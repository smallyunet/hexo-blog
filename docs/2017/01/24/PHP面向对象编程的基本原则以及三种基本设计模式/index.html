<!DOCTYPE html><html lang="zh-cn"><head><title>PHP面向对象编程的基本原则，以及三种基本设计模式</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu的博客（疯狂版）" type="application/atom+xml">
</head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
  var navbar = document.querySelector('nav.navbar');
  if (navbar) {
    navbar.classList.remove('navbar-fixed-top');
  }
}
</script><div><div class="inner"><h1>PHP面向对象编程的基本原则，以及三种基本设计模式</h1><div class="time">2017-01-24</div><ul class="tags"><li><span>#</span><a href="/tags/PHP/">PHP</a></li><li><span>#</span><a href="/tags/设计模式/">设计模式</a></li></ul><p><strong>面向对象编程的基本原则</strong>  </p>
<blockquote>
<ol>
<li>单一职责：一个类，只需要做好一件事情</li>
<li>开放封闭：一个类，应该是可扩展的，而不可修改的</li>
<li>依赖倒置：一个类，不应该强依赖另一个类。每个类对于另外一个类都是可替换的</li>
<li>配置化：尽可能地使用配置，而不是硬编码</li>
<li>面向接口编程：只需要关心接口，不需要关心实现</li>
</ol>
</blockquote>
<p><strong>PSR-0命名规范</strong></p>
<blockquote>
<ol>
<li>命名空间必须与绝对路径一致</li>
<li>类名首字母必须大写  </li>
<li>除入口文件外，其他“.php”必须只有一个类</li>
</ol>
</blockquote>
<p><strong>开发符合PSR-0规范的基础框架</strong></p>
<blockquote>
<ol>
<li>全部使用明明空间  </li>
<li>所有PHP文件必须自动载入，不能有include&#x2F;require  </li>
<li>单一入口</li>
</ol>
</blockquote>
<p><strong>类的自动载入</strong></p>
<blockquote>
<p>Test1.php</p>
</blockquote>
<pre><code class="php">&lt;?php

class Test1&#123;
    static function test()&#123;
        echo __METHOD__;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>Test2.php</p>
</blockquote>
<pre><code class="php">&lt;?php

class Test2&#123;
    static function test()&#123;
        echo __METHOD__;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>test.php</p>
</blockquote>
<pre><code class="php">&lt;?php

spl_autoload_register(&#39;autoload1&#39;);
spl_autoload_register(&#39;autoload2&#39;);

function autoload1($class)&#123;
    require __DIR__.&#39;/&#39;.$class.&#39;.php&#39;;
&#125;

function autoload2($class)&#123;
    require __DIR__.&#39;/&#39;.$class.&#39;.php&#39;;
&#125;

Test1::test();
Test2::test();
</code></pre>
<p>运行test.php会得到这样的结果：</p>
<pre><code>Test1::testTest2::test
</code></pre>
<p>__autoload()函数只可以存在一个，如果重复定义会报致命错误，所以目前一般使用spl_autoload_regisiter()来实现类的自动加载。</p>
<p><strong>PHP链式调用的实现</strong></p>
<blockquote>
<p>Database.php</p>
</blockquote>
<pre><code class="php">&lt;?php

class Database&#123;
    function where($where)&#123;
        ...
    &#125;

    function order($order)&#123;
        ...
    &#125;

    function limit($limit)&#123;
        ...
    &#125;
&#125;
</code></pre>
<p>如果Database.php是这样，那么在index.php中就需要这样来写以实现sql查询：</p>
<blockquote>
<p>index.php</p>
</blockquote>
<pre><code class="php">&lt;?php

$db=new Database();
$db-&gt;where(&quot;id=2&quot;);
$db-&gt;where(&quot;name=2&quot;);
$db-&gt;order(&quot;id desc&quot;);
$db-&gt;limit(10);
</code></pre>
<p>要实现链式调用只需要这样做：</p>
<blockquote>
<p>Database.php</p>
</blockquote>
<pre><code class="php">&lt;?php

class Database&#123;
    function where($where)&#123;
        return $this;
    &#125;

    function order($order)&#123;
        return $this;
    &#125;

    function limit($limit)&#123;
        return $this;
    &#125;
&#125;
</code></pre>
<p>在每个方法的末尾加上’return $this;’，然后就可以：</p>
<blockquote>
<p>Data</p>
</blockquote>
<pre><code class="php">&lt;?php

$db-&gt;where(&quot;id=1&quot;)-&gt;where(&quot;name=2&quot;)-&gt;order(&quot;id desc&quot;)-&gt;limit(10);
</code></pre>
<p>三种基础的设计模式包括工厂模式、单例模式和注册器模式。</p>
<p><strong>工厂模式</strong></p>
<blockquote>
<p>Factory.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Factory&#123;
    static function createDatabase()&#123;
        $db = new Database();
        return $db;
    &#125;
&#125;
$db = Factory::createDatabase();
</code></pre>
<p>工厂模式的作用在于不在类外实例化对象。</p>
<p><strong>单例模式</strong></p>
<blockquote>
<p>Database.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Database&#123;
    protected $db;
    // 第一步
    private function __construct()&#123;
        // private可以屏蔽外部new这个类
    &#125;
    // 第二步
    static function getInstance()&#123;
        if(self::$db)&#123;
            return self::$db;
        &#125;else&#123;
            self::$db = new self();
            return self::$db;
        &#125;
    &#125;
&#125;
$db = Database::getInstance();
</code></pre>
<p>单例模式用于数据库连接等只需要一个对象的场景，避免资源的浪费。</p>
<p><strong>注册器模式</strong></p>
<blockquote>
<p>Register.php</p>
</blockquote>
<pre><code class="php">&lt;?php
class Register&#123;
    protected static $objects;
    static function set($name, $object)&#123;
        self::objects[$name] = $object;
    &#125;
    static function get($name)&#123;
        return self::objects[$name];
    &#125;
    static function _unset($name)&#123;
        unset(self::objects[$name]);
    &#125;
&#125;
Register::set(&#39;db1&#39;,$db);
$db = Register::get(&#39;$db1&#39;);
</code></pre>
<p><strong>适配器模式</strong></p>
<blockquote>
<p>1.适配器模式，可以将截然不同的函数接口封装成统一的API</p>
<p>2.实际应用举例，PHP的数据库操作有mysql,musqli,pdo三种，可以用适配器模式统一成一致。类似的场景还有cache适配器，将memcache，redis，file，apc等不同的缓存函数，统一成一致</p>
</blockquote>
<blockquote>
<p>Database.php</p>
</blockquote>
<pre><code class="php">&lt;?php
interdace IDatabase&#123;
    function connect($host, $user, $passwd, $dbname);
    function query($sql);
    function close();
&#125;
</code></pre>
<p>在Database.php中定义了数据库操作的接口，接下来将MySQL、MySQLi、PDO三种数据库操作适配为接口中定义的方法。</p>
<blockquote>
<p>MySQL.php</p>
</blockquote>
<pre><code class="php">&lt;?php
namespace Database;
class MySQL implements IDatabase&#123;
    protected $conn;
    function connect($host, $user, $passwd, $dbname)&#123;
        $conn = mysql_connect($host, $user, $passwd);
        mysql_select_db($dbname, $conn);
        this-&gt;conn = $conn;
    &#125;
    function query($sql)&#123;
        $res = mysql_query($sql, $this-&gt;conn);
        return $res;
    &#125;
    function close()&#123;
        mysql_close($this-&gt;conn);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>MySQLi.php</p>
</blockquote>
<pre><code class="php">&lt;?php
namespace Database;
class MySQLi implements IDatabase&#123;
    protected $conn;
    function connect($host, $user, $passwd, $dbname)&#123;
        $conn = mysqli_connect($host, $user, $passwd, $dbname);
        this-&gt;conn = $conn;
    &#125;
    function query($sql)&#123;
        $res = mysqli_query($this-&gt;conn, $sql);
        return $res;
    &#125;
    function close()&#123;
        mysqli_close($this-&gt;conn);
    &#125;
</code></pre>
<blockquote>
<p>PDO.php</p>
</blockquote>
<pre><code class="php">&lt;?php
namespace Database;
class PDO implements IDatabase&#123;
    protected $conn;
    function connect($host, $user, $passwd, $dbname)&#123;
        new PDO(&quot;mysql:host=$host;dbname=$dbname&quot;, $user, $passwd);
        $this-&gt;conn = $conn;
    &#125;
    function query($sql)&#123;
        return $this-&gt;conn-&gt;query($sql);
    &#125;
    function close()&#123;
        unset($this-&gt;conn);
    &#125;
</code></pre>
<p>然后在应用中可以这样使用：</p>
<blockquote>
<p>index.php  </p>
</blockquote>
<pre><code class="php">&lt;?php
$db = new DatabaseMySQL();
$db-&gt;connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;test&#39;);
$db-&gt;query(&#39;show database&#39;);
$db-&gt;close();
</code></pre>
<p>或者实例化其他类型的数据库，只需要使用同一种标准。</p>
</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Y7C0CVX9PK"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-Y7C0CVX9PK');</script></html>