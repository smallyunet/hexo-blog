<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>smallyu的博客</title>
  <icon>https://smallyu.net/favicon.png</icon>
  <subtitle>smallyu的博客</subtitle>
  <link href="https://smallyu.net/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://smallyu.net/"/>
  <updated>2025-06-08T00:01:32.503Z</updated>
  <id>https://smallyu.net/</id>
  
  <author>
    <name>smallyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习王垠老师的计算机科学视频课接近尾声</title>
    <link href="https://smallyu.net/2025/06/08/%E5%AD%A6%E4%B9%A0%E7%8E%8B%E5%9E%A0%E8%80%81%E5%B8%88%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%A7%86%E9%A2%91%E8%AF%BE%E6%8E%A5%E8%BF%91%E5%B0%BE%E5%A3%B0/"/>
    <id>https://smallyu.net/2025/06/08/%E5%AD%A6%E4%B9%A0%E7%8E%8B%E5%9E%A0%E8%80%81%E5%B8%88%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%A7%86%E9%A2%91%E8%AF%BE%E6%8E%A5%E8%BF%91%E5%B0%BE%E5%A3%B0/</id>
    <published>2025-06-08T00:01:32.000Z</published>
    <updated>2025-06-08T00:01:32.503Z</updated>
    
    <content type="html"><![CDATA[<p>最近报名了王垠老师的 <a href="https://www.yinwang.org/blog-cn/2025/05/12/cs-video-course">计算机科学视频班</a>（基础班），现在学习进度已经接近尾声。因为最后一节课是选修课，我选了 Rust，而 Rust 语言本身的学习成本高，感觉不会像前几节课那样能够快速掌握并完成。不过 Rust 对我来说属于可选的进阶内容，所以并不着急结束。</p><p>前几期基础班的课程没有第八节课甚至没有第七节课，所以后两节课的内容并不影响课程本身的价值，能学到属于附加福利。我现在已经学完了前七节课，感觉收获很多。对于基础班课程内容的整体感受，我的结论是，物超所值。</p><h3 id="课程内容后续的学习计划"><a href="#课程内容后续的学习计划" class="headerlink" title="课程内容后续的学习计划"></a>课程内容后续的学习计划</h3><p>对于基础班课程内容后续的学习计划，我大概列了几条：</p><ol><li>给课程中实现的解释器写一个简单的 parser</li><li>重新做一遍所有的练习题</li><li>复刻王垠老师讲课的思路，自己写出全部课程的代码</li><li>理解练习题出题的动机，然后自己发掘新的练习题</li><li>用 Go 语言实现课程中的解释器</li></ol><p>这些目标的难度是递进的，要真实现起来需要耗费很多很多时间。所以你看，即使基础班的课程结束，但是对于其中知识的学习，还远远没有结束。基础班是一个非常好的起点，在里面学到的内容可以延展出很多有价值的东西，这个可扩展能力的价值甚至超过课程本身的价值。</p><p>基础班的知识好比非常高级的原材料，从基础班毕业就意味着拿到了这些原材料。但原材料需要经过反复打磨、锤炼、加工，才能变成更加实际可用的装备。所以我猜测有的同学学完之后感觉什么都没学到，而有的同学觉得如获至宝，能够反复加以利用并产生许多价值，大概就是这个原因吧。</p><h3 id="关于职业反思的反思"><a href="#关于职业反思的反思" class="headerlink" title="关于职业反思的反思"></a>关于职业反思的反思</h3><p>我开始反思自己的职业路径是从 4 月份开始的，当时我入职了一家新的公司，做普通的钱包后端开发。</p><p>实际的工作过程中，我发现同事以比较低的效率写着比较差的代码，整体工程能力差，但是每天工作显得忙的不可开交，领导也对他委以重任，因为他们之前就认识。</p><p>这样的现象让我很难受，我很懂区块链，但是这种懂不但没有让我的职业道路变轻松，没有给我的生活带来改善，反而在新的工作中，沦为新人一样的角色被轻视。</p><p>同样的，我有很强的工程实践能力，工作效率一向很高，但是这样能将技术设计短时间落地为工程代码的能力，不但没有给我在工作中带来应有的重视，反而在前公司受到了同事极其不尊重的对待。</p><p>所以我开始反思，是不是我的技术能力不够，是不是因为我没有上过好的学校，是不是行业环境整体的问题，是不是我过往的职业道路选择错误。</p><p>而反思的产物，就是 4 月份高频率的博客更新，尝试做一些技术产品的设计、学习新技术、改变社交态度。事实证明，只要我想，就真的可以学会使用 ZK，或者做点 EVM 相关的事情。但是这些事情还不够，我应该把这种学习能力和工程能力用到更有价值的地方。</p><h3 id="关于博客内容的反思"><a href="#关于博客内容的反思" class="headerlink" title="关于博客内容的反思"></a>关于博客内容的反思</h3><p>以前习惯于把学习到的技术、职业经历、观察到的行业现象都毫无保留分享出来，因为很多内容是我自己摸索出来的，观点也是自己经过学习和思考形成，所以分享出来没什么问题。</p><p>但是观点和知识是两种东西，从基础班学习到的知识包含很高价值，自然不可能分享。而对于博客后续的内容，也有必要进行反思和调整。</p><h3 id="区块链技术后续的学习计划"><a href="#区块链技术后续的学习计划" class="headerlink" title="区块链技术后续的学习计划"></a>区块链技术后续的学习计划</h3><p>我在区块链方面需要补齐的知识：</p><ol><li>学习研究比特币脚本</li><li>学习编写和部署 Solana、Aptos、Sui 等热门链的智能合约</li><li>学习研究 Uniswap、AAVE 之类的 DeFi 协议</li><li>调研分析一些 web3 领域知名技术人员的履历和工作成果，将其作为技术标杆提升自己</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近报名了王垠老师的 &lt;a href=&quot;https://www.yinwang.org/blog-cn/2025/05/12/cs-video-course&quot;&gt;计算机科学视频班&lt;/a&gt;（基础班），现在学习进度已经接近尾声。因为最后一节课是选修课，我选了 Rust，而</summary>
        
      
    
    
    
    
    <category term="学习" scheme="https://smallyu.net/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>想开发一个最小 EVM 虚拟机</title>
    <link href="https://smallyu.net/2025/05/11/%E6%83%B3%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8FEVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://smallyu.net/2025/05/11/%E6%83%B3%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8FEVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2025-05-10T17:15:07.000Z</published>
    <updated>2025-06-16T17:39:20.308Z</updated>
    
    <content type="html"><![CDATA[<p>我给这个项目命名为 echoevm.com，主要目标是从最简单的堆栈操作开始，逐步实现一个完整的以太坊字节码执行环境。</p><p>为什么选择这个方向？解析下以太坊客户端的技术模块：</p><ol><li>RPC：GRPC 套壳？重点在于协议设计而不是技术实现</li><li>P2P：有现成的 libp2p 可用，无非是节点发现、路由表之类，比如深入下 Kademlia DHT？</li><li>账户体系：ECDSA？密码学？</li><li>交易池：交易分析、密封交易、MEV保护方向</li><li>共识机制：共识机制的设计属于研究级别，至少得是个博士发论文、实验室里做研究、出各种测试数据，然后证明在哪方面做出了业界前沿的优化、最后融资雇人做工程化的实现</li><li>储存：搞数据库底层的专家应该干什么都一样，哪里都有用武之地，跟区块链没关系</li><li>数据结构：去研究 Merkle Patricia Tree 的实现吗？</li><li>状态同步：轻节点方向，比如用 Celestia 的核心技术把执行和储存分开，或者 Archive 节点数据的 offload？</li></ol><p>综合来看，我倾向于做一件侧重工程而不是学术、同时又有技术含量的事情，无论是从个人技术能力的提升，还是后续有可能带来的成果上，都要有意义。假如这个最小EVM开发出来了，是可以带来一系列成果的，后续也可以基于此延伸出很多更有价值的产品。</p><p>从 Solidity 语言到 bytecode 的转换过程，那是编译器专家干的事情，我要做的，是针对 bytecode 做执行，先从最简单的加法运算和 jump 开始，然后是 Gas 的计算、上下文环境的切换，直到能够执行全部以太坊历史交易。</p><p><br><br></p><h3 id="v0-0-2（2025-06-09）"><a href="#v0-0-2（2025-06-09）" class="headerlink" title="v0.0.2（2025.06.09）"></a>v0.0.2（2025.06.09）</h3><p>这个版本增加了运行 runtime bytecode 的能力，也就是先部署合约，然后再针对部署之后的合约内容，进行调用，调用的时候可以带上一些参数，比如：</p><pre><code>go run ./cmd/echoevm -bin ./build/Add.bin -function &#39;add(uint256,uint256)&#39; -args &quot;3,5&quot;</code></pre><p>这个命令的含义是，会执行 <code>./build/Add.bin</code> 文件内的 bytecode，并且调用 <a href="https://github.com/smallyunet/echoevm/blob/v0.0.2/test/contracts/Add.sol#L7">add 函数</a>，传入参数 3 和 5，最终程序运行结束后，会返回出计算结果 8。</p><p><br><br></p><h3 id="v0-0-1（2025-05-27）"><a href="#v0-0-1（2025-05-27）" class="headerlink" title="v0.0.1（2025.05.27）"></a>v0.0.1（2025.05.27）</h3><p>实现了一个非常简单的版本，现在可以用 solc 编译一个 <a href="https://github.com/smallyunet/echoevm/blob/v0.0.1/test/contracts/Add.sol">Add.sol</a> 合约，然后让 echoevm 读取生成的 <code>Add.bin</code> 部署代码，就会输出合约部署之后的运行时代码。</p><p>在实现这个版本的过程中，学习到的东西是部署代码和运行时代码的区别。我们一般会先部署一个合约到链上，然后再对这个合约产生调用，这实际上是两个不同的操作，但又都在使用相同的 EVM 执行，EVM 并不关心输入的 bytecode 是部署还是调用，只是对不同的操作码处理方式不同。一般部署代码会同时包含 <code>CODECOPY</code> 和 <code>RETURN</code> 两个操作码，可以利用这一点来区分输入的类型。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我给这个项目命名为 echoevm.com，主要目标是从最简单的堆栈操作开始，逐步实现一个完整的以太坊字节码执行环境。&lt;/p&gt;
&lt;p&gt;为什么选择这个方向？解析下以太坊客户端的技术模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RPC：GRPC</summary>
        
      
    
    
    
    
    <category term="计划" scheme="https://smallyu.net/tags/%E8%AE%A1%E5%88%92/"/>
    
    <category term="EVM" scheme="https://smallyu.net/tags/EVM/"/>
    
  </entry>
  
  <entry>
    <title>基于 ZK 和智能合约的链上身份认证系统设计</title>
    <link href="https://smallyu.net/2025/04/30/%E5%9F%BA%E4%BA%8Ezk-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E9%93%BE%E4%B8%8A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://smallyu.net/2025/04/30/%E5%9F%BA%E4%BA%8Ezk-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E9%93%BE%E4%B8%8A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2025-04-30T14:18:54.000Z</published>
    <updated>2025-06-16T01:12:31.462Z</updated>
    
    <content type="html"><![CDATA[<p>我给这个系统取名 zkgate.fun，主要想发挥零知识证明的特性，结合区块链做个小工具。</p><p>主要功能是实现，用户证明自己属于某一个群组，但是不需要暴露自己真实的链上身份。</p><p>目前的设想是这样，管理员首先有一个名单列表，可以是以太坊地址的数组，然后根据这个地址列表，计算出一个 Merkle Root Hash。</p><p>接着把这个 root hash 提交到智能合约上。</p><p>处于这个名单中的人，可以使用 Circom 电路的 proving key，来给自己生成一个 zk proof，随后将 zk proof 提交到智能合约上。</p><p>在智能合约上，会使用 Circom 电路生成的 verifier.sol，对收到的 zk proof 进行验证，判断用于生成 zk proof 的地址，是否在 Merkle Root Hash 中，最后将判断结果返回。</p><p>这样的话，管理员不需要公开自己的群组中有哪些地址，属于群组中的地址也不需要声明自己的身份，只需要提交零知识证明生成的 zk proof，就可以证明自己真的归属于这个群组。</p><p>我接下来会具体在技术上实现这个设计。</p><br><h3 id="更新（2025-05-14）"><a href="#更新（2025-05-14）" class="headerlink" title="更新（2025.05.14）"></a>更新（2025.05.14）</h3><p>有一个现有的、以太坊基金会支持的、工具链和生态都已经比较成熟的 zk 协议，同样是用来做身份验证的项目，叫 Semaphore，官网是这个，可以直接在上面体验一下包含前端界面的 Demo：</p><ul><li><a href="https://semaphore.pse.dev/">https://semaphore.pse.dev/</a></li></ul><p>在 zkgate.fun 前面两个版本的迭代中，没有选择 Semaphore 使用 EdDSA 账户体系的方案，主要是不想脱离以太坊的账户体系，也不想放弃 ECDSA，而实际上只有 EdDSA 是 zk 友好的，可以使用 Poseidon Hash 签名，zk 电路中也能对签名进行验证，不需要 “链下签名、链上 recover” 这种丑陋的实现方式。</p><p>不得不说，从个人学习的角度，虽然没几天的时间，但是我已经大概理解了 zk（工具链）的操作过程。从行业前沿的角度，我仅凭个人力量不可能做的比 Semaphore 更好。即使 zkgate.fun 进一步开发出前端界面、可视化地演示出具体的交互过程，也顶多就是 Semaphore 的这个 <a href="https://demo.semaphore.pse.dev/">Demo</a> 的样子，而且技术上没有 Semaphore 硬核。</p><p>所以 zkgate.fun 这个项目不再继续开发，域名一年后会自动到期，不再续费。</p><br><h3 id="更新-v0-2-0-版本（2025-05-13）"><a href="#更新-v0-2-0-版本（2025-05-13）" class="headerlink" title="更新 v0.2.0 版本（2025.05.13）"></a>更新 v0.2.0 版本（2025.05.13）</h3><p>这个版本解决了验证地址所有权的问题，基本思路是让 zk 证明和地址所有权的证明分开，链下用 zk 证明地址的路径在 Merkle Root 上，链上需要用户提交用私钥对 root 的签名，并且将签名提交到链上。然后合约 recover 出签名的地址，跟 zk 电路的 prove 中包含的地址信息对比。</p><pre><code>1. zk prove 包含地址信息 -&gt; 链上验证 zk prove -&gt; 得知 zk prove 中的地址信息2. 用私钥对 root 签名 -&gt; 链上得到签名 -&gt; recover 出签名对应的地址信息3. 判断 zk prove 中的地址 == 签名 recover 出的地址</code></pre><p>演示代码具体改动的地方有：</p><ol><li>offchain 部分的代码不需要变动，生成 inputs.json 的脚本中 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.2.0/offchain/smt.js#L37">inputs</a> 里已经有 key 的信息了 </li><li>电路代码中，需要把 inputs 中的 key 变为 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.2.0/circuits/merkleSmtProof.circom#L27">public</a></li><li>合约代码需要接受用户的 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.2.0/hardhat/contracts/ZkGateRegistry.sol#L38">签名</a> 作为参数，并且得到 recover 出的<a href="https://github.com/smallyunet/zkgate-demo/blob/v0.2.0/hardhat/contracts/ZkGateRegistry.sol#L49">地址</a>，将这个地址与 proof key 进行对比</li><li>调用合约的脚本，需要用私钥对 root 进行<a href="https://github.com/smallyunet/zkgate-demo/blob/v0.2.0/hardhat/scripts/prove.js#L44-L45">签名</a>，并且把签名数据作为参数调用合约</li></ol><p>到此为止，zkgate.fun 实现的功能是，群组管理员不必在链上公开自己的群组成员信息，只需要提交 Merkle Root Hash 到链上。对于群组内的成员，需要完整的成员列表，以及自己地址对应私钥签名后的信息，就可以生成 zk prove 去链上，证明自己确实是群组内的成员。</p><p>在这个过程中，使用 zk 唯一隐藏掉的信息，是群组成员的完整信息不必上链公开，只需要一个 Merkle Root Hash。而用户的地址目前无法隐藏，必须提交到链上用于验证。</p><br><h3 id="更新-v0-1-0-版本-2025-05-09"><a href="#更新-v0-1-0-版本-2025-05-09" class="headerlink" title="更新 v0.1.0 版本 (2025.05.09)"></a>更新 v0.1.0 版本 (2025.05.09)</h3><p>首先要纠正之前设计中的一个错误的地方，就是管理员必须要公开自己群组的地址列表，否则无法根据地址列表来生成 Merkle Tree，用户也无法根据树结构，来找到自己地址所在的节点位置、生成路径证明。</p><p>其次是很高兴地说，现在跑通了一个非常初级的 Demo（<a href="https://github.com/smallyunet/zkgate-demo">smallyunet&#x2F;zkgate-demo</a>），这个 Demo 功能并不完善，甚至没有办法在电路中验证地址的所有权，但至少是一个工具链路层面的跑通。</p><p>具体实现是这样：</p><ol><li>有一个 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/offchain/smt.js">链下程序</a> 来根据地址列表，以及自己的地址，生成 zk 电路的 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/offchain/inputs.json">inputs.json</a>，这个输入文件包含了 Merkle Root Hash 和验证节点位置所需要的路径</li><li>根据 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/circuits/merkleSmtProof.circom">电路代码</a> 来编译出一些 <a href="https://github.com/smallyunet/zkgate-demo/tree/main/circuits/build">二进制文件</a>，这些编译后的产物是用来生成 witness 文件的</li><li>基于公开的 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/circuits/run.sh#L17-L28">ptau 文件</a> 生成 .zkey 文件</li><li>从 .zkey 文件中导出 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/circuits/proof.json">proof.json</a>, <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/circuits/public.json">public.json</a>, <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/circuits/verification_key.json">verification_key.json</a>，这 3 个 json 文件可以做链下离线验证，证明 prove 的有效性</li><li>从 .zkey 文件中导出 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/circuits/contracts/Groth16Verifier.sol">.sol 文件</a>，也就是智能合约代码，部署到链上</li><li>拿着 prove.json 文件和 public.json 文件的内容，作为 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/hardhat/scripts/prove.js#L41">参数</a> 调用合约的 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/circuits/contracts/Groth16Verifier.sol">verifyProof</a>函数，如果 prove 有效则返回 true，否则返回 false</li></ol><p>假如一个地址不在群组列表中，有两种情况：</p><ol><li>试图用一个不在群组列表中的 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/offchain/smt_non_member.js#L24">地址</a> 生成 inputs.json，然后拿着 inputs.json 去根据电路生成 prove，会直接被电路拒绝报错</li><li>试图用一些假的 <a href="https://github.com/smallyunet/zkgate-demo/blob/v0.1.0/hardhat/scripts/fakeProofWithCorrectRoot.js#L26">prove 参数</a> 提交到链上做验证，最终无法通过链上验证</li></ol><p>那么目前这个最初级版本的 Demo，问题在于，构建 prove 使用的是明文地址，比如：</p><pre><code class="js">const members = [  &quot;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&quot;,  &quot;0x70997970C51812dc3A010C7d01b50e0d17dc79C8&quot;,  &quot;0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC&quot;,];const proofKey = toField(members[0]);const &#123; siblings &#125; = await tree.find(proofKey);</code></pre><p>这个语句的含义是在让 zk 电路判断，<code>members[0]</code> 是否属于 <code>members</code> 数组构建出来的树结构，这显然是属于的。如果想要用不属于群组的地址构建 prove，只需要替换一下 proofKey 指向的地址：</p><pre><code class="js">const nonMemberAddress = &quot;0x1234567890123456789012345678901234567890&quot;;const proofKey = toField(nonMemberAddress);const &#123; siblings &#125; = await tree.find(proofKey);</code></pre><p>也就是说，members 列表必须是公开的，而现在的程序只能判断一个地址在不在 <code>members</code> 里面，但即使 <code>members[0]</code> 不是我的地址，我也能用来构建一个合法的 prove。那还要 zk 干嘛？</p><p>所以下一步要解决的问题，是让用户用私钥对某个消息进行签名，然后在 zk 电路中根据签名 recover 出地址，接着判断 recover 出来的地址是否属于 members 数组。</p><p>这个过程是不是听起来简单？可实际上用 zk 电路来 recover 出一个 ECDSA 签名算法的地址，别说复杂度非常高，难度就像用乐高搭核电站一样。难怪人们都说，搞 zk 真的很掉头发。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我给这个系统取名</summary>
        
      
    
    
    
    
    <category term="计划" scheme="https://smallyu.net/tags/%E8%AE%A1%E5%88%92/"/>
    
    <category term="zk" scheme="https://smallyu.net/tags/zk/"/>
    
  </entry>
  
  <entry>
    <title>关于 web3 打赏系统的设计</title>
    <link href="https://smallyu.net/2025/04/29/%E5%85%B3%E4%BA%8Eweb3%E6%89%93%E8%B5%8F%E7%B3%BB%E7%BB%9Fgiveme-wtf%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://smallyu.net/2025/04/29/%E5%85%B3%E4%BA%8Eweb3%E6%89%93%E8%B5%8F%E7%B3%BB%E7%BB%9Fgiveme-wtf%E7%9A%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2025-04-29T11:26:45.000Z</published>
    <updated>2025-06-16T01:12:45.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="产品形态"><a href="#产品形态" class="headerlink" title="产品形态"></a>产品形态</h3><p>giveme.wtf 是我刚注册的一个域名，计划做一个 web3 打赏的小工具，类似的 web2 平台有：</p><ul><li><a href="https://buymeacoffee.com/">https://buymeacoffee.com/</a></li><li><a href="https://linktr.ee/">https://linktr.ee/</a></li></ul><p>与之不同的是，giveme.wtf 的个人页面上，将显示 web3 钱包的收款地址、二维码，就像 Paypal 的个人收款链接一样，并且同时支持多种链的地址格式，包括比特币、以太坊、狗狗币等，可以自由选择。</p><p>giveme.wtf 不做任何资金的中转，仅仅只是展示打赏地址这一信息，比如，访问 giveme.wtf&#x2F;{username}，这个页面将显示出 username 设置好的收款地址信息，包括以太坊地址文本是什么，二维码是什么。就这么简单。</p><p>当然 giveme.wtf&#x2F;{username} 下，也可以设置简单的 bio，头像、域名、社交媒体等，像是一个小型的个人主页，让人知道你是谁，稍微更值得分享出去一点。</p><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><ul><li>注册</li></ul><p>user 使用 MetaMask 钱包注册，连接钱包后可以设置 username，username 是全局唯一的，在智能合约上管理，user 需要发一笔与合约交互的交易，来将自己心仪的 username 提交到合约上。</p><ul><li>profile 信息</li></ul><p>绑定好 EVM 地址与 username 的关系后，就可以设置 profile 信息，包括头像、bio、钱包地址等。</p><p>填写信息后，前端页面将数据提交到后端，后端用 IPFS 节点保存这些数据（长期开启 Pin），同时生成 CID 信息，将 CID 返回给前端。</p><p>前端收到 CID 后，再发起一次合约交互，将 username-&gt;CID 的映射关系，写入到智能合约里。这个步骤可以和注册步骤合并，也可以拆开，因为有时候 user 只想注册，不想设置 profile。</p><ul><li>展示</li></ul><p>合约上的 username-&gt;CID 是最权威的数据，前端页面将根据 giveme.wtf&#x2F;{username} 中的 username，从合约中获取到 CID，再拿着 CID 去 IPFS 的网关查询出具体数据，根据数据渲染出页面。</p><p>profile 会是一些非常精简的 json 数据，数据量很小，同时为了加快网关的查询速度，可以用 Cloudflare 提供的 web3 gateway CDN。</p><ul><li>网络选择</li></ul><p>智能合约部署在 base 上。</p><h3 id="扩展优化"><a href="#扩展优化" class="headerlink" title="扩展优化"></a>扩展优化</h3><p>后期可以根据链上数据，统计出使用打赏系统的收款地址，以及收到打赏的金额总量，做个排行榜，按照 username 或者链分类，分析出一堆数据。</p><p>如果上了排行榜，username 下的 bio 可以增大曝光率。给你心目中的偶像上分吧，让他保持在榜首。</p><p>还可以增加一些 24小时榜单、PK 性质之类的排名。</p><p>同时也可以扩展到社交系统，如有打赏记录的地址可以形成关系图谱，甚至可以直接以某种 IM 工具的方式通讯、自动拉群等。</p><h4 id="username-找回"><a href="#username-找回" class="headerlink" title="username 找回"></a>username 找回</h4><p>MetaMask 钱包注册的问题在于，钱包丢了怎么办，是不是就失去了对 username 的控制。这里可以设计一个恢复机制，比如允许 username 设置一个恢复地址列表，只要是这个恢复列表中的地址，都可以找回 username 的控制权，进而改变 username 对应的 CID。这个机制主要是针对钱包遗失的情况。</p><p>至于钱包被黑了怎么办，黑客岂不是能直接修改恢复地址的列表。他都已经有 username 控制权了，再改也是改成他的地址，加固他对 username 的控制权。那么有没有钱包被黑还能夺回控制权的办法？web3 里没有。</p><h4 id="网络的选择"><a href="#网络的选择" class="headerlink" title="网络的选择"></a>网络的选择</h4><p>目前必须要选择一条链来部署智能合约，智能合约是数据正确性的来源。那么选择哪条链其实是个问题，因为作为 user，不一定有链上的代币作手续费。</p><p>比如选择了 base，那么 user 首先得有 ETH，其次得在 base 上有 ETH，然后才能后续的操作。光是这两步，就能劝退大多数人。</p><p>那么为了解决这个问题，后面可以考虑的方向是手续费代付，用 ERC-4337 （现在差不多凉了）的 paymaster，或者比较原始的 Meta Transaction 方式。但是又得考虑到薅羊毛的问题，代付也得付得起才行。</p><h4 id="数据可用性"><a href="#数据可用性" class="headerlink" title="数据可用性"></a>数据可用性</h4><p>MVP 里的方案是，数据用 IPFS 存，但仅仅只有一个服务器。IPFS 是比较底层的文件路由协议，可以考虑在上面包一层，像 Filecoin 一样，但是不会有 Filecoin 那么复杂，因为 giveme.wtf 的数据量比较小。PoST 难用的地方就在于需要对文件做加密解密，因为文件太大又不能全量校验，但 giveme.wtf 不一样，往简单了做就行，比如验证一下 Merkle Root Hash，也就是说，后面需要在 IPFS 的基础上，加上适当的文件校验和激励机制，让更多的节点愿意存下 giveme.wtf 完整的数据，然后用一种方式来定期检查每个节点是否真的储存了完整数据，如果存了，就给一点奖励。具体奖励给什么再说。</p><h4 id="链下数据缓存"><a href="#链下数据缓存" class="headerlink" title="链下数据缓存"></a>链下数据缓存</h4><p>每次前端页面都从合约上查 username-&gt;CID，交互太慢了，而且消耗节点的 rpc 资源。需要考虑链下来缓存这部分数据，比如有一个中心化的后台程序，监听合约的事件，实时拿到 username-&gt;CID 的内容，然后写入到 Cloudflare Workers KV 服务里。前端页面首先请求 Cloudflare Workers KV，如果没有内容再 fallback 到合约上查。</p><p>那么这里又涉及到一个问题，如果中心化的服务作恶，或者被黑了怎么办，username-&gt;CID 的映射关系一改，钱直接打到黑客的地址上了。</p><p>这个链下数据完整性校验的问题，其实是 Optimistic Rollup 在解决的问题，也有相对成熟的方案。然后结合 Zetachain 的跨链逻辑，可以这样设想。</p><p>首先用来缓存的链下程序，将每一个 username-&gt;CID 的数据作为子节点，构建一个 Merkle Tree，最终会得到一个 Merkle Root Hash，这个 root hash 将是校验数据完整性的凭证，把这个 root hash 定时提交到合约上，前端页面去合约上查一下这个 root hash，就可以知道从缓存里拿到的 CID 有没有被篡改。</p><p>其次链下的索引程序可以有多个，通过 TSS 协商出一个私钥，只有这个私钥，才可以向合约提交 Metkle Hash Root，并且这多个索引程序，只有 root hash 相同，才会协商成功。相当于做了多签。</p><p>最后是冷静期+挑战期，Merkle Root 提交之后，在冷静期内不生效，同时任何人都可以发起挑战，如果挑战成功，则新提交的 Root 作废，继续用旧的 Root。当然这个步骤中的挑战是很麻烦的，得考虑到怎么发起挑战，尤其是怎么挑战才算是成功这个机制。但是好在不用着急做那么复杂，这个属于后期可以优化的方向。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;产品形态&quot;&gt;&lt;a href=&quot;#产品形态&quot; class=&quot;headerlink&quot; title=&quot;产品形态&quot;&gt;&lt;/a&gt;产品形态&lt;/h3&gt;&lt;p&gt;giveme.wtf 是我刚注册的一个域名，计划做一个 web3 打赏的小工具，类似的 web2</summary>
        
      
    
    
    
    
    <category term="计划" scheme="https://smallyu.net/tags/%E8%AE%A1%E5%88%92/"/>
    
    <category term="web3" scheme="https://smallyu.net/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>因为同事的不尊重，我换工作了</title>
    <link href="https://smallyu.net/2025/04/13/%E5%9B%A0%E4%B8%BA%E5%90%8C%E4%BA%8B%E7%9A%84%E4%B8%8D%E5%B0%8A%E9%87%8D%EF%BC%8C%E6%88%91%E6%8D%A2%E5%B7%A5%E4%BD%9C%E4%BA%86/"/>
    <id>https://smallyu.net/2025/04/13/%E5%9B%A0%E4%B8%BA%E5%90%8C%E4%BA%8B%E7%9A%84%E4%B8%8D%E5%B0%8A%E9%87%8D%EF%BC%8C%E6%88%91%E6%8D%A2%E5%B7%A5%E4%BD%9C%E4%BA%86/</id>
    <published>2025-04-13T03:15:26.000Z</published>
    <updated>2025-05-05T12:35:28.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这些内容在 4月2日就写好了，原计划进入新工作后一周再发出来。这是我自己对这件事情的总结。</p></blockquote><h3 id="契机"><a href="#契机" class="headerlink" title="契机"></a>契机</h3><p>前段时间有一个同事（老员工，被重用那种，不然也不会摆那么大的谱），在群里发表了针对我的不友善言论，让我感觉有点生气，他说的话类似于 “你写的代码很垃圾”、“以后不要再让我 review 你的代码”、“这种代码谁爱合谁合，反正我不合” 之类，与其说是在表达对我代码的不满意，更像是在撒泼式的宣泄自己内心对生活的不如意，随便找个借口找个场合发泄。</p><p>这件事情本身的前因后果我都没有动力去讨论，因为很明显不是行为规范的问题，而仅仅只是他个人的情绪问题。我对造成这件事情的深层原因，总结为团队内部的管理混乱、每个人职责不分明。但原因是什么不重要，我会用实际行动来表达对这种工作环境的不满意。</p><p>在这件事情的过程中，我感受到的是一种不尊重，也因此写了《<a href="/2025/03/22/%E4%BB%8E%E5%9B%A2%E9%98%9F%E5%86%85%E9%83%A8%E7%9A%84%E6%B7%B7%E4%B9%B1%E6%83%B3%E5%88%B0%E2%80%A6%E2%80%A6/">从团队内部的混乱想到……</a>》和《<a href="/2025/03/25/%E5%85%B3%E4%BA%8E-Code-Review-%E7%9A%84%E7%A4%BC%E8%8A%82/">关于 Code Review 的礼节</a>》来委婉的提及一些当时的情况。</p><p>“尊重” 重要吗？我的出身并不好，谈不上什么尊重，更没有资格要求别人尊重我什么的，毕竟别人对你怎么样，是别人的事情，我又怎么能左右呢，说到底还是我自己的能力不够强大，强大到让别人主动尊重我。那么抛开原生家庭和个人教养的问题，对于我来说，在这件事情上，“尊重” 重要吗？</p><p>很简单，如果我能找到工作，那么就很重要，这件事情已经是一个非常充足的让我换工作的理由。如果我找不到工作，那就不重要，在生存和挣钱面前，受这么点气算什么呢，我要是一旦离开这个项目就再也找不到工作了，那我也就这么点水平，受气也是活该，忍着呗，还能怎么着。</p><p>我是毫无理由去忍受这种来自同事的情绪的，所以我现在确实已经离职、并且开始新的工作了。这件情绪上的事情算是一个契机，让我有足够动力开始改好简历、进行找工作这件事情，不然可能不会这么早主动换工作，会稍微晚一点，等等看项目进一步的情况。但是因为这件事情，我就不想等了。</p><h3 id="整体原因"><a href="#整体原因" class="headerlink" title="整体原因"></a>整体原因</h3><p>对于换工作的原因，除了这件情绪上的事情作为契机外，也有一些项目整体的因素在里面，总体来说，为什么现在到了一个需要换工作的时候？</p><p>从项目整体看，项目现在在往 AI 方向发展，全面转型到 AI，几乎放弃了区块链方面的叙事，老板从外部邀请了整个 AI 团队做事情，后续在区块链方面不需要有什么功能上的迭代。我也有听到说，老板提到过精简团队的事情，需要用到人再招，也确实精简掉一个人。虽然没有精简掉我，但这显然是一个不好的信号。</p><p>从内部管理看，团队内部的管理比较混乱，人员之间的协作很糟糕，工作协调起来比较困难，尤其是作息时间上的差异，偶尔会引起一些问题。人员素质层次不齐，虽然现在人数逐渐减少、没几个人了。整体工作氛围让人不是很舒服。</p><p>在工作内容上，最近一段时间开始，逐渐进入了没事找事的状态，没有什么紧急的需求需要做，尤其最近做的大都是一些不重要的事情，做也行不做也没差，纯粹只是为了工作而工作，让每个人显得在工作。一般来说工作进入到这种状态，也是一种非常不好的的信号。</p><p>从内部团队的前景看，整个团队能不能做成事情，几乎依赖于 Leader 的个人判断，能做什么事情、需要做什么事情、交付结果的上限是什么，都取决于 Leader 的个人能力，这对团队来说不是好事。曾经就出现过 Leader 一人判断失误，导致整个团队的努力都白费的情况。当然 Leader 本人的学习速度和改进自己的速度非常快，在意识到失误后能够在短时间内频繁做出调整，整体上是在往好的方向发展的，这一点上我还是佩服的。如果不是 Leader 有这种迅速调整的能力，我换工作可能比现在还得提前几个月。</p><p>总的来说，从各方面角度看，都有一些让自己换工作的理由，所以总结起来，目前到了一个需要换工作的时候。</p><p>（注意，换工作的原因里完全不包括我自己对项目和赛道的评价和看法。我在入职 3 天的情况下头脑里就对这个项目产生过怀疑，具体细节在《<a href="/2024/11/18/Restaking%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E6%B5%8E%E9%9A%BE%E9%A2%98/">Restaking 项目的经济难题</a>》，时至今日我作为项目内部的开发人员，都没有找到这个问题的答案。但我想说的是，这些丝毫不影响我愿意在这个项目上继续工作，并且希望能把项目做好。事实上，我们比外部的人更希望项目能越来越好，因为我们本身就是利益相关者。所以，我想再次强调，换工作和项目本身的好坏无关，只是工作氛围的问题） </p><p><br><br></p><h3 id="补充（2025-04-20）"><a href="#补充（2025-04-20）" class="headerlink" title="补充（2025.04.20）"></a>补充（2025.04.20）</h3><p>不尊重人这件事情，真是一种习惯。在离职后的工作交接中，他希望我拿出一天的时间来做某件事情，我答应了，说是周末可以。</p><ul><li>我周六上午问，今天还是明天，要不今天（周六）吧？他说周日。</li><li>我周日上午 9 点问，几点开始？他 12 点左右回复，原话是 “我有一个思路了。看晚点儿 meeting 过一下”。</li><li>我接着问，“晚点儿” 是指晚上吗？（对方已读）</li><li>我迟迟（3个小时内）没有收到回复。</li></ul><p>单从这个对话内容看，我实在没看懂什么意思，到底是要我干嘛，到底是什么时候？我已经预先准备出了一天的时间，对方反而爱搭不理的样子。难道是觉得我一整天都会坐在电脑前等待回复，处于待命状态吗？搞不懂。难道是觉得我应该迁就他的时间吗？我已经离职了呀。</p><p>要么就是不尊重人，要么就是缺乏基本的职业素养，约个时间约个会这么简单的事情都做不好，搞不懂……</p><p>话说回来，其实从我入职以来，在他的作息时间上，就感觉有很多问题。比如，几乎每天的早会，他都是 “在外面”，要么直接就不参加早会了，三番五次缺席早会，上午基本上处于不太在线的状态。再比如，中午 12 点到 3 点之间，基本上不在线，要午休。再比如，下午 5 点开始出门去打球，5点到7点左右必然不在线。</p><p>他最活跃的时间段是晚上 10 点到 12 点，每天10点开始，群里就开始有消息了，甚至12点直接给我打电话，说哪里的代码怎么怎么样。</p><p>我刚入职的时候，本来白天就正常工作了 8 个小时，到晚上该下班了，结果一到 9 点多 10 点，他上线并且开始活跃了，开始进一步推进工作，我作为新人只好奉陪了几天。也就导致我刚入职的一段时间，加班频率和强度都挺高的，根本原因就是在迁就他的作息时间。</p><p>后来由于工作内容的变化，我和他合作没那么紧密，我就开始忽略他的消息了，只要超过 10 点钟的消息，我直接就不看了。</p><p>从我的描述应该能看出来，跟这样的人一起工作其实很难受，作息时间上存在很大的差异，你找他他不在，他找你你不想回，工作很难推进。更大的问题在于，团队默认允许这种的现象存在，你说团队的问题到底来自于哪里？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这些内容在 4月2日就写好了，原计划进入新工作后一周再发出来。这是我自己对这件事情的总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;契机&quot;&gt;&lt;a href=&quot;#契机&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>鼓吹 Cursor 的人技术能力都差</title>
    <link href="https://smallyu.net/2025/04/12/%E9%BC%93%E5%90%B9Cursor%E7%9A%84%E4%BA%BA%E6%8A%80%E6%9C%AF%E8%83%BD%E5%8A%9B%E9%83%BD%E5%B7%AE/"/>
    <id>https://smallyu.net/2025/04/12/%E9%BC%93%E5%90%B9Cursor%E7%9A%84%E4%BA%BA%E6%8A%80%E6%9C%AF%E8%83%BD%E5%8A%9B%E9%83%BD%E5%B7%AE/</id>
    <published>2025-04-12T12:33:38.000Z</published>
    <updated>2025-04-12T12:52:21.797Z</updated>
    
    <content type="html"><![CDATA[<p>有点标题党，不要太介意。我想表达的是不应该过于关注使用的工具。很简单的逻辑，只有自己工程能力不如 Cursor，才会觉得 Cursor 厉害，干什么都行。当然这句话属于比较空的废话。</p><p>事实上，Cursor 的代码补全能力没有比 GitHub Copilot 好多少，底层使用的模型是一样的，不是 Claude 就是GPT。而在工程化调教方面，Cursor 和 Copilot 都是在把一些文件作为 context，继续后面的对话。</p><p>Cursor 比 Copilot 好一点的地方在于，会自己去当前工程目录下，搜索和参考其他文件的写法，这一点确实有用，你不需要告诉他具体引用那哪些文件，他自己会不断的尝试，Copilot 这种插件是不具备这种能力的，这确实是好的一面，如果项目下存在大量可复用的代码，Cursor 可以比较好的发挥出它的能力。</p><p>但有时候又会觉得 Cursor 过度智能，它甚至会自己在你的工程下面创建新文件，而不需要经过你同意，这就导致在用 Cursor 的时候需要时刻关注，他是否改变了你预期之外的代码文件。相比之下，（GoLand 下的）Copilot 只是插件的形式，只会给出代码片段，用不用是你自己的事情。VS Code 下的 Copilot 现在和 Cursor 倒是有类似的体验了，会给你一个接受或不接受更改的选项。</p><p>所以相比来说， Cursor 和 Copilot 使用了一样的大语言模型（不会有人觉得 Cursor 自己训练了个模型出来吧），然后 Cursor 拥有更大的、项目级别的控制力，而 Copilot 像他的名字一样，只是辅助级别的能力，这是它们最大的区别。</p><p>回到模型本身，o1 是迄今为止最厉害的模型，在日常工作中深有体会，我经常用 o1 来精准定位编程中遇到的 bug，而对于相同的问题，其他模型往往给出错误或者不准确的解释，包括 o3-mini-high 和 4o。</p><p>比如，在调用智能合约的时候，原本的命令是</p><pre><code>cast call requestPrice(string) &quot;BTC&quot; —-rpc-url=http://eth:8545</code></pre><p>现在需要调用另一个函数，比原本的函数多了一个入参，我就直接复制代码写成</p><pre><code>cast call requestPrice(string) &quot;BTC&quot; &quot;USD&quot; —-rpc-url=http://eth:8545</code></pre><p>不知道你有没有第一时间看出问题？其实 4o 倒是给出了正确的分析，只是没有特别精准，给出了 3 种有可能的错误原因，而 o1 直接就说对了。</p><p>当然大模型之间的差异不会体现在这么微小的问题上，只是正好有印象就随便提一下，我想表达的是，从日常体验来看，o1 是最好用的模型。</p><p>我严重怀疑鼓吹 Cursor 的人，都是之前没有使用过 AI、体会过 AI 强大能力的人，在用到 Cursor 之后，才明白原来现在的生成式 AI 已经这么强大了，欣喜若狂。而当需要使用生成式 AI 的时候，他们的第一反应不是打开 ChatGPT 的聊天框或者 Gotk3 的界面，而是打开了 Cursor 的代码框，开始去聊天。</p><p>所以鼓吹 Cursor 的人，实际上是把生成式 AI 的能力，误以为是 Cursor 的能力，才因此觉得 Cursor 异常强大。</p><p>我在工作中就不止一次被强烈推荐使用 Cursor ，让我别再用 GoLand，还说出 “GoLand 就是垃圾” 这种话，Cursor 最好用什么的。</p><p>首先我一直觉得喜欢用什么编辑器是个人的选择，管这个干啥。其次如果觉得使用什么编辑器会给使用者带来鄙视链和优越感，未免有点小儿科。最后就是我喜欢用 GoLand 的理由，只有两点：1.箭头非常直观的表达了接口的实现关系。2.前进后退快捷键很好用。基于这两点，我才可以比较快速的读懂和理解代码。</p><p>也因此带来一个差异是，使用 GoLand 的人，往往更加关注代码逻辑，比如在寻找代码位置的时候，喜欢通过代码之间的跳转，例如接口的实现关系等。而使用 Cursor（VS Code）的人，更加关注项目的目录结构、文件名、文件的位置，因为 Cursor 没有提供很好的代码跳转功能，所以不得不更加依赖通过项目结构来梳理代码功能。</p><p>代码的自动补全方面，GoLand+Copilot 插件能应付日常场景，需要补全的往往是打日志之类的内容，简单用用就可以，我不太敢用 AI 写侧重逻辑的代码。</p><p>给我推荐使用 Cursor 可能还有一种心理就是，觉得我不知道怎么使用 AI，或者觉得我不知道怎么使用 Cursor (?)，也挺奇怪的。我在 2023 年（ChatGPT 开始大火的那段时间）就试用了 ChatGPT，还写了《<a href="/2023/03/30/%E4%B8%8D%E8%A6%81%E5%B0%8F%E7%9E%A7-ChatGPT/">不要小瞧 ChatGPT</a>》，而现在不论是日常工作还是生活，都在高频率使用 ChatGPT。</p><p>总的来说，我的意思是，你可以喜欢 Cursor，也可以使用 Cursor，但最好不要鼓吹 Cursor。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;有点标题党，不要太介意。我想表达的是不应该过于关注使用的工具。很简单的逻辑，只有自己工程能力不如 Cursor，才会觉得 Cursor 厉害，干什么都行。当然这句话属于比较空的废话。&lt;/p&gt;
&lt;p&gt;事实上，Cursor 的代码补全能力没有比 GitHub Copilot</summary>
        
      
    
    
    
    
    <category term="AI" scheme="https://smallyu.net/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>关于 Code Review 的礼节</title>
    <link href="https://smallyu.net/2025/03/25/%E5%85%B3%E4%BA%8E-Code-Review-%E7%9A%84%E7%A4%BC%E8%8A%82/"/>
    <id>https://smallyu.net/2025/03/25/%E5%85%B3%E4%BA%8E-Code-Review-%E7%9A%84%E7%A4%BC%E8%8A%82/</id>
    <published>2025-03-25T13:45:43.000Z</published>
    <updated>2025-03-25T13:45:43.550Z</updated>
    
    <content type="html"><![CDATA[<p>前情提要，推荐王垠的两篇博客文章：</p><ul><li>《<a href="https://www.yinwang.org/blog-cn/2015/03/03/how-to-respect-a-programmer">怎样尊重一个程序员</a>》</li><li>《<a href="https://www.yinwang.org/blog-cn/2015/03/11/git-etiquette">关于Git的礼节</a>》</li></ul><p>由于过往不规范的工作经历，我之前是缺少对 Code Review 的理解的。最近因为同事对这个问题情绪化的表达，我开始关注到关于 Code Review 的问题。</p><h3 id="基本礼仪：不要用-FYI"><a href="#基本礼仪：不要用-FYI" class="headerlink" title="基本礼仪：不要用 FYI"></a>基本礼仪：不要用 FYI</h3><p>谷歌公开出来的 Code Review 规范 《<a href="https://google.github.io/eng-practices/review/reviewer/standard.html">The Standard of Code Review</a>》已经非常具有指导意义，内容很全面，包括我现在实际遇到的流程问题，也完全可以依照这个规范来消化解决。当然前提是所有团队成员事先对这个规范的内容已经达成一致，而不是假设公司的员工已经知道并且开始遵循这个规范。</p><p>关于规范（TSCR）中已经提到的流程问题、礼貌问题，这里是不需要赘述的。我关注到的是其中一个小章节《<a href="https://google.github.io/eng-practices/review/reviewer/comments.html#label-comment-severity">Label comment severity</a>》，也就是对 Code Review 之后的 comment 进行重要程度的区分，并且加上前缀，让 author 可以明确知道哪些留言是必须要改的，哪些是无关紧要的。</p><p>除去必须要改的 comment 不加前缀，谷歌的规范中提到有三类前缀，这些都是指站在 Reviewer 的立场，如何去写 comment，本质上这三类前缀都不影响代码的 approve 和合并：</p><ul><li><code>Nit</code> (Nitpick): 你应该改，但是不改我也能接受。</li><li><code>Optional</code>：只是建议，你自由选择改还是不改。</li><li><code>FYI</code> (For Your Information)：这个 PR 中完全不需要因此有改动，但我觉得这是一个有意思的点，后续你可以关注下。</li></ul><p>其中第三个前缀 FYI，每当看到 For Your Information 这个短语的时候，我总是下意识的会把这个短语翻译为中国传统社会普遍流行的一句古话： “为了你好”。</p><p>相信在中国本土长大的华人，即使没有遭受过严苛古怪的家庭教育，也都能深刻理解到 “为了你好” 的威力。</p><p>为了你好，你要好好学习<br>为了你好，你不能打游戏<br>为了你好，你要考公务员<br>为了你好，你要早点结婚<br>为了你好，你必须生孩子<br>……</p><p>一些情况下，父母的 “为了你好” 只是他们满足自己变态控制欲望的借口，另一些情况下，有些父母发自真心的 “为了你好”，然后由于自身有限的眼光给出了不正确的建议。</p><p>总的来说，中文语境下的 “为了你好” 绝不是什么好词，如果把这种话语带到工作中，就更匪夷所思了。虽然 For Your Information 并不能直译为 “为了你好”，但是为了避免歧义，还是建议大家不要使用这样的话术。</p><p>所以，Code Review 的基本礼仪就是，不要用 FYI。</p><h3 id="为什么-“为了你好”-往往是错的"><a href="#为什么-“为了你好”-往往是错的" class="headerlink" title="为什么 “为了你好” 往往是错的"></a>为什么 “为了你好” 往往是错的</h3><h4 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h4><p>因为没有人可以在实际上了解另一个人。</p><p>父母真的了解自己的孩子吗？结婚多年的夫妻，真的知道对方的心思吗？审查犯人的警察，足够了解自己在调查的罪犯了吗？心理学的专家，能猜到自己女朋友早上为什么生气吗？对于每一个人，你真的了解自己吗？</p><p>所以其实可以得到这样一个和技术无关的结论，出于礼貌，我们应该尽量避免对别人说 “为了你好”。</p><h4 id="具体事例"><a href="#具体事例" class="headerlink" title="具体事例"></a>具体事例</h4><p>最近的工作中，我提交的代码包含一个简单的事件总线（Event bus）的实现，其中事件的 Publish 和 Subcribe 都用了 RW 锁来保证 map 读写的线程安全：</p><pre><code class="Go">func (eb *EventBus) Publish(event Event) &#123;    eb.mu.RLock()    defer eb.mu.RUnlock()    if ch, exists := eb.channels[event]; exists &#123;        ch &lt;- event    &#125;&#125;</code></pre><p>而我得到的 CR 建议是用 Sync map 改写为：</p><pre><code class="Go">func (eb *EventBus) Publish(event Event) &#123;    if ch, ok := eb.channels.Load(event); ok &#123;        // 注：这里需要类型断言        ch.(chan Event) &lt;- event    &#125;&#125;</code></pre><p>这实际上最多是一个 Nit 级别的 comment，我是不太在意的，这个事情的处理起来也非常简单。</p><p>而事实上问题在于，我听到了类似于 “为了你好” 的话，大致意思是，为了你好，你要了解清楚 RW 锁、互斥锁、Sync map 的区别，然后选择在 Event bus 场景下最正确的实现方式，并且能够条理清晰地去说服别人。</p><p>如果说我从自身技术发展的角度，是不太在乎这种问题的。这个问题本质上是我们平时面试时候说的八股文，随着最近几年面试风向的转变，也越来越多的人开始逐渐达成一致、反感八股文一类的东西了。</p><p>当然追求这一类底层问题到极致的人，肯定是有技术追求的人，这并不是什么坏事，我们应该尊重任何努力以及对技术较真的人。只是技术也分很多种方面。</p><h4 id="我的兴趣"><a href="#我的兴趣" class="headerlink" title="我的兴趣"></a>我的兴趣</h4><p>我算不算有技术追求的人呢？也许有时候算吧，不然也不会从 Fusionist 裸辞，放弃了比现在算上币权还要高的工资。或者说，无论是技术还是别的东西，其实我们所有人都愿意追求有趣的东西。</p><p>从过往经历来看，我关心的技术话题并且乐于出自兴趣去学习、思考的，比如：</p><ul><li><p>PoW 和 PoS 的本质区别是什么，PoW 好还是 PoS 好</p><ul><li>《<a href="/2024/04/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4PoW%E6%AF%94PoS%E6%9B%B4%E5%8A%A0%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/">为什么说 PoW 比 PoS 更加去中心化</a>》</li></ul></li><li><p>以太坊的 PoS 和 Cardano 的 PoS 有什么区别</p><ul><li>为什么说 Cardano 的 PoS 是比较纯粹的 PoS，又为什么以太坊的 PoS 更加去中心化</li></ul></li><li><p>PBFT 的优缺点是什么，PBFT 有哪些优化的空间</p><ul><li>《<a href="/2025/01/05/%E6%89%80%E6%9C%89-BFT-%E5%85%B1%E8%AF%86%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E9%83%BD%E6%98%AF%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84/">所有 BFT 共识的区块链都是中心化的</a>》</li><li>《<a href="/2024/06/09/Ethereum-Casper-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-EIP-7251/">Ethereum Casper 为什么需要 EIP-7251</a>》</li><li>《<a href="/2024/06/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84PBFT%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8A%95%E7%A5%A8/">区块链中的 PBFT 不需要第二次投票</a>》</li></ul></li><li><p>不同类型的区块链是如何处理分叉的</p><ul><li>《<a href="/2023/07/01/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/">对区块链共识机制的理解</a>》</li><li>《<a href="/2024/08/22/PoS%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%88%86%E5%8F%89/">PoS 类型的区块链如何处理分叉</a>》</li></ul></li><li><p>区块链可能有哪些有趣的应用场景</p><ul><li>《<a href="/2023/05/18/Pebbling-Game-%E9%B9%85%E5%8D%B5%E7%9F%B3%E6%B8%B8%E6%88%8F/">Pebbling Game 鹅卵石游戏</a>》</li><li>《<a href="/2023/02/22/%E4%B8%80%E7%A7%8D%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%9C%BA%E5%88%B6/">一种在区块链上生成随机数的机制</a>》</li><li>《<a href="/2022/12/27/%E2%80%9C%E7%8C%9C%E5%9D%87%E5%80%BC%E7%9A%842-3%E2%80%9DdApp-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/">“猜均值的2&#x2F;3” dApp 游戏设计</a>》</li></ul></li></ul><p>知道这些东西有用吗？没什么用，面试的时候几乎不会有人问，工作中更是用不到，就仅仅只是出于兴趣爱好去探索这些技术问题。这些问题的答案，从来也都不是现成的，网络上是搜索不到的，ChatGPT 也是没办法精准回答的，只有经过一段时间的学习，加上查阅论文资料，结合自己的亲身经历和理解，才可以形成技术观点，无论观点本身是对还是错。</p><p>因此可能出于某种思维上的惯性，我很少关心太过基础的编程类问题。这种事情因人而异，不能强求，自然也不能强迫别人因为 FYI 就去关心某些问题。</p><h4 id="FYI：成为好的-writer"><a href="#FYI：成为好的-writer" class="headerlink" title="FYI：成为好的 writer"></a>FYI：成为好的 writer</h4><p>（刚说完不要 FYI，我这里就在 FYI）</p><p>《<a href="https://www.joecotellese.com/posts/rework-book-summary/">Rework</a>》 这本书里有一个章节印象挺深，标题是 “Hire great writers”，书中的观点是，不是因为工作中需要发表什么文章、写什么报告，而是好的 writer 往往具备逻辑清晰表达问题的能力，可以帮助到工作。</p><p>回到技术问题上，现在各种形式的技术文章也都非常普遍，比如对锁的使用场景比较有心得的话，完全可以落实到文字上，输出成果形成一篇文章，分门别类的介绍锁的种类、最佳的使用场景，然后发表到各种平台上，获得成千上万人的关注，再然后如果对其他技术细节也有心得，内容逐渐丰富，直到写出了一本书，甚至有出版社看上，或者公开到网络上作为电子书开源……FYI……何必跟我较真呢。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前情提要，推荐王垠的两篇博客文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《&lt;a</summary>
        
      
    
    
    
    
    <category term="程序员" scheme="https://smallyu.net/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>假如启动一个叫 Oiia Network 的以太坊 PoS 网络</title>
    <link href="https://smallyu.net/2025/01/28/%E5%81%87%E5%A6%82%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%8F%AB-Oiia-Network-%E7%9A%84%E4%BB%A5%E5%A4%AA%E5%9D%8A-PoS-%E7%BD%91%E7%BB%9C/"/>
    <id>https://smallyu.net/2025/01/28/%E5%81%87%E5%A6%82%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%8F%AB-Oiia-Network-%E7%9A%84%E4%BB%A5%E5%A4%AA%E5%9D%8A-PoS-%E7%BD%91%E7%BB%9C/</id>
    <published>2025-01-28T15:26:40.000Z</published>
    <updated>2025-05-05T02:32:12.211Z</updated>
    
    <content type="html"><![CDATA[<p>OIIA OIIA（Spining Cat）是最近很火的一只鬼畜旋转猫，对比 PoW 链上的 DOGE，OIIA 将是 PoS 链上的猫主题 memecoin。</p><p>OIIA 与 pump.fun 发行的 memecoin，以及 $Trump 之类不同的地方在于，所有代币的发行量都将通过 PoS 挖矿新增，没有任何预分配（可以验证 genesis 文件），未通过挖矿产生的代币，花钱都买不到。</p><h3 id="网络动机"><a href="#网络动机" class="headerlink" title="网络动机"></a>网络动机</h3><ol><li>《<a href="/2025/01/10/%E5%8F%91%E8%A1%8C%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F/">发行加密货币的最好方式</a>》</li><li>Oiia 将会提供更便捷的搭建以太坊 PoS 网络的工具，进一步降低搭建以太坊 PoS 网络的难度</li></ol><h4 id="为什么使用者要参与"><a href="#为什么使用者要参与" class="headerlink" title="为什么使用者要参与"></a>为什么使用者要参与</h4><p>如果参与者没有相关经验，作为学习者，可以：</p><ol><li>学习如何搭建一个完整的以太坊 PoS 网络</li><li>学习如何启动和运维一个以太坊 Validator 节点，如何质押、如何解除质押</li><li>学习如何熟练使用以太坊生态节点相关的工具</li><li>发现并解决以太坊生态工具使用上的问题，给以太坊生态做贡献</li></ol><h4 id="为什么不用以太坊测试网"><a href="#为什么不用以太坊测试网" class="headerlink" title="为什么不用以太坊测试网"></a>为什么不用以太坊测试网</h4><p>作为以太坊网络的学习者，为什么不直接用 Sepolia 这样的测试网去用，而是选择 Oiia Network？</p><p>因为 Oiia Network 的定位是 memecoin。</p><h3 id="网络-Spec"><a href="#网络-Spec" class="headerlink" title="网络 Spec"></a>网络 Spec</h3><h4 id="技术基础"><a href="#技术基础" class="headerlink" title="技术基础"></a>技术基础</h4><p>使用以太坊客户端 Geth + Lighthouse 作为初始节点。只修改启动配置和 genesis 文件，不修改代码。</p><h4 id="Chain-ID-以及-Network-ID"><a href="#Chain-ID-以及-Network-ID" class="headerlink" title="Chain ID 以及 Network ID"></a>Chain ID 以及 Network ID</h4><p>十进制：</p><pre><code>20220915</code></pre><p>十六进制：</p><pre><code>0x1348BF3</code></pre><h4 id="初始-Validator"><a href="#初始-Validator" class="headerlink" title="初始 Validator"></a>初始 Validator</h4><p>128 个，这个是网络启动的最小规模，会直接写入到 genesis.ssz 文件中。</p><h4 id="初始-Faucet"><a href="#初始-Faucet" class="headerlink" title="初始 Faucet"></a>初始 Faucet</h4><p>由于一开始网络的参与人数会比较少，会预留 128*32 &#x3D; 4096 OIIA 作为水龙头余额，放到水龙头地址中。</p><p>水龙头使用 PoW Faucet（网页挖矿）的形式来分配。</p><p>水龙头的目的是提供少量的流通金额用于网络的测试使用，以及早期愿意参与到网络中的 Validator（虽然靠水龙头很难领到 32 个 OIIA）。预留额度上，如果有 128 个 solo-staker，这个网络就算是巨大的成功了，所以认为预留 4096 个 OIIA 够用。</p><h4 id="初始发行量"><a href="#初始发行量" class="headerlink" title="初始发行量"></a>初始发行量</h4><p>为了避免类似以太坊基金会抛售的问题，OIIA 不会预分配任何金额给开发人员或 DAO，几乎所有网络都会因为预分配受到怀疑。</p><p>以太坊的 PoS 共识没有发行量上限，所以网络的初始发行量就是 4096 个 OIIA。网络启动后的流通量全部依靠挖矿奖励来产出，就像比特币一样。</p><p>也就是说，从 Oiia Network 的 genesis 文件来看，除了 4096 个 OIIA 预留用于的空投外（创世节点的 128 个 Validator 不体现在 genesis 文件上，价值 4096 OIIA），不会再预分配任何金额给任何地址。</p><h4 id="如何成为-Validator"><a href="#如何成为-Validator" class="headerlink" title="如何成为 Validator"></a>如何成为 Validator</h4><p>由于网络初始代币发行量特别少，Faucet 上又领不到足够多的 OIIA，所以可以在社区中申请成为 Validator，社区直接从 Faceut 地址转账 32 OIIA 到申请地址。</p><h4 id="网络启动进度"><a href="#网络启动进度" class="headerlink" title="网络启动进度"></a>网络启动进度</h4><p>由于没有任何商业目的，网络的启动进度会比较随心所欲。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;OIIA OIIA（Spining Cat）是最近很火的一只鬼畜旋转猫，对比 PoW 链上的 DOGE，OIIA 将是 PoS 链上的猫主题 memecoin。&lt;/p&gt;
&lt;p&gt;OIIA 与 pump.fun 发行的 memecoin，以及 $Trump</summary>
        
      
    
    
    
    
    <category term="OIIA" scheme="https://smallyu.net/tags/OIIA/"/>
    
    <category term="计划" scheme="https://smallyu.net/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>发行加密货币的最好方式</title>
    <link href="https://smallyu.net/2025/01/10/%E5%8F%91%E8%A1%8C%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F/"/>
    <id>https://smallyu.net/2025/01/10/%E5%8F%91%E8%A1%8C%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F/</id>
    <published>2025-01-09T16:39:12.000Z</published>
    <updated>2025-01-09T16:45:40.552Z</updated>
    
    <content type="html"><![CDATA[<p>前几天某个互联网无关行业的知名人物，在 pump.fun 上发行了一个 memecoin。然后这两天看到有人在公开频道里讨论，关于把 memecoin 迁移为公链的方案，比如保留原始地址和余额启动新链之类。</p><p>这个 memecoin 的动机很简单，就是发行者需要募集资金，因为他们从事的活动需要资金来源，也因为他们在从事的活动，这个 memecoin 已经被很多钱包屏蔽掉了。</p><p>当然我们这里不会讨论发行加密货币的动机，只会讨论发行加密货币的技术手段，并且对技术手段进行对比。</p><h3 id="最好的方式"><a href="#最好的方式" class="headerlink" title="最好的方式"></a>最好的方式</h3><p>先说结论，发行加密货币，最可靠的技术方案是，直接使用以太坊的客户端，运行一条和以太坊 Chain ID 不同的链。</p><h3 id="为什么不是-pump-fun"><a href="#为什么不是-pump-fun" class="headerlink" title="为什么不是 pump.fun"></a>为什么不是 pump.fun</h3><p>pump.fun 是一个很好的平台，提供了一键发币的能力，能保证合约的安全性，不 rug pull，没有预售，没有安全漏洞。这一点相比于自己写合约发币，要方便和安全很多，</p><p>pump.fun 最厉害的地方在于，发币即可交易，使用 bonding curve 机制来定义价格，让一个币种即使交易者很少，也可以正常交易，这是其他发币方式做不到的。</p><p>不过 pump.fun 也有问题，首先是 SOL 生态，不知道为什么 pump.fun 最初选择了 Solana 而不是 Ethereum，买家在购买新发的币种之前，要先理解和拥有 SOL 才可以继续后续的步骤。虽然 SOL 也非常知名了，但买家为什么要先知道 SOL？</p><p>其次是当币种市值在 100k 以下，这个币的交易行为就和 pump.fun 平台绑定了，不访问 pump.fun 这个网站，你就找不到可以交易的地方。如果网站没了，或者域名没了，就真的没有入口了，这对于币种的长期发展并不友好。市值到 100k 以上就会进入 Raydium，那么有多少买家理解 Raydium是什么？岂不是又依赖于一个Dex平台？</p><p>所以享受 pump.fun 提供便利的同时，就要承担 pump.fun 这个平台本身的风险，还要承受 Solana 这条链有可能出现的风险，比如，Solana 会长久存在吗？多久算久？</p><p>pump,fun 对自己的定位还挺准确的，memecoin 发行平台。</p><h3 id="为什么不是-PoW"><a href="#为什么不是-PoW" class="headerlink" title="为什么不是 PoW"></a>为什么不是 PoW</h3><p>PoW 是最去中心化的技术形式，但是发行 PoW 链的成本太高了，不但没有现成的技术框架可以复用，需要硬核的技术，而且维护成本也很高，没有人挖矿就得自己挖，算力还不能太低。</p><h3 id="为什么不是-Cosmos"><a href="#为什么不是-Cosmos" class="headerlink" title="为什么不是 Cosmos"></a>为什么不是 Cosmos</h3><p>Cosmos 生态的项目往往伴随着两个负面的关键词，BFT，联盟链，所以可以排除了。</p><p>ATOM 是一个市值仅排名 50 左右的币种，生态上有自己的垂直领域，可以说，如果不知道为什么要用，就不要用。</p><p>另外 Cosmos 的生态建设其实不好，到目前都没有一个像 Metamask 一样能连接任意 RPC 的钱包，要真用上 Cosmos 会遇到不少问题。</p><h3 id="为什么不是-Polkdot-x2F-Avalanche"><a href="#为什么不是-Polkdot-x2F-Avalanche" class="headerlink" title="为什么不是 Polkdot &#x2F; Avalanche"></a>为什么不是 Polkdot &#x2F; Avalanche</h3><p>区块链行业专业的从业者，估计都没整明白、用不来这两条链，不在于它们无法理解，而是理解成本高。</p><p>而且像 Polkdot 比如 Existential Deposit 这种特性简直离谱，不明白为什么会存在。类似的未知问题还有很多，是不能轻易选择使用的。</p><h3 id="为什么不是-Ethereum-Layer-2"><a href="#为什么不是-Ethereum-Layer-2" class="headerlink" title="为什么不是 Ethereum Layer 2"></a>为什么不是 Ethereum Layer 2</h3><p>以太坊的 Layer 2 本身也不是发币用的，是给项目方挣协议费的，L2 是以太坊的扩展，原生代币仍然是 ETH。而且 L2 虽然技术开源也好用，但是需要中心化的运营，以及不间断提交 fault proofs 到 Layer 1，手续费得用真实的 ETH，挺贵的，如果用户少，手续费都挣不回来。</p><h3 id="为什么不在-Ethereum-上发行-ERC-20"><a href="#为什么不在-Ethereum-上发行-ERC-20" class="headerlink" title="为什么不在 Ethereum 上发行 ERC-20"></a>为什么不在 Ethereum 上发行 ERC-20</h3><p>智能合约一般人写不明白，主要是安全漏洞风险高，即使发行方觉得合约没问题，买家也很难判断合约安不安全，识别难度很高，所以不推荐这种方式。即使合约没问题，以太坊的手续费也很贵，很不友好。</p><p>Layer 2上发行 ERC-20 呢？问题是选择哪个 L2 网络？L2 网络的手续费倒是低，但是不同网络数据又不互通，从这个角度，L2 在杀掉以太坊，至少让以太坊变得分裂，而不是在帮助以太坊。</p><h3 id="为什么是-Ethereum"><a href="#为什么是-Ethereum" class="headerlink" title="为什么是 Ethereum"></a>为什么是 Ethereum</h3><p>不可否认的几点事实是：</p><ol><li>以太坊的 EVM 已经成为区块链行业最广泛认可和使用的智能合约标准</li><li>以太坊的 PoS 是除了 PoW 之外最去中心化的共识机制</li><li>以太坊的地位无法撼动，ETH Killer 也许会在某些指标上超越以太坊，但 EVM 标准这一点不会</li><li>相比于其他公链，以太坊的社区生态更加活跃，基础设施更加完善</li><li>新兴公链都在试图兼容 EVM，而不是推翻 EVM</li></ol><p>基于这些事实，发行区块链网络最好的方式只有一种：</p><ul><li>使用以太坊客户端，修改配置文件和启动参数之后，启动一个 Layer 1 网络</li></ul><p>从网络运行的角度，即使只使用目前版本的以太坊客户端，哪怕后续客户端不再跟随以太坊的步骤进行升级，也可以让网络长久稳定运行下去。</p><p>至于手续费，币价低手续费就便宜，所以几乎不太可能贵到手续费无法接受。</p><h3 id="如何解决初期交易和空投问题"><a href="#如何解决初期交易和空投问题" class="headerlink" title="如何解决初期交易和空投问题"></a>如何解决初期交易和空投问题</h3><p>除了 pump.fun 平台和 PoW 链，其余的发币方式都无法解决初始阶段币种交易的问题，初期上不了 CEX 也上不了 DEX，买家怎么买，拿什么买？</p><p>唯一能想到的就是以 ICO 的方式预售，在 TGE 的时候正式启动网络。尽管这个过程中往往会产生一大堆不和谐的事件和争议，但是如果用以太坊的节点，只要把 Genesis 文件中的每一个地址都说明，网络本身就可以是大家认可并且没有问题的。</p><p>网络创世没问题之后，剩下的就交给网络自身的通胀，也不会有明显的问题，网络就能平稳运行下去了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前几天某个互联网无关行业的知名人物，在 pump.fun 上发行了一个 memecoin。然后这两天看到有人在公开频道里讨论，关于把 memecoin 迁移为公链的方案，比如保留原始地址和余额启动新链之类。&lt;/p&gt;
&lt;p&gt;这个 memecoin</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>所有 BFT 共识的区块链都是中心化的</title>
    <link href="https://smallyu.net/2025/01/05/%E6%89%80%E6%9C%89-BFT-%E5%85%B1%E8%AF%86%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E9%83%BD%E6%98%AF%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84/"/>
    <id>https://smallyu.net/2025/01/05/%E6%89%80%E6%9C%89-BFT-%E5%85%B1%E8%AF%86%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E9%83%BD%E6%98%AF%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84/</id>
    <published>2025-01-05T03:57:59.000Z</published>
    <updated>2025-01-05T04:17:27.381Z</updated>
    
    <content type="html"><![CDATA[<p>首先给出一个共识机制在去中心化程度上的排名，这个排名几乎是毋庸置疑的：</p><p>PoW &gt; PoS &gt; DPoS &gt; BFT</p><p>然后从处理分叉的角度，对比一下 PoS 和 BFT 的差异。</p><p>因为 BFT 算法本身决定了，所有使用 BFT 共识的链，都不会存在分叉，无论是软分叉还是硬分叉。没有分叉的链，意味着整个网络同一时刻只会有一个版本，而这个版本取决于项目发行方，哪怕项目发行方不是官方，这一版本也只能来自于某个中心化的组织。所以，使用 BFT 共识的区块链都是中心化的。</p><p>假如网络发行方对网络进行了让人无法接受的更改，会发生什么？</p><p>在 PoS 共识下，验证者可以选择旧的规则，也可以选择新的规则，这两种规则可以同时存在，直到大多数验证者达成一致，网络恢复一致。如果验证者始终无法达成一致，就会一直分叉下去。</p><p>在 BFT 共识下，验证者可以选择旧的规则，也可以选择新的规则，但是如果一方数量达到半数，网络将会停止。直到验证者线下达成一致，网络才会重新启动。</p><p>也就是说，当面临本应该分叉的情形时，BFT 会直接停机，这也是为什么 Solona 和 SUI 都出现过网络停止的原因。</p><p>到这里你就明白，这里说的中心化，是指在 BFT 网络中不会同时存在两个网络，当然使用其他共识的网络也几乎不会出现这种情况，但是容许这种情况发生。</p><p>更进一步的说明，这里说的中心化，是指 BFT 网络中如果一定比例的验证者想要让网络停止，网络就可以停止，只能通过新启动另外一个网络（其实也属于硬分叉的一种）来让网络恢复正常。</p><p>这种差异会产生什么影响？以太坊网络中，即使大多数节点已经挂掉，只要还有少数存在，网络就能够正常运行。而 BFT 网络对验证者的容错能力不到一半，如果半数验证者停掉，网络会直接瘫痪，你的所有链上资产无法继续转移。</p><p>从投资的角度，如果你打算长期持有某种代币，你觉得哪种网络更安全，更能让你的资产安全受到保障？</p><p>不过还要注意的是一点，网络的可靠性不一定来自于去中心化程度，Coinbase 的 Base 网络可靠性来自于美国政府的监管和半合规化，很多交易所和政府机构都会把钱放到 Coinbase Prime 的信托服务里，所以 Base 网络也是比较可靠的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;首先给出一个共识机制在去中心化程度上的排名，这个排名几乎是毋庸置疑的：&lt;/p&gt;
&lt;p&gt;PoW &amp;gt; PoS &amp;gt; DPoS &amp;gt; BFT&lt;/p&gt;
&lt;p&gt;然后从处理分叉的角度，对比一下 PoS 和 BFT 的差异。&lt;/p&gt;
&lt;p&gt;因为 BFT</summary>
        
      
    
    
    
    
    <category term="BFT" scheme="https://smallyu.net/tags/BFT/"/>
    
  </entry>
  
  <entry>
    <title>对 2025 年区块链行业的预测</title>
    <link href="https://smallyu.net/2024/12/16/%E5%AF%B92025%E5%B9%B4%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%8C%E4%B8%9A%E7%9A%84%E9%A2%84%E6%B5%8B/"/>
    <id>https://smallyu.net/2024/12/16/%E5%AF%B92025%E5%B9%B4%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%8C%E4%B8%9A%E7%9A%84%E9%A2%84%E6%B5%8B/</id>
    <published>2024-12-16T15:04:43.000Z</published>
    <updated>2024-12-17T14:46:16.093Z</updated>
    
    <content type="html"><![CDATA[<p>2024 年发生的事情：</p><ol><li><p>比特币减半、比特币通过现货 ETF、比特币新高</p></li><li><p>特朗普喊单 BTC，马斯克喊单 DOGE</p></li><li><p>比特币叙事熄火，铭文、符文无人问津，Layer 2 技术没有一个出圈（Lighting Network、Taproot、RGB、RGB++），Layer 2 项目没有一个靠谱（Nervos、Merlin、Nubit、Fractal Bitcoin)</p></li><li><p>以太坊 Cancun 升级引入 Blob，让 Layer 2 成本大幅降低，但是现在 Layer 2 充值到交易所仍然需要25分钟等待期，这一点体验很不好，既然有可能重组，交易就是不安全的</p></li><li><p>NFT 市场消失，Coinbase 和 Binance 关闭 NFT 交易市场</p></li><li><p>DEXX 交易所被盗，上千名用户上千万资金，交易所是华人背景，用户也是华人背景，小白多</p></li></ol><hr><p>2025 年的趋势预测：</p><ol><li><p>比特币价格新高到 14 万美元</p></li><li><p>比特币不需要 OP_CAT</p></li><li><p>以太坊的地位无法撼动，所有 ETH Killer 都没有潜力，包括 Solona、Ton、Tron、Polkdot、Cardano、Avalanche、Cosmos、SUI</p></li><li><p>现有的公链格局不会改变，也不会有新的高市值 Layer 1 出现</p></li><li><p>会有新的技术整合类型的链出现，把低成本的东西作为原生功能，比如预言机、随机数、链上治理、Subnet、Web Assembly、DID 等老技术大杂烩，为了提高吸引力，还会蹭 ZK 和 AI 热度，但会发现实际上 ZK 起不到作用，和 AI 也没有关系</p></li><li><p>跨链一直是刚需，但一直没有去中心化的方案落地，以后也不会有</p></li><li><p>新的链一定会兼容 EVM，新的项目也会优先支持 EVM</p></li><li><p>生态类的项目还会不断出现，这些项目会追随某一条公链的技术，干自己的事情，Ethereum &#x2F; Polkdot &#x2F; Cosmos &#x2F; Internet Computer &#x2F; Avalanche 都提供了这样的生态环境</p></li></ol><hr><p>作为一个普通人，想参与到区块链中，能做的只有 3 件事:</p><ol><li><p>定投比特币</p></li><li><p>定投比特币</p></li><li><p>定投比特币</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;2024 年发生的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;比特币减半、比特币通过现货 ETF、比特币新高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特朗普喊单 BTC，马斯克喊单 DOGE&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比特币叙事熄火，铭文、符文无人问津，Layer 2</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Restaking 项目的经济难题</title>
    <link href="https://smallyu.net/2024/11/18/Restaking%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E6%B5%8E%E9%9A%BE%E9%A2%98/"/>
    <id>https://smallyu.net/2024/11/18/Restaking%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E6%B5%8E%E9%9A%BE%E9%A2%98/</id>
    <published>2024-11-18T15:13:15.000Z</published>
    <updated>2024-11-18T15:19:35.499Z</updated>
    
    <content type="html"><![CDATA[<p>Restaking 是一个相对早期的赛道，其中比较有名的项目是 Eigen Layer，有一段时间很火，因为 Eigen Layer 高薪聘请了以太坊基金会的 Researcher，舆论认为以太坊基金会的成员拿了好处，以至于让以太坊往中心化的方向发展了。</p><p>Eigen Layer 搞得声势浩大，不可否认的是 Restaking 的商业模式行得通，因为 Eigen Layer 已经把路走出来了，在运作模式上不用做过多怀疑。</p><p>但是回到 Restaking 的定义上，仍然有问题值得思考。比如，为什么是 Restaking，而不是 Staking？</p><p>因为 Restaking 项目的本质不是技术问题，而是经济问题。换句话说，Restaking 项目没有技术壁垒，有的是商业模式壁垒，关键看在商业合作上能不能运转起来。</p><p>为什么这么说？</p><p>为什么要 Restaking？因为收益有限。作为一个质押用户，我先把 ETH 质押成 stETH，可以稳定拿 3% 的质押收益，在此基础上，我把 stETH 质押到 Eigen Layer 上，有收益最好，没有也无所谓，反正是白给的，哪怕没有收益，我还有 3% 的保底收益。</p><p>如果是 Staking 呢？就有问题了。我手里拿着 ETH，是去拿 stETH 的稳定 3%，还是去拿 Eigne Layer 上不靠谱的项目收益？</p><p>这里就涉及到一个问题，Eigen Layer 的收益来自哪里？</p><p>PoS 链的质押奖励是原生的，非常稳定。Eigen Layer 呢？奖励只能是来自于使用 AVS 提供服务的用户。那么，AVS 提供了什么服务？</p><p>有一个理论是这样：</p><p>对于 PoS 链的逻辑，用户质押了 token，来给 validator 提供质押权重，然后，validator 提供对块数据的验证。</p><p>Restaking 项目中，用户质押了 token，来给 operator 提供质押权重，然后，operator 可以对任意计算任务提供验证。</p><p>听起来是不是很诱人？PoS 链竟然是 Restaking 项目的子集，这么说起来 Restaking 大有可为。</p><p>这种理论有一定道理，不过稍微较真一点，和 Restaking 比较的应该是 DPoS 共识，而不是 PoS 共识。在去中心化程度上，DPoS 是要比 PoS 差的。</p><p>那么就拿 DPoS 和 Restaking 项目比，Restaking 项目会具有更大的优势吗？</p><p>这里得再考虑一个问题，为什么 DPoS 优先被用于对块数据的验证了？而没有拿着用户的质押份额去验证别的东西？</p><p>答案很简单，因为没有比用户资产更重要的数据了。比如，是银行存款的余额数据重要，还是明天天气预报数据的准确度重要？所以 DPoS 在此前有且仅有一个场景，那就是验证区块交易数据，而且，想再找到一个比资产数据更重要的场景，是非常困难的。</p><p>在明确了这个概念后，回到 Restaking 收益的问题，假如 DPoS 能提供 3% 的质押收益，Restaking 能提供多少收益呢？按道理是少于 3% 的，因为 Restaking 在验证的数据，不会比用户的资产数据更重要。</p><p>这就是为什么 Restaking 项目一定要 Restaking 而不是直接 Staking，因为收益率比不过 Staking。在 Staking 的基础上做 Restaking，性质就不一样了。</p><p>回到收益来源的问题，其实 DPoS 和 Restaking 的质押收益，都来自于使用服务的用户。</p><p>DPoS 中，有一批人质押了 token 成为 validator，另一批人依赖于 validator 提供的资产安全能力。所以用户允许 DPoS 链增发 3% 的 token 作为块奖励。供应总量增加，不就相当于洗劫了所有人嘛。</p><p>Restaking 中，有一批人质押了 token 成为 operator，另一批人依赖于 operator 提供的数据验证能力，基本逻辑和 DPoS 是相似的。这里的 “另一批人”，就指使用 AVS 服务的用户，而这些用户，也将会为 Restaking 的收益付费。</p><p>Restaking 的收益不可能凭空产生，直接来源就是用户，而付费方式也可以很简单，就是字面意思的付费，我调用一次 AVS 上的某个数据，就付费 0.1 美元，类似这种方式，直接计费就好了，都不需要涉及什么供应量。</p><p>用户支付的费用，有多少才够呢，假如有 1M 的 stETH 质押量，为了给质押者提供 1% 的年化，假如有 1 万个用户每天使用一次的话……</p><p>到这里问题就又来了，有哪个冤种用户会愿意为了这种服务花钱？要知道以太坊 L1 的链上交易，一次 1 美元可就贵死了，更是有很多很多人，舍不得开 9 块钱的爱奇艺会员看视频，无数程序员，舍不得为自己日夜使用的 IDEA 买个正版……</p><p>当然，只要泡沫不破裂，大家的财富就都在膨胀，牛市来临之后，没有人是在亏钱的，只要泡沫不破裂，只要能够在泡沫破裂前离场，一切都会很美好。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Restaking 是一个相对早期的赛道，其中比较有名的项目是 Eigen Layer，有一段时间很火，因为 Eigen Layer 高薪聘请了以太坊基金会的</summary>
        
      
    
    
    
    
    <category term="Restaking" scheme="https://smallyu.net/tags/Restaking/"/>
    
  </entry>
  
  <entry>
    <title>看懂任意区块链项目的技术架构</title>
    <link href="https://smallyu.net/2024/10/15/%E7%9C%8B%E6%87%82%E4%BB%BB%E6%84%8F%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    <id>https://smallyu.net/2024/10/15/%E7%9C%8B%E6%87%82%E4%BB%BB%E6%84%8F%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/</id>
    <published>2024-10-15T15:43:36.000Z</published>
    <updated>2024-10-15T15:48:08.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>最基本的区块链，就是一条区块链本身，包含有通过共识出块的能力，可能有很多节点，也可能只有一个节点，每个节点都提供接收交易的 RPC 接口：</p><img src="1.png" width="60%"><p>因为以太坊的诞生，区块链的交易不仅仅是交易，还具有了智能合约的能力：</p><img src="2.png" width="60%"><p>总会有一个外部的程序来和智能合约交互，也就是发起交易：</p><img src="3.png" width="60%"><p>从这里开始需要明确两种行为：</p><ol><li>凡是和区块链有交互的，可能是提交交易或者查询交易，都算是链上交互</li><li>和区块链没有任何交互的，属于链下行为</li></ol><p>向智能合约发起交互一定属于链上交互，同样的，无论发起交易的外部程序，是用什么语言写的，可能是 Javascript 或者 Golang，都叫做智能合约的 SDK：</p><img src="4.png" width="60%"><p>除了以太坊的 EVM 合约，还有可能是其他虚拟机（SVM、WASM）的合约，或者 Cosmos 直接操作状态数据库的方式（Native合约），可以统一理解为链上智能合约：</p><img src="5.png" width="60%"><p>只要是链上合约，都会需要链下程序来发起交易，才能够实现某些功能。</p><p>而当智能合约有了具体的逻辑，很可能会触发一些事件，这些事件往往由链下节点来监听和处理：</p><img src="6.png" width="60%"><p>这个链下节点起什么名字都可以，用什么语言写都可以，总之会获取到合约中的事件，一般监听事件的方式有两种：</p><ol><li>主动查，不断请求节点的接口，看有没有新的事件</li><li>被动接受，比如 websocket 建立的长链接</li></ol><p>当合约里触发某个事件后，链下节点监听到事件，会根据事件进入不同代码分支，后面进行多么复杂的操作都可以。</p><p>链下节点可能有多个，也可能有多种角色，但是不重要，重要的是，他们都是在和链上的事件进行交互：</p><img src="7.png" width="60%"><p>一般链下节点之间不会擅自进行通信，而是紧跟区块链的块内容，因为链下节点也需要保持状态的一致，区块链场景下，链本身已经是非常好的能提供状态一致的手段了：</p><img src="8.png" width="60%"><p>所以，这个时候你就知道，其实对于区块链项目来说，链下节点和链上节点之间，只有两种动作：</p><ol><li>通过交易向区块链发送数据</li><li>通过监听事件来从区块链查询事件</li></ol><p>Cosmos 有一个能支持 EVM 合约的项目，还提供了 evm_hook 的接口，当 EVM 合约触发事件的时候会主动调用接口函数。这种 hook 函数本质上也是合约事件的被动监听，无非是从合约事件到链下节点调用的方式，从 RPC 请求变成了函数的直接调用。唯一增加的复杂度是 EVM 合约触发了 Cosmos 模块的函数，把两种合约的实现方式串起来了：</p><img src="9.png" width="60%"><p>复杂架构也不会改变的是，链下节点和链上节点之前的交互，只有两种动作。</p><p>如果再复杂一点的话，会往什么方向复杂呢，链下节点开始向链上提交交易了：</p><img src="10.png" width="60%"><p>也许在监听到事件后提交了一笔交易，交易触发了另一个事件，监听到另一个事件后进行了更多的操作。但是总之，链下节点和链上节点之前的交互，仍然只有两种动作。</p><h3 id="填充业务逻辑"><a href="#填充业务逻辑" class="headerlink" title="填充业务逻辑"></a>填充业务逻辑</h3><p>有了基本的技术手段，再往上填充业务逻辑，就容易理解了。</p><p>面对很长的业务逻辑，总是能分清楚哪些部分是链上交互、哪些部分是链下行为，核心区别在于数据状态存在哪里，是区块链上，还是链下节点：</p><ol><li>如果是通过交易发送到链上，业务的复杂程度就取决于合约的逻辑。</li><li>如果是链下节点监听到事件后的行为，那就取决于链下代码的复杂程度。</li></ol><p>如果复杂度超出了上述两种情况，就只能是链下节点之间脱离区块链进行了擅自的通信，并且还产生了不一致的状态，这样的链下节点可以认为已经在区块链项目之外了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;基本结构&quot;&gt;&lt;a href=&quot;#基本结构&quot; class=&quot;headerlink&quot; title=&quot;基本结构&quot;&gt;&lt;/a&gt;基本结构&lt;/h3&gt;&lt;p&gt;最基本的区块链，就是一条区块链本身，包含有通过共识出块的能力，可能有很多节点，也可能只有一个节点，每个节点都提供接收交易的</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>关于工作的反思和规划</title>
    <link href="https://smallyu.net/2024/10/04/%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%8F%8D%E6%80%9D%E5%92%8C%E8%A7%84%E5%88%92/"/>
    <id>https://smallyu.net/2024/10/04/%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%8F%8D%E6%80%9D%E5%92%8C%E8%A7%84%E5%88%92/</id>
    <published>2024-10-04T07:55:48.000Z</published>
    <updated>2024-10-04T07:56:50.558Z</updated>
    
    <content type="html"><![CDATA[<p>之前啰嗦说了一堆辞职的原因，经过这两天的沉淀和思考，我想可以更简洁的描述辞职原因以及职业方面的规划。换句话说，想清楚了自己为什么辞职以及到底想要什么。</p><p>上一份工作让我处于对技术能力的焦虑中，需要时刻担心技术能力是不是有退步、技术能力的增长能不能跟得上年龄的增长、假如离开这家公司后还能不能找到工作等。</p><p>那份工作能让人挣钱，但是不能让人安心，所以接下来我想找能让人安心的工作。</p><p>比起现在有没有工作，我更担心以后能不能找到工作，现在挣多少钱只是一时的，我还是希望自己能在技术的道路上走的更远一点，希望能在技术方面有持续的积累。</p><p>接下来我找工作的理想类型优先级从高到低是：</p><ol><li>区块链开发，指链本身的开发，哪条链都可以</li><li>纯 web3 项目，比如 SocialFi、GameFi 之类</li><li>区块链相关的后端开发，如果我能胜任的话</li></ol><p>找到这几种类型工作的难度也是从高到低的，区块链开发职位数量最少、要求最高，区块链相关的后端开发则职位数量多一点，各种交易所都是。</p><p>结合这两年找工作面试的经历来看，面试官大多数是传统的后端开发出身，从提问的问题能看出来。真正能提出区块链方面技术问题的屈指可数。为什么会存在这样的现象？</p><p>我盲目猜测，做区块链开发的人都还没当上面试官，或者说，坐在面试官位置上的人大概率是因为历史原因或其他原因。区块链行业还没有培养出一批人，就已经在熊市的时候淘汰掉很多人了。</p><p>（到目前为止我遇到过最有水平的问题，就是 “PBFT为什么需要第二次投票？”这个问题去年被问到过两三次，有趣的是，提问问题的这几个面试官，对这个问题的答案是不一样的。后来我意识到这是一个复杂且充满争议、没那么肤浅的问题，还写过《<a href="/2024/06/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84PBFT%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8A%95%E7%A5%A8/">区块链中的 PBFT 不需要第二次投票</a>》来描述我对这个问题的理解）</p><p>关于职业方向，我是迷茫的，其实任何人都应该迷茫。区块链到现在总共十来年，从2017年山寨币大爆发到现在更是只有五六年的时间，还不足以让一个行业形成完整的职业体系。</p><p>技术方面该学什么？该往什么方向深入？完全没有答案，没有先例，谁也说不准接下来的趋势。</p><p>尤其是 web3 公司的变化速度快，技术创新快、公司变动快，牛市会产生一些新叙事，然后又很大一批公司抗不过熊市，不稳定是 web3 公司本应该的基调。</p><p>在这样的情况下，对于没有背景的打工人，能依靠的只有自己的技术能力，所以要持续提高自己的技术能力。至于往哪个方向提升是另一个问题。至少不可能依赖于公司。</p><p>那么如果我接下来找不到工作怎么办？</p><p>假如经过了足够长的几个月时间，我确信整个北京以及全世界的远程工作，没有任何一家公司的工作，我能够胜任，可能就需要进入另一种模式。</p><p>我需要重新审视和思考自身的技术能力，以及重新了解和学习整个区块链行业的现状，根据市场情况来调整自己的认知以及预期，调整自己在职业方向上的期望，需要什么我就学什么，能做什么我就做什么。</p><p>这是一段有趣的旅程，虽然过程中充满痛苦，如果赢了，自己会变得更强大，如果输了，就看会输到什么程度。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;之前啰嗦说了一堆辞职的原因，经过这两天的沉淀和思考，我想可以更简洁的描述辞职原因以及职业方面的规划。换句话说，想清楚了自己为什么辞职以及到底想要什么。&lt;/p&gt;
&lt;p&gt;上一份工作让我处于对技术能力的焦虑中，需要时刻担心技术能力是不是有退步、技术能力的增长能不能跟得上年龄的增长</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>为什么不要做以太坊的二次开发</title>
    <link href="https://smallyu.net/2024/09/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%81%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
    <id>https://smallyu.net/2024/09/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%81%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/</id>
    <published>2024-09-12T07:29:05.000Z</published>
    <updated>2024-09-12T07:29:05.913Z</updated>
    
    <content type="html"><![CDATA[<p>道理很简单，以太坊是有核心开发团队的，以太坊基金会为中心，各个以太坊客户端的开发团队，都拿了以太坊基金会的钱给以太坊做开发。Vitalik 来中国融资，拿完钱到某个国家组建开发团队，密集开发一年后有了以太坊。当年以太坊基金会以不到 $1 的价格参与以太坊的 ICO，现在 ETH 的价格已经涨了几千倍，以太坊基金会的钱就是这么来的。</p><p>以太坊生态主要有三个部分，Layer 1、Layer 2 以及生态类项目。（Staking 类不需要你开发，Restaking 和技术有关系？）</p><p>Layer 1 部分，有几大客户端团队，执行层的 Geth、Nethermind、Besu、Erigon、Reth，共识层的 Prysm、Lighthouse、Teku、Nimbus、Lodestar，先不管这些团队和以太坊的利益关系如何，如果你自己或者你所在的公司，说是想要基于以太坊的客户端做二次开发，那么请问，要开发什么？</p><p>如果是对以太坊网络本身有益的改进，能够提高性能、优化数据结构之类，你大可以直接给以太坊提交 Issue 以及 PR，甚至建立合作关系，直接让以太坊客户端的官方版本来支持你的优化。何况这些客户端的创始团队仍然处于活跃的开发状态，你觉得自己有理由可以比他们 “自己人” 做的更出色吗？无论是客户端功能方面还是性能方面，无论你是个人还是公司的力量。</p><p>例如并行 EVM，试图提高 EVM 交易的执行速度，这是 Geth 团队都没能解决的难题，随便一个小团队能做得成？</p><p>如果是对以太坊无益而对自己链有益的改进，你预期以太坊的开发团队不会接受你的提议和改进，那这个问题就更加奇特，你的链是有多么特殊的需求，需要做这些必须 “自有” 的开发？以太坊的完成度已经比较高了，如果遇到这样的场景，似乎需要回到一开始的需求来评估整件事情。</p><p>Layer 2 的部分，比较大的团队有 Polygon、Optimism、Zksync 等。以太坊的 Layer 2 为什么能做大做强能火？Layer 2 是 Vitalik 认可的方向。ENS 项目为什么能广泛普及？ENS 是 Vitalik 认可的项目。AA 钱包为什么热闹了一段时间？Vitalik 喊灵魂绑定带起来的。你可以从 Vitalik 的博客中看到，凡是目前比较大的生态类项目，都和 Vitalik 本人有直接的联系，这些项目的创始人都是可以和 Vitalik 说上话的。</p><p>Vitalik 是整个以太坊生态背后的大 Boss，那么假如你说你想搞一个以太坊生态的项目，是优先考虑技术能力方面的问题吗？一个项目能不能成，先看什么？先看以太坊的 Roadmap 有没有这个方向，再看以太坊生态里这个方向的头部项目是哪个，然后呢？你会发现跟你没什么关系。以太坊基金会又没有给你钱，你凑什么热闹？</p><p>站在开发者的角度，假如你想参与以太坊的生态建设，那么请问，要以太坊的核心团队干什么？如果你想改进 Op Stack 的 Fault Proofs，那么请问，要 Optimism 的核心团队干什么？你作为一个局外人，花费时间和资源去给别人抬轿子？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;道理很简单，以太坊是有核心开发团队的，以太坊基金会为中心，各个以太坊客户端的开发团队，都拿了以太坊基金会的钱给以太坊做开发。Vitalik 来中国融资，拿完钱到某个国家组建开发团队，密集开发一年后有了以太坊。当年以太坊基金会以不到 $1 的价格参与以太坊的 ICO，现在</summary>
        
      
    
    
    
    
    <category term="程序员" scheme="https://smallyu.net/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>为什么不要做智能合约开发和 DeFi 开发</title>
    <link href="https://smallyu.net/2024/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%81%9A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E5%92%8CDeFi%E5%BC%80%E5%8F%91/"/>
    <id>https://smallyu.net/2024/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%81%9A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E5%92%8CDeFi%E5%BC%80%E5%8F%91/</id>
    <published>2024-09-11T12:51:35.000Z</published>
    <updated>2024-09-11T12:54:05.006Z</updated>
    
    <content type="html"><![CDATA[<p>目前市场上的招聘，“合约开发”一般指“以太坊上的EVM合约开发”。而事实上，世界上不只有以太坊一条链，可能有上百条链，也不止以太坊有智能合约，Solona 有 SVM，Polkdot 有 Wasm，Cosmos 在用平行链的方式达到智能合约的效果，等等，还有很多各种各样的实现形式。</p><p>所以看出问题了吗？如果一个程序员号称自己是“合约开发”，说明他把自己局限在了一个狭窄的方向上。Solidity 是以太坊团队创造出来的脚本语言，而“合约开发”把自己的职业生涯交付在了这一种不成熟脚本语言上。至少，咱们应该是 “程序员”，而不是 “Solidity 程序员” 吧。</p><p>程序员可以在需要的时候，做一些合约开发的工作，而合约开发者，就只能做开发合约的工作。单就 Solidity 这种语言来说，语法的学习成本是多高呢？一般半个星期左右就可以开始上手写。</p><p>再是关于 DeFi 开发，因为做合约开发的大多都在学习 DeFi 开发。这里的问题在于，无论是 Centralized Finance，还是 Decentralized Finance，本质都是 Finance，核心是 “金融”，“去中心化” 只是金融的修饰词。</p><p>“金融”是什么？完全和“程序员”是两个行业，全世界的精英都在华尔街搞金融，一个半路出道的程序员，你能搞金融？现在的 DeFi 项目是不是都和杠杆、质押、借贷有关？Luna 暴雷是不是杠杆加太高了？Luna 背后有几家公司的资本力量参与？一般人能整明白 Luna 暴雷的原因吗？整不明白的，专业的金融人士分析半天也许能有点结果。</p><p>也就是说，专业的金融人士未必是程序员，而程序员几乎不可能成为专业的金融人士。金融领域的水很深，不是会写代码学一学 Solidoty 就可以的，更不是一个程序员励志要做DeFi，就能学得会的。</p><p>更进一步，假如程序员把 DeFi 学懂了，能做些什么事情？能做的就是给资本大佬打工，让你实现什么业务逻辑就实现什么业务逻辑，有自由发挥的余地吗？难道你要自己设计一种金融逻辑？搞笑呢？有权力控制大量资产的一定不是程序员，而程序员一定没有权力控制大量资产。</p><p>我的意思是，如果一个程序员想搞懂金融然后表达对整个金融行业独到的见解，是…几乎不可能的，难度非常非常大，有那样能力的人不会是程序员。而如果你只是想要搞懂某个技术领域的情况然后发表一些观点，还是存在可能性的，至少不需要你拥有（或者替别人管理）大量资产吧。</p><p>如果懂金融的程序员自己开一家金融公司呢？你确定？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;目前市场上的招聘，“合约开发”一般指“以太坊上的EVM合约开发”。而事实上，世界上不只有以太坊一条链，可能有上百条链，也不止以太坊有智能合约，Solona 有 SVM，Polkdot 有 Wasm，Cosmos</summary>
        
      
    
    
    
    
    <category term="程序员" scheme="https://smallyu.net/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>写博客的意义是什么</title>
    <link href="https://smallyu.net/2024/08/30/%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://smallyu.net/2024/08/30/%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2024-08-30T05:25:34.000Z</published>
    <updated>2025-06-16T00:24:31.309Z</updated>
    
    <content type="html"><![CDATA[<p>当世界上没有人再记得你，你就会真正死去。</p><p>如果你的生活里有观众，就让生活中的观众记住你，他们可以是家人、爱人、朋友、同事。</p><p>而如果你的生活里没有观众，你也许想留下一些自己活过的证据。</p><p>可能除了你自己，没有人会关心博客里的内容。</p><p>但在曾经的某时某刻，你真真切切地在思考一些问题，真真切切地感受到了某些情绪。</p><p>你不可能跟爱人分享递归的三种写法，也不可能和同事分享你对爱的感悟。</p><p>你没办法跟父母分享你的许多快乐和悲伤，也不可能让亲戚来体会你的喜怒哀乐。</p><p>世界上没有人会理解你，就像你总是无法理解别人。</p><p>所以把这些东西记录下来，转化成文字、图片、视频。</p><p>即使你的肉体死去，也许还会有人看到你的文字，交到一个跨越时空的朋友，和他进行精神上的对话（这本是书籍的意义）。</p><p>如果已经有人理解你，你不需要写下什么，只管尽情地表演，让观众记住更多的你。也许你停留在生活的小圈子，那就跟所有人分享你知晓的一切。也许你是功成名就的公众人物，那就发表更多作品和言论，会不断有追随者记住你。</p><p>而如果现在还没有人理解你，没有人关心你在乎的话题，那么就写下来，然后等一等，也许会有人发现这些历史的遗迹。</p><p>哪怕是自己老后，回顾一下曾经的自己。哪怕自己不是最后一代，让子孙来认识年轻的你。</p><p>这就是写博客的意义。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;当世界上没有人再记得你，你就会真正死去。&lt;/p&gt;
&lt;p&gt;如果你的生活里有观众，就让生活中的观众记住你，他们可以是家人、爱人、朋友、同事。&lt;/p&gt;
&lt;p&gt;而如果你的生活里没有观众，你也许想留下一些自己活过的证据。&lt;/p&gt;
&lt;p&gt;可能除了你自己，没有人会关心博客里的内容。&lt;/p</summary>
        
      
    
    
    
    
    <category term="观点" scheme="https://smallyu.net/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>我的加密货币定投策略（一）</title>
    <link href="https://smallyu.net/2024/08/28/%E6%88%91%E7%9A%84%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E5%AE%9A%E6%8A%95%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://smallyu.net/2024/08/28/%E6%88%91%E7%9A%84%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E5%AE%9A%E6%8A%95%E7%AD%96%E7%95%A5%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2024-08-27T18:15:14.000Z</published>
    <updated>2024-09-26T04:02:54.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着时间的推移以及对市场的更深入了解，定投策略尤其是投资组合会产生非常大的变化，所以在标题中用（一）标识，如果定投策略有变动，可能还会有（二）、（三）……当然也会同时说明变动的原因。</p></blockquote><p>今年以来开始更加关注投资的话题，也因为乱操作损失过一些钱。</p><p>最近中了李笑来的毒，定投策略的理论让人感到很兴奋，可以从以下资料更加深入了解：</p><ul><li>《<a href="https://ri.firesbox.com/#/">定投改变命运</a>》—— 李笑来，所有关于定投的内容都在这本书里</li><li><a href="https://youtu.be/tmRQImBk6NA?si=Cl7Fwiq2WcfM28P2">定投改变命运直播公开课</a> —— Youtube 视频，李笑来本人的解读</li></ul><p>除了定投，还有几个其他投资方面的参考资料：</p><ul><li>《<a href="https://github.com/xiaolai/the-self-cultivation-of-leeks">韭菜的自我修养</a>》—— 李笑来</li><li><a href="https://www.youtube.com/@ChandlerGuoChannel">郭宏才（宝二爷）的 Youtube 频道</a></li></ul><p>我想实践一下定投的投资方式，其中涉及到的几个问题：</p><ol><li>是否要加入李笑来的投资实践群？没有必要，尤其是对于有自制力的人</li><li>是否要买 <a href="https://b.watch/">BOX</a>？江湖传言，李老师的书必须看，课可以听，币千万别买</li><li>定投的方式？Binance 自带的定投功能就可以，0 手续费（要记得时不时提到钱包）</li><li>定投的频率是？每天，因为价格变化太快了，如果频率太低，周期会变得太久</li><li>定投的周期是？目前规划了用来定投 1 年的钱</li><li>定投的标的是？</li></ol><p>我没有盲目跟从李笑来 BOX 中标的的选择和比例。李笑来的 BOX 一开始给了 EOS 很高比例，事实证明 EOS 失败了，所以现在 BOX 的成分里已经不包含 EOS。最新的情况是，BOX 中 BTC 占了 92% 的比例。另外 BOX 的成分中一直含有 XIN，说明人都会受到立场的左右，因为我们大多数人可能都不知道 XIN 是什么，而李笑来多年坚定的选择这个币。</p><p>我选择的标的和分配的比例是：</p><table><thead><tr><th align="center">序号</th><th align="center">标的</th><th align="center">比例</th><th align="center">标签</th><th align="center">风险</th><th align="center">供应量上限</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">BTC</td><td align="center">50%</td><td align="center">PoW, UTXO</td><td align="center">低</td><td align="center">✅</td></tr><tr><td align="center">2</td><td align="center">ETH</td><td align="center">10%</td><td align="center">智能合约平台</td><td align="center">中</td><td align="center">❌</td></tr><tr><td align="center">3</td><td align="center">LTC</td><td align="center">5%</td><td align="center">PoW, UTXO</td><td align="center">高</td><td align="center">✅</td></tr><tr><td align="center">4</td><td align="center">DOGE</td><td align="center">5%</td><td align="center">PoW, UTXO</td><td align="center">高</td><td align="center">❌</td></tr><tr><td align="center">5</td><td align="center">BCH</td><td align="center">5%</td><td align="center">PoW, UTXO</td><td align="center">高</td><td align="center">✅</td></tr><tr><td align="center">6</td><td align="center">ADA</td><td align="center">5%</td><td align="center">PoS, UTXO</td><td align="center">高</td><td align="center">✅</td></tr><tr><td align="center">7</td><td align="center">SOL</td><td align="center">5%</td><td align="center">智能合约平台</td><td align="center">高</td><td align="center">❌</td></tr><tr><td align="center">8</td><td align="center">FIL</td><td align="center">5%</td><td align="center">PoSt</td><td align="center">非常高</td><td align="center">❌</td></tr><tr><td align="center">9</td><td align="center">TON</td><td align="center">5%</td><td align="center">智能合约平台</td><td align="center">非常高</td><td align="center">❌</td></tr><tr><td align="center"><del>10</del></td><td align="center"><del>XEC</del></td><td align="center"><del>3%</del></td><td align="center"><del>PoW, UTXO</del></td><td align="center"><del>非常高</del></td><td align="center"><del>✅</del></td></tr><tr><td align="center"><del>11</del></td><td align="center"><del>DASH</del></td><td align="center"><del>2%</del></td><td align="center"><del>PoW, UTXO</del></td><td align="center"><del>非常高</del></td><td align="center"><del>✅</del></td></tr><tr><td align="center">10</td><td align="center">XMR</td><td align="center">5%</td><td align="center">PoW, UTXO</td><td align="center">非常高</td><td align="center">❌</td></tr></tbody></table><p>（2024.09.26 更新）</p><p>可以从这个公开的 <a href="https://coinmarketcap.com/watchlist/66d339a5c316be09d04b7b16/">Watchlist</a> 看到这些币种的集合，链接会跳转到 CoinMarketCap 网站上。能注意到的是，几乎所有币种的市值排名都在 100 之内，这条原则来自《<a href="/2024/05/04/%E7%82%92%E5%B8%81%E6%8A%95%E8%B5%84%E7%9A%84%E5%B0%8F-tips/">炒币投资的小 tips</a>》第 4 条。</p><p>我的定投组合中，BTC 一定是首位，占 50% 的比例。另外 5 个 PoW 的币总计占了 20% 的比例，也就是说，PoW 币总计占比 70%。PoW 的币大都有供应量上限。</p><p>由于 “比特金，莱特银” 的说法，LTC一直比较强势，DOGE 和 LTC 是难兄难弟，挖矿算法一样，<a href="https://www.litecoinpool.org/">矿池</a>都是同时挖这两个币，所以 LTC 和 DOGE 的价格不能简单像 BTC 一样估算 “矿机关机价”，而 DOGE 又属于 memecoin 的老大，历史久，马斯克喜欢，也放不下的，所以 LTC 和 DOGE 要一起出现。</p><p>BCH 是 BTC 在手续费超高年代（2017年）的 workaround 方案，Blocksize War 真的已经结束了吗？BCH 是大区块的代表，所以要把 BCH 选进来。BTC 已经脱离 “电子现金” 的目的，变成了 “储存价值”，相信这个问题上的争议还没有彻底结束。那后来 BCH 又分叉出了 BSV，为什么没有把 BSV 涵盖进来？BSV 的生态小，而且生态里有一些活跃但无知的项目（Note 之类），BSV 的创始人还在被法院通缉，等等原因。</p><p>DASH 和 XEC 是最没道理的两个，冷门到很多人没听过，也是风险最高的两个。其中 XEC 是因为 BCH 的 <a href="https://github.com/bitcoin-cash-node/bitcoin-cash-node">节点代码</a> fork 自 XEC 的代码，相信 XEC 有不错的技术能力。DASH 是 LTC 的一个 fork，更多是凑数性质，因为很多老牌钱包比如 Unstoppable 支持的币种列表大都是 PoW 系列的币，DASH 就在其中，而且币安的矿池服务支持的币种不多，其中也有 DASH，所以就把 DASH 作为 “电子现金” 的高风险备选了。</p><p>然后是 ADA，学术能力强，纯粹的 PoS 共识，用了 UTXO 模型，属于 BTC 在 PoS 共识上的平替，而且 ADA 技术上在不断更新，如果有一天 PoS 赢了，ADA 绝对是绕不过去的一个，所以预计 ADA 能有更好的未来。</p><p>FIL 的话，属于分布式存储领域。计算机科学有两大方向，分布式计算和分布式存储，ETH 说自己是 “世界计算机”，担起了分布式计算的职责，而 FIL 是存储领域的老大。印象里 libp2p 是 Filcoin 开发的，而很多区块链像 ETH 用的 p2p 模块，就直接用的是 libp2p。以及目前非常广泛使用的 IPFS，也是 Filecoin 实验室开发的。所以 FIL 在研发方面实力很强，未来也许会有得到突破的一天。</p><p>最后是智能合约平台类型。其实我不太喜欢智能合约，很多人喜欢把智能合约等同于区块链，或者认为只有支持智能合约的区块链才叫区块链。在囤币方面，币只是智能合约平台的 <a href="/micro-blog/#2024-31">燃料</a>，又没有供应量上限，囤它干嘛。但是智能合约平台火，玩的人多，价格居高不下。ETH、SOL、TON 的特点都是支持智能合约、现在关注量比较大，所以适当分配一些比例上去。</p><p>另外这是一些热门币没有被涵盖进来的原因：</p><table><thead><tr><th align="center">币种</th><th align="center">未选择原因</th></tr></thead><tbody><tr><td align="center">BNB</td><td align="center">平台币，不是链</td></tr><tr><td align="center">DOT</td><td align="center">没有供应量上限、APR 很高</td></tr><tr><td align="center">ATOM</td><td align="center">没有供应量上限、APR 很高</td></tr><tr><td align="center">AVAX</td><td align="center">没有供应量上限、没看到明显优点</td></tr><tr><td align="center">APT, SUI</td><td align="center">BFT 类共识</td></tr><tr><td align="center">所有 ERC-20 代币</td><td align="center">不是链</td></tr><tr><td align="center">所有 Memecoin</td><td align="center">没有长期价值</td></tr><tr><td align="center">铭文、符文</td><td align="center">BTC 手续费太贵</td></tr></tbody></table><p>祝自己好运！</p><h3 id="更新（2024-09-26）"><a href="#更新（2024-09-26）" class="headerlink" title="更新（2024.09.26）"></a>更新（2024.09.26）</h3><p>去掉了原先投资组合中的 XEC 和 DASH。因为在原先的选择中，XEC 和 DASH 本就是理由不充分的两个标的，而他们的总市值排名在 100 左右甚至之外，社区热度也比较差。</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><del>10</del></td><td align="center"><del>XEC</del></td><td align="center"><del>3%</del></td><td align="center"><del>PoW, UTXO</del></td><td align="center"><del>非常高</del></td><td align="center"><del>✅</del></td></tr><tr><td align="center"><del>11</del></td><td align="center"><del>DASH</del></td><td align="center"><del>2%</del></td><td align="center"><del>PoW, UTXO</del></td><td align="center"><del>非常高</del></td><td align="center"><del>✅</del></td></tr></tbody></table><p>更重要的是，现在要用 XMR 来代替它们原先占有的共 5% 的比例。XMR 是暗网使用的 <a href="https://x.com/DarkDotFail/status/1765104459913330820">主要货币</a> 之一，暗网仅接收 BTC 和 XMR。XMR 在隐私保护方面非常强。而在暗网的应用领域，XMR、XEC、DASH 其实是经常被 <a href="https://x.com/Altcoinbuzznews/status/1746989440373784958">并列讨论</a> 的三个币种。要在这三个同类型代币中选择一个的话，就首选 XMR。</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">10</td><td align="center">XMR</td><td align="center">5%</td><td align="center">PoW, UTXO</td><td align="center">非常高</td><td align="center">❌</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;随着时间的推移以及对市场的更深入了解，定投策略尤其是投资组合会产生非常大的变化，所以在标题中用（一）标识，如果定投策略有变动，可能还会有（二）、（三）……当然也会同时说明变动的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年以来开始更加关注投</summary>
        
      
    
    
    
    
    <category term="定投策略" scheme="https://smallyu.net/tags/%E5%AE%9A%E6%8A%95%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>PoS 类型的区块链如何处理分叉</title>
    <link href="https://smallyu.net/2024/08/22/PoS%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%88%86%E5%8F%89/"/>
    <id>https://smallyu.net/2024/08/22/PoS%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%88%86%E5%8F%89/</id>
    <published>2024-08-22T09:41:01.000Z</published>
    <updated>2024-08-22T13:48:12.728Z</updated>
    
    <content type="html"><![CDATA[<p>主流公链从共识机制的角度基本上可以分为 3 类，分别是 PoW、PoS、PBFT。选择了不同的共识，也就很大程度上决定了网络的 TPS、去中心化程度、节点规模。</p><p>除了 PoW，另外两种共识 PoS 和 PBFT 都面临一个基本的问题，就是当网络发生了软分叉，该如何恢复？由于 PoS 和 PBFT 产生块不需要算力成本，也就不能用和 PoW 一样的最长链原则。</p><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><h4 id="共识概览"><a href="#共识概览" class="headerlink" title="共识概览"></a>共识概览</h4><p>PoW 系列的链有 BTC、BCH、BSV、LTC、DOGE、ZEC 等。PoW 都使用最长链原则，节点在面对多个发生了分叉的链时，直接选择块高度最高的一条就行了。由于每产生一个块都需要庞大的算力，攻击成本比较高。</p><p>PoS 系列的链有 ETH、BNB、TRON、DOT、TON、ADA、AVAX、NEO 等。几乎目前所有智能合约平台类型的链，都属于 PoS 共识。</p><p>PBFT 系列的链有 ATOM、SOL、TON、ONT、APT、SUI 等。其中 Cosmos 最为知名，Solana 有超越以太坊的势头，The Open Network 今年也发展的很好。</p><p>这里可能会觉得有点奇怪，怎么把 SOL 归类到 PBFT 上了？SOL 不是 PoH 共识吗？SOL 不也有质押的功能，比如在 Solflare 钱包上还可以质押获得收益的吗？TON 也有质押和收益啊？</p><p>这里是两个问题。</p><p>首先 Solana 的确开发和使用了 BFT 类的共识，叫 <a href="https://solana.com/news/8-innovations-that-make-solana-the-first-web-scale-blockchain">Tower BFT</a>，PoH 是用来解决 Solana 链上的时钟问题的，而不是一种完整的共识机制。 </p><p>其次是 PoS+BFT 类共识，算 PoS 还是 BFT？上面提到的分类，PoS 主要指 PoS、dPoS、PoS Casper 这些，凡是用到 BFT 的都归类为 PBFT 作为区分。最明显的就是 Cosmos 也有质押和收益功能，但很少有人会说 Cosmos 用的是 PoS。</p><h4 id="关于分叉"><a href="#关于分叉" class="headerlink" title="关于分叉"></a>关于分叉</h4><p>PoS 共识和 PBFT 共识面对分叉问题的时候，有两个方面。</p><p>一方面是质押者列表（以太坊叫 <code>Validators</code>，Cardano 叫 <code>Stakeholders</code>）是否一致，因为 PoS 和 PBFT 大都是使用 VRF 从一组候选列表中选择出一个节点作为出块节点，那么 PoS 和 PBFT 类共识在处理这个问题的时候有哪些异同？</p><p>另一方面是当网络分叉后，在选择链的规则（以太坊叫 <code>Forkchoice</code>，Cardano 叫 <code>Chain selection rule</code>）方面有什么异同？</p><h3 id="质押者列表不一致"><a href="#质押者列表不一致" class="headerlink" title="质押者列表不一致"></a>质押者列表不一致</h3><h4 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a>联盟链</h4><p>从最简单的联盟链开始分析。联盟链的特点是没有 coin，也就完全没有质押方面的内容，只是单纯的 PBFT。</p><p>联盟链顾名思义，有非常高的准入门槛，需要经过审核或者某种授权也能够成为联盟成员。具体到技术层面，就是想要加入网络，需要在其他节点都知道的情况下，比如所有节点的配置文件里，都包含一个网络成员的列表，列表里定义了网络的节点公钥以及对应的 index，想要增加节点就需要其他所有节点都改一下配置文件。</p><p>节点在出块的时候，就会从这个列表中使用 VRF 随机选择一个作为出块节点。一般 VRF 返回的是一个简单的数字，对应公钥列表的 index，出块节点用这个公钥来对块签名。</p><p>这样的做法比较笨拙，但也是联盟链的特点。在这种模式下，节点的质押着列表不太可能不一致，如果不一致就是配置文件写错了。而且配置错误的情况下，它将永远是错误的，排查起来很简单。</p><h4 id="Cosmos"><a href="#Cosmos" class="headerlink" title="Cosmos"></a>Cosmos</h4><p>Cosmos Hub 用的共识叫 <a href="https://docs.cometbft.com/v0.37/introduction/">CometBFT</a>，基本流程是花费不少于 180 个 ATOM 注册成为 Validaotr，然后就有可能会选为出块节点。</p><p>由于 BFT 类共识在出块之前就需要投票，所以假如网络中真的出现了质押者列表不一致的情况，在同一个块高度会有两个节点产生出两个块，此时网络中的其他节点会对这两个块进行投票。</p><p>这个时候也分两个场景，就是网络正常和网络异常的情况。</p><p>在网络正常的情况下，现在有两个块，一定只能有一个块收到大于 2&#x2F;3 的投票，不可能两个块都收到大于 2&#x2F;3 的投票。所以在出块之前，就已经把质押者列表和其他节点不一致的节点排除在外了，不会影响后续流程。</p><p>在网络异常的情况下，节点感知不到其他节点的存在，即使当前节点的质押者列表正好是当前子网络中的有限几个节点，其他几个节点也不会把票投过来。除非整个子网络都断网了、质押者列表还发生了一样的错误，那这个自网络就自己在局域网玩吧。网络异常本身就是一种异常情况了，与外界隔绝。</p><h4 id="Cardano"><a href="#Cardano" class="headerlink" title="Cardano"></a>Cardano</h4><p>Cardano 的 PoS 是最纯粹的 PoS，没有投票机制。Cardano 的共识经历了<a href="https://iohk.io/en/blog/posts/2022/06/03/from-classic-to-chronos-the-implementations-of-ouroboros-explained/">很多次演进</a>（内容很多很复杂，我没看完）。</p><p>Cardano 网络的规则是，任何人都可以质押任意金额到 Stake pools 中成为 <a href="https://docs.cardano.org/about-cardano/learn/delegation/">Delegator</a>，这些 Delegator 按照质押金额的比例共享矿池的收益，但是不会有出块的资格。</p><p>在 Cardano 网络中真正有出块权限的是 Stake pools，也就是说有可能被选为出块节点的节点，都在 <a href="https://preprod.cexplorer.io/pool">矿池列表上</a> 了，数量不多，目前大概 300 个左右，每个 solt 将从中随机选择一个来产生块。</p><p>那么 Stake pools 节点注册之后，如果节点之间出现 Stake pools 列表不一致的情况怎么办？Cardano 的文档中有 <a href="https://developers.cardano.org/docs/operate-a-stake-pool/introduction-to-cardano#how-it-works">描述</a>，当遇到同一 slot 产生了两个块的时候，就开始启用链选择的规则（Chain Selection Rule）了。也就是说，实际上当第二个块被产生出来，链就已经分叉了，然后所有节点都启用链选择的规则，来进行恢复。</p><h4 id="Ethereum"><a href="#Ethereum" class="headerlink" title="Ethereum"></a>Ethereum</h4><p>以太坊要成为 Validator 需要花费 32 个 ETH 把节点信息注册到 <a href="https://etherscan.io/address/0x00000000219ab540356cbb839cbe05303d7705fa">质押合约</a> 上，然后其他所有的 Validator 都会从质押合约获取质押者列表的信息。</p><p>那怎么确定其他 Validators 都已经把质押者信息从合约同步到本地了？你可以在 Beacon Chain 浏览器的任意一个 <a href="https://beaconcha.in/block/20584195">块信息</a> 上，找到一个叫 <a href="https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/validator.md#eth1-data">Eth Data</a> 的字段，这个字段对于质押者列表非常重要，当一个 validator 被选为出块节点时，它会把当前节点同步到的质押者列表信息，一起打包进块里，包括质押者的总数以及 Deposit root 信息。</p><p>以太坊网络大概每 17 个小时进行一次 <a href="https://github.com/ethereum/consensus-specs/blob/v1.3.0/specs/phase0/validator.md#process-deposit">质押者列表的更新</a>。在这个周期中，只有超过半数区块的 Eth Data 包含了新增的 validator，新的 validator 才会真正加入到网络中。</p><p>所以以太坊要加入 validators 的过程是漫长而且严格的，首先要确认其他 proposer 已经同步了相关信息，才会真正更新质押者列表。在这样的规则模式下，质押者列表很难不一致。</p><h3 id="分叉链选择"><a href="#分叉链选择" class="headerlink" title="分叉链选择"></a>分叉链选择</h3><h4 id="Ethereum-1"><a href="#Ethereum-1" class="headerlink" title="Ethereum"></a>Ethereum</h4><p>以太坊中如果出现了多条分叉的链，选择起来时相对容易的，因为以太坊有投票机制，每一个块上都包含了有多少个 validators 对块进行了投票。可以猜想到，在发生分叉时，只要不断选择投票数多的块就可以了。</p><p>而实际上以太坊的分叉选择基于 <a href="https://ethos.dev/beacon-chain">checkpoint 机制</a>，每个块是一个 slot，每 32 个 slot 是一个 epoch，每个 epoch 都是一个检查点。一个检查点收到大于 2&#x2F;3 的投票，就进入了 justified 的状态，当一个检查点的下下个检查点也进入 justified 状态，当前检查点就认为是 finalized 状态了。所以在以太坊中，一笔交易最终被标记为 finalized 需要 15 分钟。</p><p>这里提到的检查点，也就是 <a href="https://arxiv.org/abs/1710.09437">FFG</a> 进行 forkchoice 的依据，每条链会选择 checkpoint 多的链。所以以太坊的共识不是选择 “有最多块的链” 原则，而是选择 “有最多检查点的链” 原则，检查点最多的链就是主链。</p><h4 id="Cardano-1"><a href="#Cardano-1" class="headerlink" title="Cardano"></a>Cardano</h4><p>Cardano 最新在使用 <a href="https://developers.cardano.org/docs/operate-a-stake-pool/introduction-to-cardano/#what-if-for-some-reason-there-is-a-fork">Chain selection rule</a>，是由 <a href="https://dl.acm.org/doi/10.1145/3243734.3243848">Ouroboros Genesis</a> 版本提供的。</p><p>Ouroboros Genesis 的上一个版本是 <a href="https://link.springer.com/chapter/10.1007/978-3-319-78375-8_3">Ouroboros Praos</a>，Praos 版本中提出了一套叫 <code>maxvalid</code> 的规则，Genesis 版本基于 <code>maxvalid</code> 做了一点改进，把 <code>moving checkpoint</code> 的特性结合了进来，形成了新版本叫做 <code>maxvalid-mc</code> 的规则。</p><p>移动检查点简单理解就是，本地链在面对多条分叉链时，如果没有超过 k 个块，就选最长的链，如果超过了 k 个块，就直接不选它。也就是说本地链只会在 k 个块的范围内，选择链最长的一个。而 k 个块的范围就是所谓的移动检查点（moving checkpoint）。加了这样限制的好处就是可以避免最长链攻击。当然 Cardano 制定这样的规则经过了一系列学术上的推演以及实际场景的检验。</p><h4 id="Cosmos-1"><a href="#Cosmos-1" class="headerlink" title="Cosmos"></a>Cosmos</h4><p>PBFT 链在网络正常的情况下，只要保证质押者列表一致，就不会分叉。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，每种共识的具体实现，都包含了详细的处理分叉的规则，而且这些老牌公链都经过了实际运行的检验。具体如何实现与链的设计理念有关。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;主流公链从共识机制的角度基本上可以分为 3 类，分别是 PoW、PoS、PBFT。选择了不同的共识，也就很大程度上决定了网络的 TPS、去中心化程度、节点规模。&lt;/p&gt;
&lt;p&gt;除了 PoW，另外两种共识 PoS 和 PBFT</summary>
        
      
    
    
    
    
    <category term="共识机制" scheme="https://smallyu.net/tags/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Ethereum Casper 为什么需要 EIP-7251</title>
    <link href="https://smallyu.net/2024/06/09/Ethereum-Casper-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-EIP-7251/"/>
    <id>https://smallyu.net/2024/06/09/Ethereum-Casper-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-EIP-7251/</id>
    <published>2024-06-09T15:57:17.000Z</published>
    <updated>2024-08-03T19:07:09.964Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1710.09437">Casper the Friendly Finality Gadget</a> 是以太坊现在使用的共识机制，属于 PoS 的一种实现。这种关系类似于同样是 PoW 挖矿，Bitcoin 使用 sha256 而 Dogecoin 使用 scrypt。其他的 PoS 实现还有比如 Cardano 的 Ouroboros。</p><p><a href="https://eips.ethereum.org/EIPS/eip-7251">EIP-7251</a> 的主张是增加单个验证者的质押额度上限，原先是 32 ETH，希望改为 2048 ETH，这样可以有效减少验证者的数量，同时有效 P2P 网络的通信量。</p><p>这项改动有点迫在眉睫，因为以太坊在测试环境中模拟了大量质押者的情况，<a href="https://notes.ethereum.org/@parithosh/bigboi-beaconchain-test-2">测试结果</a> 显示，当质押者数量达到 2.1 M，网络的投票率会不到 50%，已经不能正常进入 Final 状态，意味着检查点机制失效，整个网络处于非常不安全的状态。而以太坊现在的验证者数量已经达到了 <a href="https://beaconscan.com/stat/validator">1.4M</a>。如果不及时做出改变，以太坊网络将在不久的将来奔溃。</p><p>那为什么以太坊会面临这样的困境？PoS 不是公链专属的共识机制，能够适用于大规模网络的吗？</p><p>究其原因，Ehtereum Casper 其实是对 BFT 的改进，而不是对 PoS 的改进。</p><p>先来看看 Vitalik 是怎么描述 Ethereum Casper 的，他把 Ehtereum Casper 相对于 BFT 的改进视为重中之重：</p><img src="1.png" /><p>再来看一下 Ehtereum Casper 的具体流程：节点质押资产成为验证者，然后通过 VRF 来随机选择一个节点出块，出块后所有验证者都对块的有效性进行一次投票。这些投票会先投递给委员会的成员，委员会成员聚合投票结果之后，再在委员会成员之间同步。委员会成员是每隔一段时间随机选举出来的。</p><p>对于了解 BFT 但是不了解 Ethereum Casper 的人，在接触到以太坊网络后，当知道只有收到 2&#x2F;3 投票的块才有资格被标记为 Final 状态时，会不会对 2&#x2F;3 这个数字有点敏感？因为 2&#x2F;3 是 BFT 一直在强调的投票比例，以保证 3f+1 的容错能力。</p><p>BFT 的投票机制保障了网络绝对不存在分叉，以太坊引入了 BFT 的这个优点，使得 Ethereum Casper 处理分叉场景相对容易，只需要判断哪个区块的得票率最高，就可以认定主流块了。如果验证者同时对两个块投票，验证者会为此受到惩罚，这也是以太坊在众多 PoS 链中唯一一个有 Slash 机制的原因。同时结合 checkpoint 机制，以太坊就可以面对非常复杂的分叉情况，整个网络分叉成树都能从中找出主链。</p><p>问题在于，Ethereum Casper 在引入 BFT 优点的同时也引入了 BFT 的缺点，那就是通信量过大。BFT 的通信量是 O(n<sup>2</sup>) 级别的，一般只能承受 100 个以下的节点规模，例如 <a href="https://ar5iv.labs.arxiv.org/html/2303.11045">这篇报告</a> 就给出了具体的数值。</p><p>可以大致计算对比一下 BFT 和 Ethereum Casper 的消息量。</p><p>BFT 在 100 个节点的时候大概是 50 tps 的能力，消息膨胀量 O(n<sup>2</sup>)，那么消息数量是：</p><pre><code>n = (100^2) * 50)  = 500000  = 0.5 M/s</code></pre><p>Ethereum Casper 在 2M 验证者的时候大概 50% 的投票率，以太坊的块时间是 12 秒，一共 64 个委员会，消息膨胀量 O(n)，那么消息数量为：</p><pre><code>n = 2M * 0.5 / 12 * 64  = 1000000 / 12 * 64  = 5 M/s</code></pre><p>这样计算比较草率和粗略，结果数字上差了一个数量级，但是考虑到两种共识机制具体实现上有很大差异，包括测试的硬件环境差异，有出入很正常，总体上差不太多。</p><p>所以由于以太坊集成了 BFT 的投票机制，导致以太坊网络需要大量的通信量。或者说，Ehtereum Casper 改进了 BFT 并且把 Stake 机制加入其中，使得 BFT 更进一步能够支撑起十万规模的节点数量。</p><p>同时，有没有注意到，Ethereum Casper 的消息膨胀量仅仅只是 O(n)，为什么呢，因为 Ethereum Caspe 不需要进行第二次投票，一次就够了。</p><p>另外，委员会机制有点像联盟链的分层共识。有些国内公司需要在没有 token 概念的前提下，对区块链技术进行改进，但是 BFT 算法最多只能撑起几十个节点的规模，于是有了基于 BFT 的分层共识，基本思路是，从所有节点中选出一部分节点作为提案节点，然后提案节点来进行出块和投票，其他节点只接收数据，并且每隔一段时间换一次共识组（提案节点）。</p><p>对于联盟链，VRF + BFT + 分层共识已经是比较完善的技术组合了。</p><p>与之相比，以太坊多出来的是 Stake 机制，联盟链中每一个节点都是验证者，都有机会出块，而以太坊想成为验证者，需要事先质押一定量的 token 才行。后面的委员会机制相比分层共识，也有一些改进，委员会机制保留了每一个验证者的投票权，只是选出一些代表来归集投票结果。而分层共识直接剥夺了多数节点的出块权，只有少数节点负责出块。</p><p>所以以太坊的共识能简单理解为 Stake + VRF + BFT + 委员会机制。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1710.09437&quot;&gt;Casper the Friendly Finality Gadget&lt;/a&gt; 是以太坊现在使用的共识机制，属于 PoS 的一种实现。这种关系类似于同样是 PoW 挖矿，Bitcoin</summary>
        
      
    
    
    
    
    <category term="以太坊" scheme="https://smallyu.net/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="BFT" scheme="https://smallyu.net/tags/BFT/"/>
    
  </entry>
  
  <entry>
    <title>区块链中的 PBFT 不需要第二次投票</title>
    <link href="https://smallyu.net/2024/06/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84PBFT%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8A%95%E7%A5%A8/"/>
    <id>https://smallyu.net/2024/06/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84PBFT%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8A%95%E7%A5%A8/</id>
    <published>2024-06-03T03:09:21.000Z</published>
    <updated>2024-08-03T19:07:10.036Z</updated>
    
    <content type="html"><![CDATA[<p>PBFT 为什么需要进行两次投票，第二次投票的作用是什么？这个问题困扰我很久。</p><h3 id="逆向推导"><a href="#逆向推导" class="headerlink" title="逆向推导"></a>逆向推导</h3><p>从这个角度想，第二次投票在什么情况下是发挥作用的？在第二次投票的结果和第一次不一致的情况下，才是发挥作用的。如果第二次投票的结果和第一次严格一致，那当然没有必要进行第二次投票。</p><p>那在什么情况下，第二次投票的结果会和第一次不一样？只有当恶意节点存在并且刻意在第二次投票阶段投出不同的票，两次投票的结果才会不一样。</p><p>这是传统 PBFT 的常规操作流程图，其中节点 3 是错误节点或者恶意节点，从始至终没有响应：</p><img src="1.png" width="70%"><p>这是去掉 prepare 阶段，只保留一次投票过程的流程图，其中节点 3 仍然是错误节点，没有响应：</p><img src="2.png" width="60%"><p>关键在于，在这个场景中，节点 0、1、2 都是诚实节点，绝不可能恶意投票或者不投票，那么 commit 阶段的结果一定是和 prepare 的结果一致的，所以即使去掉 prepare 阶段，系统最终也会达成一致。</p><p>节点 3 一直都是恶意节点，如果在 commit 阶段，0、1、2 中的某个节点投出了和 prepare 不一致的票，整个系统就存在超过 1 个恶意节点，超出了容错能力。</p><h3 id="正向理解"><a href="#正向理解" class="headerlink" title="正向理解"></a>正向理解</h3><p>要证明第二次投票是必要的，等同于说明如果没有第二次投票，系统将会无法正常运转。</p><p>逻辑上，即使说第二次投票有各种各样的好处，通过冗余来增加系统的容错能力、能够及时发现错误并且快速调整到一致的状态等，也不能说明第二次投票是非要不可的。比如这个 <a href="https://cs.stackexchange.com/questions/54152/why-is-the-commit-phase-in-pbft-necessary">Why is the commit phase in PBFT necessary?</a> 中的高赞回答，说了很多但只是正向解释了 commit 阶段的设计和作用。</p><p>我目前看到比较靠谱的一个解释在这里：<a href="https://stackoverflow.com/questions/51125238/pbft-why-cant-the-replicas-perform-the-request-after-2-3-have-prepared-why-do">PBFT: Why cant the replicas perform the request after 2&#x2F;3 have prepared? why do we need commit phase?</a> </p><p>其中提到如果没有 commit 阶段，当 view change 的时候，节点将无法保证请求执行的顺序。</p><p>我觉得 StackOverFlow 中的描述和高赞回答提到的论文含义还是有出入的。高赞回答的意思是，节点的 execute 因为缺少 commit 阶段而不一致，有的快有的慢。但即使有两轮投票，节点也可能在 commit 阶段之后 execute 之前发生故障，导致执行上的差异，所以这种故障还不是关键场景。</p><p>更加合理的场景是论文 <a href="https://pmg.csail.mit.edu/papers/bft-tocs.pdf">Practical Byzantine Fault Tolerance and Proactive Recovery </a> 中提到的，view change 发生的时候，不同的请求使用了相同的序列号，被打包进不同的 view 中。（这句话很凌乱）</p><blockquote><p>Replicas may collect prepared certificates in different views with the same sequence number and different requests. The commit phase solves this problem as follows.</p></blockquote><h3 id="单次投票流程"><a href="#单次投票流程" class="headerlink" title="单次投票流程"></a>单次投票流程</h3><p>这个场景基于只投票一次的流程，也就是没有 prepare 阶段的流程。</p><h4 id="场景设置"><a href="#场景设置" class="headerlink" title="场景设置"></a>场景设置</h4><p><strong>视图 V1</strong></p><ol><li>R1 提出提议 P，并广播给 R2, R3, R4。</li><li>提议 P 在 R2, R3, R4 被执行，但 R1 未执行</li></ol><pre><code>R1: --R2: P --&gt; 执行 PR3: P --&gt; 执行 PR4: P --&gt; 执行 P</code></pre><p><strong>视图切换到 V2</strong></p><ol><li>假设 R1 发生故障，视图切换到 V2</li><li>R2 提出新的提议 P’</li><li>R2 提出新的提议 P’ 并广播给 R1, R3, R4</li><li>新的提议 P’ 被所有副本执行</li></ol><pre><code>R1: --      P&#39; --&gt; 执行 P&#39;R2: P --&gt; 执行 P      P&#39; --&gt; 执行 P&#39;R3: P --&gt; 执行 P      P&#39; --&gt; 执行 P&#39;R4: P --&gt; 执行 P      P&#39; --&gt; 执行 P&#39;</code></pre><h4 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h4><p>假设提议 P 和 P’ 是对相同账户余额的操作：</p><ul><li>提议 P：增加账户 A 的余额 10 单位。</li><li>提议 P’：减少账户 A 的余额 5 单位。</li></ul><p>在视图 V1 和 V2 中的操作顺序和结果如下：</p><p><strong>视图 V1</strong></p><pre><code>R1: 账户 A 余额 = 100 (未执行 P)R2: 账户 A 余额 = 110 (执行 P)R3: 账户 A 余额 = 110 (执行 P)R4: 账户 A 余额 = 110 (执行 P)</code></pre><p><strong>视图 V2</strong></p><pre><code>R1: 账户 A 余额 = 100 (未执行 P) --&gt; 执行 P&#39; --&gt; 账户 A 余额 = 95R2: 账户 A 余额 = 110 (执行 P) --&gt; 执行 P&#39; --&gt; 账户 A 余额 = 105R3: 账户 A 余额 = 110 (执行 P) --&gt; 执行 P&#39; --&gt; 账户 A 余额 = 105R4: 账户 A 余额 = 110 (执行 P) --&gt; 执行 P&#39; --&gt; 账户 A 余额 = 105</code></pre><h4 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h4><p>再来重复一下这句话，不同的请求（R2）使用了相同的序列号（R1 认为是 P），被打包进不同的 view （P’）中。相同的序列号应该是指执行的时序，就是当前时间点轮到哪个请求执行了。</p><p>在上面这个场景中，确实由于 A 节点故障导致最终状态出现了不一致。</p><h3 id="两次投票"><a href="#两次投票" class="headerlink" title="两次投票"></a>两次投票</h3><p>两次投票的流程又是如何解决上述场景中的问题？</p><ol><li>如果 A 节点故障发生在收到 prepare 结果之后、开始 commit 之前，所有节点都不会进入 execute 阶段。</li><li>如果 A 节点故障发生在收到 commit 结果之后、开始 execute 之前，A 节点会根据 commit 结果再次尝试执行 P，然后再执行 P’</li></ol><h4 id="场景分析-1"><a href="#场景分析-1" class="headerlink" title="场景分析"></a>场景分析</h4><p>是不是注意到，第 2 条存在一点不公平？</p><p>两次投票的场景下，A 节点可以根据 commit 结果再次尝试执行 P。</p><p>单词投票的场景下，A 节点并没有根据 commit 的结果再次尝试执行 P，而是直接执行了 P’。</p><p>那么其实两次投票并没有完全避免在 execute 之前节点故障导致的状态不一致，仅仅只是通过增加一次通讯的形式，来反复确认其他节点的状态和自己预期是一致的，减少状态不一致的风险。</p><p>两次投票把发现故障的时间提前了，如果节点 A 没有在 commit 阶段发出投票，其他节点就知道 A 节点故障了，而不是等到自己已经 execute 了，才发现 A 没有 execute。多一次确认多一份保障，减少系统 execute 后回滚的成本，尽可能在 execute 之前就商量好。两次投票最大的作用应该也就这样了。</p><p>总的来说，第二次投票始终都没有体现出必须存在的意义，而只是带来了一些好处，加强了系统的安全性。这个问题可能类似于，TCP 为什么需要 3 次握手才能建立连接？2 次不行吗？估计 1 次也行，只是会引起一些麻烦，3 次确认足够保险。</p><h3 id="无状态与有状态"><a href="#无状态与有状态" class="headerlink" title="无状态与有状态"></a>无状态与有状态</h3><p>为什么 PBFT 需要反复确认，尽量避免 execute 之后的状态不一致呢？也许任何系统的回滚都是一件非常慎重的事情，所以不惜增加 execute 之前的沟通成本。</p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>回到上面单次投票的场景，出故障的 A 节点在什么情况下就不会执行 P’ 了？</p><ol><li>A 节点知道自己执行 P 失败了</li><li>执行 P’ 之前一定要执行 P</li></ol><p>满足这两个条件，即使是单次投票，也可以实现和两次投票一样的效果。</p><p>对于无状态的系统，如果节点只记录了一个最终的数字，那还挺难办的，节点知道自己没有执行 P，然后收到了一个 P‘，节点 A 将无法分辨 P’ 的位置，是在 P 后面还是和 P 同等位置。</p><p>正常顺序是：</p><pre><code>O -&gt; P -&gt; P&#39;</code></pre><p>对于 A 节点来说，知道自己没有执行 P，但是收到了一个 P’：</p><pre><code>O -&gt; (P&#39;)?</code></pre><p>要不要执行呢？A 节点就执行了，状态就错乱了。</p><p>基于这一点原因，无状态的系统的 execute 是非常慎重的。</p><h4 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h4><p>区块链属于有状态的系统，天然记录了自己的执行记录（区块），以及会对请求进行强制的排序（区块哈希、父哈希）。</p><p>一个节点收到了区块，它一定能够判断出这个区块的位置，是否应该本轮执行，以及自己是否缺少区块，及时从其他节点把区块同步过来。</p><p>所以在区块链的使用场景下，如果只是为了达到多数节点最终状态一致的效果，完全没有必要进行第二次投票。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>PBFT 为什么需要进行两次投票？这个问题在 GPT-4o 的知识边界，详细追问它，它就会开始胡说八道了，这符合 GPT-4o 不了解就开始编造的特点。</p><p>以我有限的互联网信息搜索能力，我一直没有找到一个足以让我信服的理由，证明 PBFT 中的第二次投票是必要的。</p><p>经过我自己反复的推演，我能得到的结论只有二次投票并不是必须的，仅有一次投票，也可以达到多数节点一致的结果。</p><p>可为什么长久以来，PBFT 包括各种变体 Tendermint、HotStuff，都保留了两次投票的流程？为什么从来没有人质疑过第二次投票其实不需要？</p><p>我到底错在哪里？也许是对 PBFT 了解不够深入，还没有触及到第二次投票真正发挥作用的场景吧？可如果真的存在这样的场景，为什么没有找到资料把这种场景直接了当地描述出来？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;PBFT 为什么需要进行两次投票，第二次投票的作用是什么？这个问题困扰我很久。&lt;/p&gt;
&lt;h3 id=&quot;逆向推导&quot;&gt;&lt;a href=&quot;#逆向推导&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="BFT" scheme="https://smallyu.net/tags/BFT/"/>
    
  </entry>
  
  <entry>
    <title>开发者的思维方式</title>
    <link href="https://smallyu.net/2024/05/30/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    <id>https://smallyu.net/2024/05/30/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/</id>
    <published>2024-05-30T05:46:26.000Z</published>
    <updated>2024-08-03T19:07:10.105Z</updated>
    
    <content type="html"><![CDATA[<p>前情提要：《<a href="https://www.yinwang.org/blog-cn/2015/02/01/creative-thinking">创造者的思维方式</a>》——王垠</p><hr><p>发现一个现象，当你说 A 好的时候，别人会说 A 没有 B 好，所以 A 不好。</p><p>第一个案例是当你说 SOL 的技术比 BNB 好的时候，就会引来争议了。有人拿 SOL 宕机过几次来证明 SOL 技术不好，还有人说炒币根本不是技术导向，而是资本导向，技术好不好不重要。这些观点反映了各自不同的立场。</p><p>从开发者的角度，没有人会把 BNB 看作一条区块链，因为它是平台币，节点中心化运维，运营模式也不是链的方式。技术上 fork Geth 的代码做了一些魔改，比 Geth 早一步用上了 PoS，以增加对整条链的控制。ETH 完成坎昆升级后，BNB 也模仿着搞上了自己的 BIP-4844，显然和 ETH 属于相同的技术体系。</p><p>另一个观察角度是，ETH 的 ETF 接近通过后，大家开始讨论下一个能上 ETF 的是 DOGE 还是 SOL，甚至是 DOT，但没有人会提到 BNB，充分说明了 BNB 和其他公链不一样，都不是一个赛道。判断两个产品是否属于同一个赛道的方法，可以看其是否存在竞争关系，你死我活那种。如果 BNB 用了 ETH 的技术还希望 ETH 死掉，在逻辑上是不通顺的。正常逻辑应该是希望 ETH 更好，BNB 也会跟着受益。</p><p>而从使用者（炒币）的角度，管你用的什么技术，管你技术好不好，一个表情包都能市值前十，一个戴帽子的狗都能市值上亿，投资人在哪儿我就去哪儿，资本炒什么我就买什么，FOMO 就完事了。</p><p>第二个案例是当你说 SOL 技术好的时候，别人会说 ETH 更好，所以 SOL 不好。</p><p>同样是立场问题，站在使用者的角度，有无数理由来对比两个项目的好坏。当你说 A 好的时候，总是有人可以找到一个比 A 好的 B，或者只有某个方面好于 A 的 C。使用这样的技巧，他们可以打败任何人、任何项目。而且这里面也存在非常大的争议空间、鄙视链，就好像到底 PHP 是不是世界上最好的语言？</p><p>但是站在开发者的角度，如果我要开发一条链，我的链要和 SOL 比技术、抢市场，我能不能做的比 SOL 更好？肯定不能。那么在这个立场下，我说一句 SOL 技术挺好，不过分吧？</p><p>这里的 SOL 只是举例，其实只要是 CMC 前 100 的老牌公链，都有一些闪光点，尤其是开创和尝试了不一样共识算法的，它们也许不如 ETH 和 SOL 备受关注，但是也做出了不错的成绩。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前情提要：《&lt;a href=&quot;https://www.yinwang.org/blog-cn/2015/02/01/creative-thinking&quot;&gt;创造者的思维方式&lt;/a&gt;》——王垠&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;发现一个现象，当你说 A 好的时候，别人会说 A 没有 B</summary>
        
      
    
    
    
    
    <category term="思维方式" scheme="https://smallyu.net/tags/%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>发币的核心要点</title>
    <link href="https://smallyu.net/2024/05/26/%E5%8F%91%E5%B8%81%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/"/>
    <id>https://smallyu.net/2024/05/26/%E5%8F%91%E5%B8%81%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9/</id>
    <published>2024-05-26T14:31:26.000Z</published>
    <updated>2024-08-03T19:07:10.041Z</updated>
    
    <content type="html"><![CDATA[<p>首先关于《炒币投资的小 tips》再补充两点：</p><ol><li><p>比特币本位还是法币本位或者其他币本位，主要还看手里有什么、什么币来的容易，没有银弹的逻辑适用于任何场合.</p></li><li><p>随着 ETH 的 ETF 通过了一半，意味着 SEC 也许会接受 PoS，只是要求 ETF 的资金不能用于质押（我还没理解为什么）。之前提到要在 CMC 前 100 里挑，可能需要再加一个条件，就是没有曾经被 SEC 称作证券的。也许在换人后，或者新法案通过后，加密货币将不归 SEC 管，但至少说明在同等的判断标准下，很多币明显存在问题，ETH 一直属于模棱两可的状态，所以目前在 ETF 的状况比较复杂。<br>  其实比较安全可靠的币屈指可数。例如 DOT 的出镜率不高，SEC 没有对 DOT 有过定义，但是 DOT 的质押率已经达到流通量的 57%，而且还保持着 17% 的年利率，我还无法理解这是一种什么样的状况，质押率高的后果是什么，为什么 DOT 收益率可以这么高，假如所有持有者都平等获得年利率，不就相当于通胀吗，币价得跌。对于网络来说，质押率越高倒是越安全。但是流通中的币越少，说明这个币没啥用，甚至不能用于合约的手续费来消耗。这种理解不了的币也是不能买的。</p></li></ol><p>然后是关于发币。最近无意间听到李笑来以前在网上流传的录音，还是有不少启发。</p><p>所有币的核心要点就一个，就是把币通过有价值的形式分发出去。持有者认为它值什么价格，它就是什么价格，只要持有者不卖，价格就不会跌。包括 BTC，是通过挖矿的形式分发，10 分钟发一次，无论多少人参与，10 分钟、固定数量，总会有一个胜出者，而且胜出者有随机性，增加了活跃参与的程度。</p><p>ETH 也是通过挖矿，每 12 秒钟一次，把块奖励发给矿工，奖励分发上和 BTC 差不太多，ETH 最大的两个黑点是：</p><ol><li>开发团队有预挖，挖了多少不清楚，ICO 低价给了多少人是黑箱</li><li>无限增发的代币模型，总供应量没有上限，是否会带来通胀，是否意味着开发团队可以不断印钱</li></ol><p>李笑来发过一个叫 Caddy 的币，当时给他一个什么社区合作，几百万真实用户，以十分之一的价格给那个群体，让他们在网上点赞转发炒新闻。李笑来自己说，要策划好一个币的前提是自己是网红，有流量、有影响力，是非常重要的条件。因为李笑来自己就算个网红，经常出书、到处演讲、是新东方有名的老师，他的背景是非常深厚的。</p><p>他说的这个关于网红的要点，其实最终作用也就是招来大量粉丝，让这些粉丝认可这个币，币会通过某个价格到达这些粉丝的手里。所以无论是挖矿，还是早期的空投、交易所的 LaunchPool、激励形式的发放，目的都是以有价值的方式发给持有者，持有者必须要付出一点代价，币才会有价值。广撒网白给，币肯定不值钱，但如果和美元一对一锚定，那又是稳定币。所以这个价值还得控制好，不能太具体，也不能没有。</p><p>另外十倍百倍的币是没有逻辑的，一般认为 ETH 的火爆有两个主要原因，一是当时国家出了个政策，交易所里面的 BTC 不能提出去。二是当时有个传销盘，用的 ETH，日利率 1%，大量用户在交易所里花钱买完 ETH 就提出去，放到传销盘里了，币价就涨了上来。好笑的是期间 ETH 的价格涨了上千倍，传销盘甚至可以坚持三年不崩盘……</p><p>FIL 曾经也在国内大量挖矿，价格一度涨到 200，为什么价格那么高，也是传销盘……后来国内不让搞，现在 FIL 就一点活力都没有了，技术是真的好啊。另外一个技术不好的，NEO 也涨了百倍起来的，大家都疯了不知道为什么这么值钱，只有十来个中心化的节点，技术也不行用 C# 写的，号称国产版本的以太坊，主要还是资金盘拉起来的，创始人手里也没多少币，直到现在也能看出来，币价隔一段时间就会拉起一波，只有资金盘能操纵起这样的场面。</p><p>所以技术也不是绝对优先地位，技术属于基础，用来给大家做横向比较的，比如同时有几个项目叫 ETA、ETB、ETC、……、ETH，即使是传销盘也会从中选一个技术相对可靠、有东西可炒作的币来用。然后就是天意了。</p><p>还有是八卦相关的，很多新闻报道李笑来曾经是币圈首富，用四分之一的身价低价买了六位数的比特币，拿了好几年然后经历过好几波牛熊，最后高价卖掉了。但是事情没有那么简单，网上可以查到很多李笑来关于比特币的演讲视频，他绝不是单纯买完币啥也不干，躺着等币价涨，再卖掉。他从复杂的知识层面对比特币有理解、做演讲，肯定是逻辑上相信比特币，才会进入币圈的。这件事情告诉我们，别瞎买，看准了再买，别在交易所上看见个喜欢的代号就买了，或者看见个推广文章就买了，真正能赚钱的人背后都有深厚的逻辑支撑，做了大量功课的。</p><p>另一个版本的八卦是，李笑来曾经组织过一个比特币基金，私募，几万个比特币的规模，用来投资挖矿、交易所、买股票，结果亏的很惨，很多人跟着亏钱还拉了维权群。后来投 EOS 什么的又赚回来了，打折把欠的钱还上。李笑来吹牛自己有六位数的比特币，结果没有啊，警察去搜都搜不着，到现在李笑来都被边控着出不了国。谁知道他到底有没有比特币，他要真有呢，不能放他出去。这件事情告诉我们的道理是，没有人靠炒币发财的，李笑来本来就有钱，有钱了都还在进行各种操作，做投资、搞基金，赚钱总是得做事情，别想着炒币挣钱，买完币放在那儿就等着涨。即使当年属于币圈早期，参与了李笑来比特币基金的人，对比特币的未来也是持怀疑态度，拿不准比特币以后的价值，过程中也洗掉了一大批人。何况现在呢。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;首先关于《炒币投资的小 tips》再补充两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;比特币本位还是法币本位或者其他币本位，主要还看手里有什么、什么币来的容易，没有银弹的逻辑适用于任何场合.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随着 ETH 的 ETF 通过了一半，意味着 SEC</summary>
        
      
    
    
    
    
    <category term="发币" scheme="https://smallyu.net/tags/%E5%8F%91%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>炒币投资的小 tips</title>
    <link href="https://smallyu.net/2024/05/04/%E7%82%92%E5%B8%81%E6%8A%95%E8%B5%84%E7%9A%84%E5%B0%8F-tips/"/>
    <id>https://smallyu.net/2024/05/04/%E7%82%92%E5%B8%81%E6%8A%95%E8%B5%84%E7%9A%84%E5%B0%8F-tips/</id>
    <published>2024-05-04T12:44:13.000Z</published>
    <updated>2024-08-03T19:07:10.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-BTC-是行业底线"><a href="#1-BTC-是行业底线" class="headerlink" title="1. BTC 是行业底线"></a>1. BTC 是行业底线</h3><p>有 Bitcoin，才有加密货币的整个行业。如果哪一天 Bitcoin 被否认了，说 BTC 不安全了、不去中心化了、没有价值了，那么整个行业就没了，BTC 从来没有被超越。而且事实上，除了比特币，其他的全是山寨币，尤其是在老矿工眼里，经历过只有比特币的时代。山寨币都是从作为比特币的模仿者开始，试图做出某些改变，包括以太坊。Vitalik 也搞过染色币、从 PoW 开始发链、来中国募资。一切都从比特币开始。</p><h3 id="2-PoW-抗跌"><a href="#2-PoW-抗跌" class="headerlink" title="2. PoW 抗跌"></a>2. PoW 抗跌</h3><p>2024年4月12日前后，由于多方面因素，普遍认为是因为两个国家擦枪走火、有可能挑起战争的缘故，所有的币平均下跌 20% 左右，币安的 Gainner 排行榜上也全是红色，可以简单将其称为 412 事件。</p><p>观察一下这一波价格变动的情况，可以明显看出，PoW 系列的币，跌幅普遍比 PoS 系列的币小。以 BTC 为首，Doge、LTC、BCH、ZEC、ETC、ETHW。毕竟 PoW 的链是矿工实实在在投入算力在上面，硬件成本在那儿，他们不愿意低价格卖掉。PoS 不一样，把一大堆钱质押进服务器，钱生钱，来的相对容易。ETh、DOT、ADA、COSMOS 等，很多很多，CMC 前 100 估计有 50 个 PoS 的、有质押功能的。</p><h3 id="3-BTC-本位"><a href="#3-BTC-本位" class="headerlink" title="3. BTC 本位"></a>3. BTC 本位</h3><p>炒币的基本逻辑是 BTC 本位的，也就是炒山寨币对比特币的汇率。假如本来有 1 个 BTC，觉得 Doge 最近的上涨幅度会超过 BTC，就把 BTC 换成 Doge，等 Doge 涨完涨了 20%，再把所有的 Doge 换成 BTC，这个时候，BTC 就从 1 个变成了 1.2 个，这就是 BTC 本位的含义。</p><p>从此以后，你将无视市场行情的波动，无惧牛熊，你眼里只有比特币的数量，是 1 个，还是 1.2 个，还是 0.8 个。至于 BTC 对于法币的价格，随便怎么变化，总之每隔 4 年翻一倍，跌了会涨，涨了还会涨，All Time High 反反复复。</p><p>要是用法币本位去炒币，十有九伤，大多会死得很惨。特指现货，合约千万别碰。</p><h3 id="4-挑-CMC-前-100-的买"><a href="#4-挑-CMC-前-100-的买" class="headerlink" title="4. 挑 CMC 前 100 的买"></a>4. 挑 CMC 前 100 的买</h3><p>尽可能把眼光聚焦在 CMC（Coin Market Cap）排行前 100 名的币上，挑这些里面的买。一方面是因为暴跌的概率小，100 名开外的没底。另一方面是生态支持差，没准什么时候钱包不支持了，转不了账带来很多麻烦。或者某个 X-20 币的合约地址变了，就很离谱，前段时间有一个 AI 板块下的，合约地址说变就变，而且原合约的 Dex pool 还在以 20% 的价格运行，合约地址切换后，价格变为了原来的 80% 左右。</p><h3 id="5-创始人的离开是去中心化的开始"><a href="#5-创始人的离开是去中心化的开始" class="headerlink" title="5. 创始人的离开是去中心化的开始"></a>5. 创始人的离开是去中心化的开始</h3><p>BTC 比较特殊，创始人从一开始就隐瞒身份，这是非常聪明的做法。也正因为如此，BTC 才可以被大肆炒作。为什么 BTC 上的资产类型很多，染色币、RGB++、Taproot Assets、铭文、符文，L2 资产还在打架。因为没有人能站出来给 Bitcoin 画一个 Roadmap，谁也不知道接下来应该怎么发展。</p><p>与之相比，ETH 的创始人还在全世界开会、演讲，给 Ethereum 画出了路线图，让 L2 有了整齐划一的技术方向。当 ETH 遭遇黑客攻击，创始人能够带领整个社区把攻击历史分叉掉，还能引领社区把共识机制从 PoW 转换为 PoS。如此大的影响力，说明 ETH 是中心化的。ETH 没有理由能通过 Howey 测试，在 SEC 的标准下，ETH 八九不离十被认定为证券。</p><p>如果一个币是你发的，你在那儿喊单，是不是很不合适？可如果一个币是去中心化的，你随便喊，就喜欢 Doge，就喜欢，怎么喊都行。</p><p>BSV 的 CW 也在今年打输了官司。社区里有人用这一点来安慰自己，说 CW 的离开是好事，BSV 会变成真正社区驱动的币。不管 BSV 前景如何，至少创始人的离开是一个重要的指标。</p><p>还有一个例子是 ETC 和 ETHW。这两个币都是宝二爷分叉出来的，很多人对他有成见，但是这两个币的市值、价格、TVL 摆在那儿，412 这一波，这两个币的抗跌能力有体现。虽然确实不敢买，从 ETH 分叉出来以后，技术上就没有进一步的更新了，GitHub 上活跃度很低，感觉很难长久下去，但价格上又很是让人感到疑惑。ETC 和 ETHW 其实是真正没有创始人而且是 PoW 的币。</p><p>另外一个现象是，自从以太坊将共识机制从 PoW 转为 PoS，ETH 对 BTC 的汇率就一直在下跌，从接近 0.1 到现在 0.05 左右。</p><h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><p>拿出 CMC 前 10 来简单对比一下：</p><ol><li>BTC：行业底线，市值占比 50%</li><li>ETH：开创了 EVM 和加密货币版 Defi 市场，有庞大的生态，市值占比 16%</li><li>USDT：使用范围最广的稳定币，美国国债储备</li><li>BNB：世界上最大的交易所平台币</li><li>SOL：PoH+DPoS 共识机制，中心化，依赖于少数排序器对交易排序后，才会交给验证者打包</li><li>USDC：最安全的稳定币，黄金储备</li><li>XRP：RPCA 共识机制</li><li>DOGE：PoW 共识，最大的 Meme 币，马斯克喜欢</li><li>TON：Telegram 发行的链</li><li>ADA：创始人有名气，使用 Haskell 开发，UTXO + PoS</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;1-BTC-是行业底线&quot;&gt;&lt;a href=&quot;#1-BTC-是行业底线&quot; class=&quot;headerlink&quot; title=&quot;1. BTC 是行业底线&quot;&gt;&lt;/a&gt;1. BTC 是行业底线&lt;/h3&gt;&lt;p&gt;有 Bitcoin，才有加密货币的整个行业。如果哪一天</summary>
        
      
    
    
    
    
    <category term="炒币" scheme="https://smallyu.net/tags/%E7%82%92%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>为什么说 PoW 比 PoS 更加去中心化</title>
    <link href="https://smallyu.net/2024/04/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4PoW%E6%AF%94PoS%E6%9B%B4%E5%8A%A0%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/"/>
    <id>https://smallyu.net/2024/04/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4PoW%E6%AF%94PoS%E6%9B%B4%E5%8A%A0%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/</id>
    <published>2024-04-13T16:50:00.000Z</published>
    <updated>2024-08-03T19:07:10.027Z</updated>
    
    <content type="html"><![CDATA[<p>想从准入门槛的角度对比一下 PoW 和 PoS。</p><p>我们经常描述一条链是 permissionless 还是 permissioned 的。其含义是成为出块节点，需要被授权还是不需要被授权。</p><p>PoW 是公认不需要被授权就可以挖矿的共识机制，只要你有一台计算机，就可以加入网络开始挖矿，只要你能计算出符合要求的哈希值，哪怕手算心算都可以，只要是正确的，你就拥有出块的权利，这个块中包含哪些交易由你来决定。当然能不能算的出来是另一回事。</p><p>BFT 是典型的需要被授权的共识机制。很多使用 BFT 类共识的项目，直接需要 CA 中心来签发证书，只有拥有证书的节点才可以在网络冲承担起挖矿的职责。而 CA 中心为什么要给你签发证书呢，完全是线下行为。成为出块节点的权限牢牢控制在 CA 中心手里。</p><p>PoS 存在一些争议。</p><p>SEC 曾经把 66 种加密货币定义为证券，包括 SOL、ADA 等市值比较高的币种。但其中没有包含 ETH，这一点给了很多人期望，也让 ETH 的 PoS 存在模棱两可的空间。</p><p>一个显著的事实是，PoS 是属于 permissioned 的共识机制。</p><p>在 PoS 中，节点往往会需要质押一定数量的 token 才能成为出块节点，而质押的那么多 token，就是 PoS 的门槛。</p><p>一个节点想成为出块节点，需要获得很多 token，而这些 token 从哪里来？要么来自项目的发行方，在创世阶段就分配出来到钱包里，要么后续从矿工手里买，因为矿工会增加 token 的供应量。</p><p>问题就在这里，设想一种极端的情况，如果所有持有 token 的人不愿意出售持有的 token，整个网络的控制权不就在他们手里了吗？不管他们是十个人还是十万个人，总之是一个圈子。而且在 PoS 的机制中，拥有越多 toekn 权力就越大，更是加剧 PoS 的中心化程度。</p><p>这个时候可能有疑问，以太坊如此成功，有上千万的持有者，成千的机构组织管理着上万个出块节点，难道还不够去中心化吗？</p><p>所以要区分两个概念，共识机制是去中心化的，和一条链是去中心化的，是两码事。</p><p>只要愿意，即使 BFT 类共识只能支持几十个节点的规模，如果这几十个节点分散在世界各地且有利益冲突的大财团手里，这条链仍然可以认为是去中心化的，因为几十个个利益相关方不可能有超过 2&#x2F;3 比例的数量合作。</p><p>同样的道理，以太坊只是做的去中心化了，它成为了一条去中心化的链，不代表 PoS 是去中心化的技术。</p><p>为什么很多项目方愿意选择 PoS 而不是 PoW 来发币？因为 PoW 太不可控了，被攻击的风险非常高。可以观察一下，目前存在的 PoW 链，几乎都是从比特币分叉而来，而且很少有新增。新出现的山寨币，多数源自以太坊的技术栈。</p><p>PoS 为什么可控？只要你不把创始阶段的钱分散出去，你就拥有整条链的控制权，PoS 让人更有安全感。分散出去也没事，只要整体比例可控，链就仍然在你的控制下。</p><p>那按照这么说，比特币的矿机资源不也被控制在少数生产商手里吗？只要他们不愿意出售矿机，比特币就始终被控制在一定范围内。也不全是，即使没有先进的矿机，也是能够参与挖矿的。落后的矿机堆积的多了，算力也可以很高。至少没有人有权力，剥夺你成为出块节点的资格。</p><p>与之相比，PoS 是不一样的，只要没有足够的钱，就没有成为出块节点的资格。如果 token 持有者不愿意出售，这种资格是你无论花费多少努力都无法获得的。PoS 本质上还是关起门来大家协商的共识机制，在有资格的节点中随机选一个出块，而且还得投票。</p><p>对了，如果存在一种 PoS，没有准入门槛呢？所有节点都是出块节点，每一轮随机选择一个节点负责出块。这样的机制免不了会受到女巫攻击，最终变为比拼节点数量的游戏。其实比拼节点数量也不是不行，节点数量最终也是硬件资源的体现。拥有更多硬件资源的节点有更大几率被选中。我倒是觉得这样的共识机制有进一步思考的空间，不过面临的现实问题也非常多，比如怎么通过 VRF 来选择下一个出块节点，以及如此庞大的出块节点数量，需要的网络带宽也许是不是现有技术能够承载的。另外，其实没有准入门槛就不叫 PoS 了。</p><p>15 年过去了，比特币从未被超越……</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;想从准入门槛的角度对比一下 PoW 和 PoS。&lt;/p&gt;
&lt;p&gt;我们经常描述一条链是 permissionless 还是 permissioned 的。其含义是成为出块节点，需要被授权还是不需要被授权。&lt;/p&gt;
&lt;p&gt;PoW</summary>
        
      
    
    
    
    
    <category term="共识机制" scheme="https://smallyu.net/tags/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>牛市对普通人来说意味着什么</title>
    <link href="https://smallyu.net/2024/03/13/%E7%89%9B%E5%B8%82%E5%AF%B9%E6%99%AE%E9%80%9A%E4%BA%BA%E6%9D%A5%E8%AF%B4%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88/"/>
    <id>https://smallyu.net/2024/03/13/%E7%89%9B%E5%B8%82%E5%AF%B9%E6%99%AE%E9%80%9A%E4%BA%BA%E6%9D%A5%E8%AF%B4%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88/</id>
    <published>2024-03-13T15:58:55.000Z</published>
    <updated>2024-08-03T19:07:10.114Z</updated>
    
    <content type="html"><![CDATA[<p>如果你曾经在市场低迷的时候，持有一些加密货币，那么牛市最大的意义，就是让你有限的资产获得了价值上的增长。</p><p>如果你是一位比特币信仰者，牛市最大的意义还在于，能够证明你的信仰是对的、几年前的眼光具有前瞻性，但也仅此而已，如果当时没有投入很多钱的话。</p><p>很多人看到现在 7W 的比特币眼红，后悔当年 3.8W 的时候没有多买点。但是放到 1 年前，3.8W 的比特币你敢买吗？是真不敢，谁知道当时还能跌到什么程度。如果我告诉你，一年后比特币会涨到 20W，你现在敢买吗？也不敢，是真的不敢。很简单的道理，没有人可以预测未来，只有在回顾历史的时候，人人都是股神。</p><p>最近比特币已经上了两次微博热搜，价格一涨人们就开始关注了。我也是眼睁睁看着 ETH 从 3400 掉到 1800，现在又涨到 4000。可是话说回来，这样的波动，能带来多大的改变呢，1W 块钱变 2W 块钱？好像也没太大意思。</p><p>牛市往往伴随着很多暴富故事。按照我的理解，有这么几种赚钱的方式：</p><ol><li><p>炒币，拿现货，价值投资。这样相对稳健，风险可控，但是收益也有限。敢投入多少资金，取决于你自己有多少可用于投资的资金。别看鲸鱼们动不动挣百万千万，他们真实拥有的资产，一定至少在用于投资的 5 倍以上。同样的，收益虽然绝对值多，但其实相对于他们的资产总量，也就那么回事。</p><p> 按照类似的比例，对普通人而言，收益也是有限的。敢把房子卖掉梭哈比特币的，那叫赌狗，那种做法，一般来说，挣多少钱就会赔多少钱，怎么挣来的就会怎么赔进去。除非能赚一波及时收手，可以能收住的也不是一般人，自制力已经超越人性。</p></li><li><p>开合约，加杠杆。这种类型的交易，拿个 10 块 20 块玩一玩就行了。如果不是玩，想赚钱，就不要碰，多少钱都得进去出不来，一般人玩不了这个。庄家做庄可以，如果你有能力控盘，但那个不是一般人。</p></li><li><p>发行 Meme 币。蹭当下的热度，什么火热蹭什么，AI 出新技术了就发个 AI 币，马斯克发推特有火箭的照片，就发个 ROCKET 币。总会有不长眼的玩家，为了热度瞎买，干这种事情，指不定一不小心就能赚很多很多钱。运气成分占很大一部分。另外是要有一定的运营和技术基础，得及时开交易的池子，懂得在社交媒体上推广，还得有一些美术能力，画个像样的 LOGO。</p><p> 哪怕不是 Meme 币，发个土狗币，只要有盘子，有人进来玩，有人愿意接盘，就能赚钱。但是技术、美术、运营各方面条件加起来，也需要点小小的成本。很多暴富的例子其实都是从土狗币来的。我亲眼见过有人干这个事情挣了钱的，但是我不太眼红这个，这种钱咱挣不了。</p></li><li><p>钓鱼网站。这个属于明确的违法行为了，需要黑客基础，以及相关经验，这个是不能考虑的。</p></li><li><p>撸空投。现在的空投猎人已经是一个小产业，批量参与早期项目，广撒网。这个也是随机性很强，需要运气，前段时间疯狂打铭文的，也有很多很多人花了手续费进去，最后啥也没捞到的。另外这里也有一个收益比例的问题，别看有些空投猎人一个项目上拿百万，他能够控制的用于投入的资产一定也非常多，这种机会给你，你也拿不出那么多钱啊，一般人也是没啥机会。我平时接触的空投性质的项目不多，也许是我消息闭塞，不懂这些人是怎么玩的。</p></li><li><p>DeFi。就是赚个收益，把钱压进质押平台，赚几十个点的利息。这种需要承担的是项目方 Rug 的风险，得看准项目方靠不靠谱。</p></li><li><p>MEV。每年几亿的市场，已经被很多有经验的厂商盯着了，想从里面挣钱可能得拼网速。</p></li><li><p>实打实地开发一个有技术含量的项目，作为核心开发成员，拿到初期分配的 token，然后等着 token 翻上几百倍。这种方式显然更安全，但是机会也非常少，尤其是现在的市场环境，几乎没有敢从头搞开发的，大多数项目是拼凑型的，类似于技术方案整合商。有能力在某一个技术方向有突出贡献的项目不但少，而且技术门槛也非常高，这个也不是普通人搞得了的。</p></li><li><p>正经工作，安心打工。像交易所的技术栈和互联网公司其实差别不是很大，办公地点不传统以及工资发 token 属于比较显著的特色。</p></li><li><p>挖矿。现在的挖矿应该不挣钱了。</p></li></ol><p>牛市有两种，一种是政策利好带来的价格增长，另一种是新技术引爆市场，吸引更多玩家进入圈子。目前的牛市属于前者，除了价格很疯狂，似乎没有太显著的技术出现，也没有现象级别的新玩意出现。除了价格在变，似乎什么都没变。或者说，可以认为目前还处于牛市早期，敢加仓的赶紧追高 :P</p><p>还有一点是，牛市会吸引更多资本的眼光，开始投入更多新的项目、新的公司，打工人的工作机会应该会变多一点。最近发现偶尔会出现一些名字小众的小公司，可能用人市场稍微好转了一点点？但是不出意外的话，猜测这些小公司，做的项目，也无非就是想象中的那几样……在哪儿打工不是打呢，身处裁员名单的人可能会觉得轻松点吧。</p><p>对于普通人而言，目前的牛市似乎真的没有意味着什么。今晚以太坊完成了坎昆升级，不知道能不能引起又一波 Layer 2 的风潮。我自己不太是以太坊信仰者，Layer 2 给人一种残缺的感觉，而现在的以太坊致力于推进 Layer 2 的发展。同样的，近期有一些公司在做比特币的 Layer 2 项目，同样不太看好，Bitcoin core 本身没兴趣搞扩容，甚至有能力直接让 BRC-20 一类的项目直接消失。</p><p>那么该信仰比特币吗，比特币好像跟普通人也没啥关系。期待有能代表信仰的项目出现。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;如果你曾经在市场低迷的时候，持有一些加密货币，那么牛市最大的意义，就是让你有限的资产获得了价值上的增长。&lt;/p&gt;
&lt;p&gt;如果你是一位比特币信仰者，牛市最大的意义还在于，能够证明你的信仰是对的、几年前的眼光具有前瞻性，但也仅此而已，如果当时没有投入很多钱的话。&lt;/p&gt;
&lt;p&gt;</summary>
        
      
    
    
    
    
    <category term="币圈" scheme="https://smallyu.net/tags/%E5%B8%81%E5%9C%88/"/>
    
  </entry>
  
  <entry>
    <title>最近半年的工作</title>
    <link href="https://smallyu.net/2024/02/17/%E6%9C%80%E8%BF%91%E5%8D%8A%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C/"/>
    <id>https://smallyu.net/2024/02/17/%E6%9C%80%E8%BF%91%E5%8D%8A%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C/</id>
    <published>2024-02-17T02:49:03.000Z</published>
    <updated>2025-06-16T00:22:16.169Z</updated>
    
    <content type="html"><![CDATA[<p>最近半年的工作主要是三件事。</p><h4 id="Abstract-Account-ERC-4337-项目的搭建"><a href="#Abstract-Account-ERC-4337-项目的搭建" class="headerlink" title="Abstract Account (ERC-4337) 项目的搭建"></a>Abstract Account (ERC-4337) 项目的搭建</h4><p>AA 账户实际上是一个智能合约，借助额外的 bundler 和 paymaster 实现零手续费、社交恢复等功能。ERC-4337 定义了一套规范，规范包括作为账户的合约支持哪些接口、bundler 如何与合约交互、paymaster 如何发挥作用等，目前各部分组件都有大概三到五种具体的项目实现，细节上有差异，但都是遵循了 ERC-4337 标准。</p><p>去年有一段时间抽象账户的概念挺火热，猜测是因为 Vitalik 提到过 Soulbound，项目方把 AA 账户作为灵魂绑定的解决方案来炒作了。像 ERC-4337 这种规范类的创新，一般来说不会带来太长远的影响，因为技术没变，只是使用方法变了，定义了一系列标准化的使用方法。短时间内用一用、解决燃眉之急也没什么不好。</p><h4 id="Op-Stack-的使用"><a href="#Op-Stack-的使用" class="headerlink" title="Op Stack 的使用"></a>Op Stack 的使用</h4><p>自从 Optimism 开源了 Op Stack 的一整套工具包，发行 Optimismtic 的 Layer 2 就变得容易起来，也就是去年挺火热的一键发链，Base、opBNB 等都是短时间就上线了。虽然 Optimism 的 Fault Proof 还不够完善，但哪怕是中心化一点，项目也是足够稳的，基于 Op Stack 完全能发行自己的网络。</p><p>我们把 AA 账户运行在 Layer 2 网络上，实际支撑了一场小型的游戏活动，虽然过程中遇到一些坎坷，但也算是积累了很有用的经验。从时间上，想非常深入这两种项目当然是不可能的，每个方向都能是一个细分领域。现在只是一个将将能用的状态。</p><p>不过有没有注意到一点，像 AA 账户、一键发链这些概念，都是阶段性的，去年火了今年就没人提了，今年更多提到的是比特币的 Layer 2、铭文、ERC-404 之类，热点总是在不断变化。</p><h4 id="搭建以太坊-PoS-网络"><a href="#搭建以太坊-PoS-网络" class="headerlink" title="搭建以太坊 PoS 网络"></a>搭建以太坊 PoS 网络</h4><p>自从 The Merge 以后，以太坊网络的搭建似乎更复杂了，虽然节省了挖矿的算力消耗，但是需要引入一堆复杂的 Validator 治理机制，来确保出块的有条不紊，PoS 就必然会涉及到如何成为验证者、哪些验证者有效等问题。原先的节点也拆分为两种类型，分成了执行层和共识层。相当于 PoS 解决了 PoW 出块不体面的问题，代价是需要另外一套复杂规则来完成这件事情。</p><p>以太坊是目前生态最丰富的链，执行层和共识层各有五、六种客户端，都实现了标准接口，但具体的体验不完全一样，尤其是性能方面，所以也花了不少时间试用每一种客户端。</p><p>以太坊最出色的应该是 EVM 而不是 PoS，能适配 EVM 已经是各种链的噱头之一。PoS 并不是以太坊的发明，Cardano 从一开始就使用了 PoS 而且保留了 UTXO 模型，所以偶尔会看到有人说 Bitcoin 和 Cardano 才是未来，与以太坊相比，单从共识机制上，Cardano 更像是 Bitcoin 的平替而不是以太坊。</p><p>比特币和以太坊属于两大阵营，比特币执着于加密货币，而以太坊重点探索加密货币在货币之外的应用价值。在每一个阵营下面，又有许许多多的 Altcoin 处于活跃状态。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近半年的工作主要是三件事。&lt;/p&gt;
&lt;h4 id=&quot;Abstract-Account-ERC-4337-项目的搭建&quot;&gt;&lt;a href=&quot;#Abstract-Account-ERC-4337-项目的搭建&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>也许事情没那么糟糕</title>
    <link href="https://smallyu.net/2023/11/29/%E4%B9%9F%E8%AE%B8%E4%BA%8B%E6%83%85%E6%B2%A1%E9%82%A3%E4%B9%88%E7%B3%9F%E7%B3%95/"/>
    <id>https://smallyu.net/2023/11/29/%E4%B9%9F%E8%AE%B8%E4%BA%8B%E6%83%85%E6%B2%A1%E9%82%A3%E4%B9%88%E7%B3%9F%E7%B3%95/</id>
    <published>2023-11-29T15:46:00.000Z</published>
    <updated>2024-08-03T19:07:10.029Z</updated>
    
    <content type="html"><![CDATA[<p>最近博客的更新频率出问题了，也许很多事情都出问题了。我也在反思到底出了什么问题，原因一定是多方面的。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>首先表面上的原因是没有时间，现在每天的有效工作时间平均在 7 小时左右，有效工作时间指去掉了休息时间甚至摸鱼的时间，真正工作过的应该明白这是一种怎么样的强度。</p><p>不管工作效率怎么样，时间是在这儿了。不过奇怪的是即使花了这么多时间，也感觉没做出什么事情，要真干点什么事也就拿出来说了，工作的进度甚至达不到我自己的预期，这种情况无非就两个原因：1.工作效率低，2.对工作进度期望高。</p><h4 id="工作效率低"><a href="#工作效率低" class="headerlink" title="工作效率低"></a>工作效率低</h4><p>我想两方面原因都有。有一些主观原因造成工作效率低的，比如试图用增加体力输入的方式解决 bug，已经不止一次遇到过，在 debug 的时候，觉得即使效率低一点，用笨办法，忍一忍就能把问题给解决了，问题只是暂时的，没想到一进去就出不来了，bug 的复杂程度超过想象。如果一开始就能花更多时间去理解，而不是无脑尝试，可能结果会好一点。</p><p>不过谁能想到仅仅只是把软件运行起来，就会有那么多坑，确实是超过理解了。最近一个新加入的同事也在尝试相关的技术，遇到一个匪夷所思的问题，我花了至少两小时的时间也没能解决，最后爱莫能助了。想起我之前遇到类似匪夷所思的问题，还有很多很多……可能真的是某种奇怪的道路，总得踩几个坑才能过去吧。</p><p>在心态上，我倒是能体谅和理解自己选择笨办法这样的做法。当时刚入职，首要的是能够完成工作任务，把问题解决掉，即使是在表面上，哪怕多花点时间呢，来不及把事情做的体面。另外其实生态内的软件也没那么靠谱，都是几十个 star 的小项目，需要把不同公司开发的、有一定个性化的项目拼接起来，按照自己的预期和逻辑运行。</p><h4 id="对工作进度期望高"><a href="#对工作进度期望高" class="headerlink" title="对工作进度期望高"></a>对工作进度期望高</h4><p>再是对工作进度期望高的问题。这里涉及到一个底层逻辑的变化。对于一个研发型的区块链公司来说，无论项目大小，工作的的逻辑是开发出某个细分技术领域的产品，争取能够做到头部，拉拢一批看好领域前景的粉丝，然后发币挣钱。具体到工作内容上，把开发环境运行起来只是第一步，后续的开发是工作重点。</p><p>而对于一个开发游戏为主的链游公司来说，思路是不一样的，在区块链方面更多是站在使用者的角度，希望能够稳定运行一个区块链网络，然后以某种形式将游戏和区块链的概念结合起来。具体到工作内容上，搭建环境、选择最正确可靠的方式运行一个网络，本身就是工作重点，即使涉及到少许的修改，大多也是对部署工具的整改，以符合自己使用的预期为主。</p><p>这就造成了对工作进度理解的偏差，由于原本的思维惯性，认为搭环境应该是最简单的一件事情，只是第一个步骤而已，都还没有进入正式工作的节奏，所以总觉得进度是延误的，希望尽可能加快进度，给自己也带来很多身心上的负担。但如果换个角度想，搭建环境就已经是工作重点了呢，运行和维护一个不出问题的网络环境，就是正式的工作内容了。这样去理解，事情会清晰很多。</p><p>再一个体验比如工作性质上的差异，区块链项目设想的目标群体是有一定技术背景的、能够理解技术特性的，无论是客户还是用户，所以要求项目要有差异化的东西，如果一个区块链项目实现出了和某知名项目一模一样的功能，甚至直接使用了某某开源代码，并且以此为卖点，其实是一件很奇怪的事情，这个项目本身就没有存在的必要了。相反，每一行代码都自己开发，是一个团队技术能力强的体现。</p><p>链游项目设想的目标群体是不一样的，面对的主要是游戏玩家和羊毛党，所以要求尽可能使用知名品牌的开源项目，最好是一行代码不改，直接运行，用户才比较容易相信你的区块链网络是没有问题的、让人放心的。如果一个技术人员想从链游项目的区块链网络上找区块链的技术特性，并且对此抱有某种信念，那也是挺离谱的事情。一个游戏玩家对游戏抱有信念，并且愿意参与到游戏的周边生态中，才是比较正常的逻辑，</p><h3 id="行业"><a href="#行业" class="headerlink" title="行业"></a>行业</h3><p>更深层次一点的原因是对行业前景失去信心。</p><p>美国是少数全面禁止加密货币的国家，不允许明面上的交易行为，更不能挖矿，发币是虽然没有立法但是明确违法的行为，金融相关的操作也是不可能的，整个行业都处于灰色地带，过去几年知名的区块链公司都逐渐消声匿迹。直观一点看，招聘软件上的职位全是几个月前就存在，或者以前还有现在没有了。行情差的可怕，而且短期内看不到好转的迹象。</p><p>在这样的情况下，难免会有一种无力感。比失败更可怕的是没有前进的机会，如果整个行业都不好，作为从业者又该怎么办呢，看不到希望，就没有昂扬向上的热情，对未来是倍感绝望的，低落的情绪下，也很难发掘有趣的东西。</p><p>以区块链为主导的行业，在美国已经几乎行不通了。</p><p>上面提到了不同类型公司在工作思维上的差异，也因此想到，也许链游还有生存空间呢，链游是以游戏为主导的行业，而正因为有运行区块链网络的需求，多少能给区块链留一点机会。虽然在工作性质上有比较大的差异，但正因为目标群体不同、盈利模式不同，才造成工作内容上的区别。灰色网站还有技术人员负责升级维护呢。</p><p>当然链游也有很多种类型，我相信以区块链为主导的游戏一定会死，但是在游戏上加入区块链元素的模式，就不好说了，关键是游戏公司要有向区块链靠拢的意愿。我不了解游戏行业，链游的情况也比较复杂，印象中游戏在美国是很难活下去的，还是得针对外部市场。总之这是一个不见得有很大希望但至少还不会让人感到绝望的方向，接下来可以多关注一下。</p><h3 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h3><p>最深层次的原因是整体的经济环境不好。</p><p>前两年全世界都处于经济下行的趋势，如今美国面临近几十年来最严重的经济衰退，极有可能在接下来几年进入经济大萧条的时代。所以不仅仅是区块链行业没有前景，尤其在美国，各行各业的情况都非常凄凉，人民看不到任何再次经济崛起的希望。</p><p>由于经常关注一些时政类节目，看到了太多政治体制上的不足，以及发生在社会中的悲惨事件，明白了美国是一个会让人感到人人自危的国家。各种信息和观点似乎都在宣告，美国政体变动频繁，美国社会即将进入动乱，有可能会面临真正的战争，在这样的危机下，个人要做好保护自己的准备。</p><p>不过时间一长，也难免会产生怀疑，真的有那么糟糕吗？就业环境确实差，一年比一年差。只是目测都感觉商场的人变少了，以前最繁华的商圈，也有大批商店关门了。最近商场的服装店开始普遍加顾客好友，像是要从实体拓展线上销售的样子。但仍然有很多企业在正常运作，歌手的演唱会在全世界开，电视节目不断出新，有些优秀的开源软件甚至诞生于爆发战争的几年，某些初创的科技公司也没说社会环境有变化就不干了。</p><p>最近了解到一个词叫 “政治抑郁”，顾名思义就是因为对社会环境不满而导致心情低落，对生活丧失信心的一种现象。在美国，任何社会事件，深挖一锄头，都能挖到执政党身上。但是美国的经济虽然难以再向上增长，由于体量巨大，也不可能在短时间内崩溃，溃而不崩是很多人的共识。也就是说，现在的社会环境让人感到难受，事实是确实会这样持续很多年。</p><p>历史上发生过几次大型的经济萧条，但都没有导致国家层面的颠覆，而是按部就班走过来了。在经济萧条的年代，尽管大多数行业处于衰败的状态，但也有少部分行业能正好顺应经济下行的趋势，显得欣欣向荣。比如很典型的例子是，当经济环境不好的时候，口红的销量会显著增加，因为口红是比较低成本的能够让女性感到愉悦的消费品。再比如当人们的消费能力普遍下降的时候，电影的销量会增加很多，因为看电影是比较省钱的娱乐活动。</p><p>更为显著的例子是，在日本 “失去的三十年” 期间，漫画产业和宅文化变得兴起，很多人愿意沉浸在文化作品中，逃避令人痛苦的现实生活，希望在虚拟的世界中找到快乐。也有一定被迫的因素，在整体经济低迷的环境下、年轻人就业困难，只能呆在家，给宅文化创造了有利的机会。也正是因为类似这样的一些原因，我开始关注和看好链游行业，也许能在其中发现新的机会。</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>分享几句听起来有道理的话。</p><p>“一个人赚不到认知以外的钱”，网上有很多钓鱼信息，尤其是加密货币领域的一些骗局，空投、MEV Bot、中奖之类，包括炒币、打铭文、挖矿，该买什么不能买什么，在这种时候就能意识到这句话是对的，如果实实在在上当受骗过，就会格外认为这句话有道理了。</p><p>“一个人的认知配得上他的苦难”，这是用来形容最近很火的一个悲剧事件主人公的一句话，有一对小夫妻在美国买到了烂尾楼，求助无门还被开发商打了。房地产突然暴雷是一方面，他们敢在一个不合时宜的时机买房是另一方面，他们的认知不足以让他们避开苦难，随之而来的痛苦只好自己承担了。这句话可以毫无违和感的应用到其他领域，工作不开心了，生活遇到困难了，都可以归咎于自己的认知不足。</p><p>“当老虎袭来的时候，你不需要跑的比老虎快，只需要跑的比其他人快”，这句话也挺有意思，所以要保持对时事的关注，不见得能从中获得多大的收益，要是能够避开一些大坑，也算是万幸了。</p><p>总之，要关心身边美好的人和事，世界没有想象中那么糟糕。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近博客的更新频率出问题了，也许很多事情都出问题了。我也在反思到底出了什么问题，原因一定是多方面的。&lt;/p&gt;
&lt;h3 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="生活" scheme="https://smallyu.net/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>如何健康地远程工作</title>
    <link href="https://smallyu.net/2023/10/10/%E5%A6%82%E4%BD%95%E5%81%A5%E5%BA%B7%E5%9C%B0%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C/"/>
    <id>https://smallyu.net/2023/10/10/%E5%A6%82%E4%BD%95%E5%81%A5%E5%BA%B7%E5%9C%B0%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C/</id>
    <published>2023-10-09T16:39:09.000Z</published>
    <updated>2024-08-03T19:07:10.091Z</updated>
    
    <content type="html"><![CDATA[<p>最近两个月在以远程工作的形式上班，当然远程工作并不是像很多人憧憬的那样，穿着泳衣在沙滩上晒太阳，谈笑之间上百万的交易就成交了。远程工作仅仅只是办公场地的不同，至于工作制度和工作流程，属于整个公司和团队的氛围和文化选择，暂时不讨论这方面的问题。</p><p>远程工作和现场办公相比，有好有坏。好的地方是能比较方便打造适合自己的工作环境，比如电脑桌的高度不太对，可以换一张让自己舒服的桌子，在公司的办公桌就不那么方便换掉了。</p><p>也有一些不好的地方，比如生活和工组场所相同导致生活和工作没有明确的边界感，像我之前有过比较离谱的情况，找 bug 没有头绪，心烦意乱，晚上已经躺下准备睡觉了，睡不着，半夜 1 点多起床 debug 了一小时代码，稍微有点进展后继续睡觉，第二天 8 点钟起床继续 debug，然后继续上一天班。一天下来状态会很差，这是非常非常不健康的行为，一定要想办法杜绝。</p><p>为了针对和解决不好的习惯，需要一些明确可行的规则来规范个人行为，主要是作为参与者，应该如何在远程工作的状态下，保持自己的身心健康。</p><h3 id="工作地点"><a href="#工作地点" class="headerlink" title="工作地点"></a>工作地点</h3><p>因为需要合适的工作环境，所以并不能太自由地选择工作地点，比如背上电脑到商场，在咖啡店呆一天，或者找个图书馆、自习室，都是不合适的，不但要花钱买咖啡，而且那种消费类型的座位都不适合久坐，工作中还有需要视频会议的时候，在公共场合的话也不方便。尤其是对于程序员来说，工作需要 27 寸的外接显示器，需要人体工学椅，也需要能让人专注的环境，还涉及到工作时长的问题，如果下班晚，咖啡店不会营业到那个时候，就有麻烦了。</p><p>WeWork 之类的共享办公室本身选择比较少，而且价格很高，一天要 100～300 块钱，长期用的话非常贵了，很多共享办公室也是不支持保存个人物品的，产业整体并不成熟，不是好的选择。</p><p>综合来看，工作地点只能是在自己的房间里。如果有属于自己的房子，有一间闲置的书房，或者空闲的房间，那么多余的房间就可以作为工作地点。</p><p>如果是租房子住，情况会稍微恶劣一点，一般租房子只会租一间自己的卧室，卧室的书桌就变成了工作的地方。如果专门为了远程工作租另外一间屋子，成本是比较高的。而且提供办公场所原本是公司的责任，在远程工作的形式下这个步骤就省略了，如果让这个成本转嫁到员工身上，也挺违反直觉的，所以自己另外租一间房子实在是没有道理。</p><p>还有一种方案是移居到低消费的城市，由于远程工作不受地点约束，降低消费的同时还能提高生活质量是可行的，但是这种方案仅适用于在当前城市没有任何朋友的情况，否则即使只为了某一个人，也没办法换城市。</p><h3 id="生活和工作要要有明确界限"><a href="#生活和工作要要有明确界限" class="headerlink" title="生活和工作要要有明确界限"></a>生活和工作要要有明确界限</h3><p>在现场工作的时候，生活和工作会有明显的区分，至少身处的环境是完全不一样的两个地方，一个是家，一个是公司，比较容易做出生活和工作的区分。可能会有一种感觉，即使工作再累，回到家也是该休息的时候。也许电脑放在公司就不会带回家，也许带回家不打开，也许工作环境在公司内网，你想在家工作都不行。总之种种原因，会给你一个明确的、生活时间和工作时间的区分。</p><p>但是如果生活和工作的场所相同，都在同一间屋子里，而且还是远程工作，就出问题了。</p><p>想象一下，公司在你的办公桌旁边放了一张床，还提供了所有生活所需的物品，然后你今后要住在公司的办公桌旁边，起床就能看见办公桌，是不是一件很可怕的事情。</p><p>再想象一下，你一整天的生活，起床之后一个小时就开始工作，工作结束之后两个小时就准备睡觉，在工作之外的时间你都仍然呆在房间里，是不是一种会让人发疯的场景。</p><p>远程工作最重要的一点，就是要保证生活和工作有明确的界限，为了达到这样的效果，简单列出几点行为：</p><ul><li>按时起床，预留出“通勤”时间</li><li>在原本应该通勤的时间里，出门散步，假装在通勤，绝对不可以睡懒觉</li><li>上班时间要穿好衣服和鞋子，不能穿居家的衣服或睡衣，必须是随时能够出门的状态</li><li>摆正外接摄像头的位置，表示进入上班时间</li><li>打开桌面上的时钟摆件，表示进入上班时间</li><li>打开窗户，表示进入上班时间</li><li>下班时间后，外出散步相当于通勤，结束工作</li><li>下班时间后，回到房间，拖一次地，让地板是湿的</li><li>下班时间后，不在电脑上进行工作相关的操作</li><li>……</li></ul><p>这些行为并不是具体的，也不一定是好的，只是举一些例子，重点是通过一系列物理上的行动，来给自己明确的信号，经过四五种操作以后，就进入上班时间了，经过另外四五种操作以后，就进入下班时间了。单纯光靠时间概念，到点了就上下班，很难让自己有明确的感受，也许本就非常自律的人可以做到，如果还做不到，就需要先依赖一些繁琐的行为，来给自己制造分界线。</p><h3 id="户外活动"><a href="#户外活动" class="headerlink" title="户外活动"></a>户外活动</h3><p>上面有提到，在本应该通勤的时间，要出门散步，假装在通勤。不只是为了保持和现场工作一样的生活节奏，更重要的是为了保持身体健康，确保有足够的时间在户外进行活动，哪怕是简单的散步，也一定好过整天待在家里。</p><p>有人认为远程工作的好处之一是可以省去通勤的时间，用来睡懒觉。这是非常错误的想法，多出来的时间不但不可以用来休息，还要刻意用来锻炼身体才对，天天在家里呆着估计也没人受得了。</p><h3 id="参加社交活动"><a href="#参加社交活动" class="headerlink" title="参加社交活动"></a>参加社交活动</h3><p>远程工作以后，我甚至开始怀疑和人类说话是一种生理需求。也许是认真工作的缘故，也许是工作日从早到晚都在同一个场所中，而且见不到活人、不能和人说话，感觉周末异常想出去玩，然后连续玩两天。</p><p>不在乎游戏好不好玩，只是想换个地方呆着，换换脑筋放松一下，见到不同的人，玩不同的游戏，干点和工作无关的事。</p><h3 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h3><p>现场办公的时候，可能时不时有人和你说句话、从你工位旁边走过、制造出什么声响，或者自己站起来去饮水机接一杯水、下楼买瓶饮料、去一趟洗手间等，各种各样的小事件，都会分散你的注意力，打断你的思考。这些事情也许会让你觉得麻烦，但是这些事情也能让你不要长时间专注于某件事情。</p><p>过于长时间的专注不是一件好事，会让头脑变得麻木迟钝，对于身体也是一种压力，会让人感觉腰酸背痛。人需要隔一段时间就站起来活动活动、舒展筋骨。</p><p>番茄工作法的大致含义是，每工作 25 分钟，休息 5 分钟，算作一个番茄时间。番茄工作法能有比较高的知名度，还是有一定道理的，这样的时间分配是一种不错的实践。</p><p>不要用 Stretchly 之类会在屏幕上弹窗的软件，使用体验并不好，它会直接打断你正在进行的工作，这很让人生气，你大概率会手动直接关掉它的弹窗。即使有些软件可以提前 30 秒通知你要弹窗了，体验也不会变好，手头上的事情如果在 30 秒内无法放下呢，本次 break time 就直接失效了。而且弹窗直接覆盖掉整个屏幕的方式，会让人有轻微的不安，担心是否有人给自己发消息，担心错过屏幕上的什么动态。</p><p>所以最好用会响起闹铃的倒计时。开始工作后计时，25 分钟后响起闹铃，如果不手动关闭闹铃，闹铃就会一直响下去。这种闹铃其实是一个很好的特性，如果你不放下手上的工作，闹铃就在不断提示你，是时候站起来放松一下了。当然自己也要自律，直到自己真的站起身，再动手把闹铃关掉。</p><p>但有时候开始工作会忘记启动倒计时，而且频繁手动开启倒计时也很麻烦，可以直接设定多个闹钟，在固定的时间响起，比如每个小时的 25 分和 55 分都响起一次。你不一样严格按照闹钟的时间进行工作，但至少闹钟会按时提醒你，该休息了。</p><p>实践证明，适度的休息放松不但不会耽误工作，而且会让工作效率变得更高。有些难题会一时想不到解决办法，往往在休息放松的时候，就有灵感了。</p><h3 id="仪式感"><a href="#仪式感" class="headerlink" title="仪式感"></a>仪式感</h3><p>作为内容的补充，偶然发现上面描述的种种行为，其实是在创造一种仪式感，上班需要仪式感，下班需要仪式感，很多时候仪式感是周围环境创造出来的，有时也可以自己主动去创造。生活需要仪式感。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近两个月在以远程工作的形式上班，当然远程工作并不是像很多人憧憬的那样，穿着泳衣在沙滩上晒太阳，谈笑之间上百万的交易就成交了。远程工作仅仅只是办公场地的不同，至于工作制度和工作流程，属于整个公司和团队的氛围和文化选择，暂时不讨论这方面的问题。&lt;/p&gt;
&lt;p&gt;远程工作和现场办</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="远程工作" scheme="https://smallyu.net/tags/%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>为什么比特币不用概率加密函数</title>
    <link href="https://smallyu.net/2023/10/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%8D%E7%94%A8%E6%A6%82%E7%8E%87%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0/"/>
    <id>https://smallyu.net/2023/10/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%8D%E7%94%A8%E6%A6%82%E7%8E%87%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0/</id>
    <published>2023-10-04T14:36:18.000Z</published>
    <updated>2024-08-03T19:07:10.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概率加密函数"><a href="#概率加密函数" class="headerlink" title="概率加密函数"></a>概率加密函数</h3><p>在常用的对称加密中，一个明文对应一个密文。有一种叫概率加密的方式，会在加密的过程中加入随机数，达到一个明文对应多个密文的效果，</p><ol><li>概率加密函数为什么很少用</li></ol><p>需要区分三个概念：加密、签名、哈希。概率加密函数属于对称加密的一种，而实际上区块链系统中很少用到加密，无论是对称加密还是非对称加密。比特币的白皮书中只提到过签名和哈希，签名是在发起交易的时候用来确认资产所有权的，哈希是在挖矿的时候确认出块权的，并没有提到关于加密的使用。</p><p>加密的应用场景比较少是主要原因，存储类项目可能会用到对文件的加密，但也属于用户行为，区块链系统本身不参与数据的加密保护。</p><p>概率加密函数想要替代签名和哈希更是不可能的事情，它本身就不具备那样的能力。</p><ol start="2"><li>概率加密函数的概率分布</li></ol><p>有概率就会有概率分布，比如正态分布。对于概率加密函数来说，均匀的概率分布是比较理想的，否则在概率分布已知的情况下，根据加密出的密文内容，攻击者有可能还原出明文内容，是很危险的。只有随机强度一致，攻击者才无从下手。</p><p>所以概率加密函数几乎没有选择，尽可能分布均匀是常见的做法。</p><h3 id="新式落地窗"><a href="#新式落地窗" class="headerlink" title="新式落地窗"></a>新式落地窗</h3><p>在一个优美和睦的动物森林里，不知怎的流行起了落地窗风格的房子，不仅透光良好，而且设计又美观又高级。小狐狸是有名的建筑师，能够建造出这种流行的带有很大落地窗的房子，森林里的小动物们纷纷找小狐狸盖房子。</p><p>小鹦鹉是森林里的百事通，消息灵通能说会道，同时也是河水霸主河马身边的军师，常常给河马出谋划策。河马听说了最近流行落地窗的房子，也想要盖一间。但是河马碍于比较高的地位和身份，不想直接套用大家都在用的设计，于是让小鹦鹉想想办法。</p><p>小鹦鹉到处打听，无意间听说了“玻璃纤维”这个词，据说是一种新出现的合成材料，不易碎、韧性特别好。小鹦鹉高兴极了，赶紧告诉河马，自己发现了一种新的建筑材料，这是史无前例的伟大创新，能够颠覆传统的建筑方式，用更高级的玻璃纤维来代替玻璃，简直能引领下一代房屋建筑的新潮流！</p><p>河马听了挺满意，出钱出力让小鹦鹉找人把房子盖出来，而且建造方案要保密！可不能让人知道了这么重要的创意。</p><p>小狐狸听说了这件事情，也挺好奇，自己盖房子这么多年，并不知道有什么新材料，小鹦鹉竟然能做出如此重大的创新。正好小鹦鹉的施工队招人，小狐狸欣然报名，参与到河马房子的施工大队中。</p><p>但是小狐狸一进去傻眼了，玻璃纤维不是玻璃，是不透光的呀！怎么能代替玻璃呢？如果坚持用玻璃纤维，这房子就没法住了。如果不用玻璃纤维，就只能用玻璃，那就没有创新了！</p><p>后来小狐狸离开了小鹦鹉的施工队……</p><h3 id="达克效应"><a href="#达克效应" class="headerlink" title="达克效应"></a>达克效应</h3><p>达克效应是认知偏差的一种，尤其用于描述低估或高估自己能力的现象。对于在某一个领域的专家，试图对领域之外的事情进行革命性创新的行为，可以归因于达克效应上，但是也存在细节上的差异，更贴切一点的描述是“超越领域的自信”，或者用更专业的心理学概念描述为“专业人士错觉”。</p><p>从心理学角度解释这种现象是有一定道理的，不过实际上造成这种现象的，还有一个重要的因素，就是存在一种无形的力量……</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;概率加密函数&quot;&gt;&lt;a href=&quot;#概率加密函数&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="加密" scheme="https://smallyu.net/tags/%E5%8A%A0%E5%AF%86/"/>
    
    <category term="心理" scheme="https://smallyu.net/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>程序员的 “服从权威” 心理</title>
    <link href="https://smallyu.net/2023/07/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E2%80%9C%E6%9C%8D%E4%BB%8E%E6%9D%83%E5%A8%81%E2%80%9D%E5%BF%83%E7%90%86/"/>
    <id>https://smallyu.net/2023/07/30/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E2%80%9C%E6%9C%8D%E4%BB%8E%E6%9D%83%E5%A8%81%E2%80%9D%E5%BF%83%E7%90%86/</id>
    <published>2023-07-30T14:35:34.000Z</published>
    <updated>2024-08-03T19:07:10.125Z</updated>
    
    <content type="html"><![CDATA[<p>最近经历了一件事情，就是入职一家初创公司，工作两周后主动离职。虽然只有短短两周但感觉过了很长时间，从中也学到或者意识到很多东西。离开的原因有很多，也涉及到比较具体的问题，我会继续反思和总结。今天想到一个有意思的话题，可以作为简单的切入点。当然有一些不方便说的内容我是不会说的 :P</p><p>我发现程序员群体普遍存在一种 “兽性”：谁技术好谁就厉害，谁技术好我就听谁的、我就服谁，我甚至会叫他大神、大佬，崇拜他，相信他，反之，要是技术不好的人当我的小组长、技术负责人、CTO，支配我的工作，我就不服他、不愿意听他的话。对于管理者来说，如果自己的能力不服众，事情推进起来也会格外艰难。</p><p>这个问题罗永浩在某个节目里也提到过，但是我不记得是在他的创业课播客还是什么访谈节目中了，特意找了一下没有找到，他的语录内容实在太多了。同时我也意识到，当有过加入初创公司的经历，观察到一些现象后，再回头去看他的 <a href="https://www.youtube.com/@zhuangyuanli/videos">创业课播客</a>，觉得他说的那些东西对创业公司还真挺有价值。</p><p>这种现象不止存在于程序员群体，在很多影视剧中都有类似的情节，比如在森林中，战斗力最强的狮子就是王，猴群中最能打的当猴王，或者在骁勇善战的原始人部落，以武力争高低，谁赢了听谁的。再比如西部牛仔比试枪法，胜利者获得某种地位和象征之类，等等。</p><p>这样的现象叫 “服从权威” 心理。分析一下权威这个词。权威其实不是一个负面的词语，虽然我们会看到一些言论说要打倒权威、不要盲目崇信权威，但其实那个语境中的权威是指非法获得的、德不配位的、迷惑群众的权威。“服从权威” 这个词中的权威，指群体中真正的强者。相信大多数人都不会反感真正的强者。</p><p>回到职场关系的问题，按照我粗浅的理解，可以简单把职场关系分为 “合作关系” 和 “从属关系”。</p><p>典型的合作关系比如公司与公司合作、公司的合伙人之间合作、两个部门负责人之间合作、两个小组长之间，等等，地位是平等的，在这种合作的情况下，能力可以是互补的，一方拥有 A 能力，另一方拥有 B 能力，合作起来才能发挥更大作用。很多公司都有 CEO、CTO、COO 的角色，角色背后是极其专业的能力。</p><p>从属关系也好理解，老板和员工之间，领导和下属之间，只要存在上下级关系都属于从属关系。一般来说，从属关系的能力是垂直的，比如 CTO 负责制定技术路线和战略方向，一线的技术人员根据规划完成具体的工作。这个属于角色分工的不同，但 CTO 和下属都是技术背景的人员。如果让公司的 COO 来领导技术团队，事情不就乱套了吗。</p><p>程序员的 “服从权威” 心理就存在于从属关系中，需要有纵向的比较，才能够产生所谓的 “权威”。合作关系中的能力都不同在一个标准下，就很难进行比较。</p><p>既然这种心理现象是普遍存在而且是客观存在的，那对于我们来说有什么启发呢？</p><p>对于非权威一方：明白自己要追求的权威是什么。比如工作中感受到了来自上级的压力，要清楚是有意义的压力还是无意义的压力，如果对方是自己领域的权威，就争取提高自己的能力，打败他，自己成为新的权威。如果对方不是自己领域的权威，只是凭借着某些原因在支配你，你应该奋起反抗，或者及时脱离苦海。</p><p>对于权威一方：明白自己权威的来源是什么。比如技术能力也是分层次的，假如自己有着高瞻远瞩的技术视野，而有些非权威的人拿着一分钟能打多少个字的数据来挑战你，你完全可以置之不理，不需要担心什么。</p><p>如果不具备权威的能力，又身处权威的位置，该怎么办呢？将从属关系变为合作关系，就不用担心有人来挑战权威、自己不能服众、有人不服气的问题了。因为 “服从权威” 的心理只存在于从属关系中而很少出现在合作关系中。简单来说，就是外行的领导要懂得放权。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近经历了一件事情，就是入职一家初创公司，工作两周后主动离职。虽然只有短短两周但感觉过了很长时间，从中也学到或者意识到很多东西。离开的原因有很多，也涉及到比较具体的问题，我会继续反思和总结。今天想到一个有意思的话题，可以作为简单的切入点。当然有一些不方便说的内容我是不会说的</summary>
        
      
    
    
    
    
    <category term="程序员" scheme="https://smallyu.net/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    <category term="心理" scheme="https://smallyu.net/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术面试题</title>
    <link href="https://smallyu.net/2023/07/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://smallyu.net/2023/07/12/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-07-11T17:01:09.000Z</published>
    <updated>2024-08-03T19:07:10.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近找工作也经历过很多次面试，这几次面试比较大的感受到一个共同的现象，就是和面试官聊不到一块儿，因为一般面试官也只是问他自己会的、关心的技术，很多东西我平时不怎么关心，而我简历上写的东西，对方也不怎么问。举例来说，我简历上有提到 State channels 相关的工作内容，我想但凡面试官知道 State channels 是什么，看到这部分简历，一定会多少问一句 HTLC 的原理是什么这种问题。然而我经历过的面试中，只有一家公司的面试官问到了这个，他们也确实是专业做区块链项目的团队。然后人家没要我。</p><p>虽然我面试了很多次，也不通过面试很多次，但是大多数情况是问我一些 web2 风格很重的技术细节，很少有人在区块链方面把我问住，尤其是我简历上提到的工作相关的内容，所以并没有太多挫败的感觉，更多时候是在抱怨，为什么那些人都在关心那些，我觉得不重要的东西，我能把某种需要两三个月才能搞明白的区块链技术理解清楚，半个小时就能看懂的某个关于编程语言的问题还能学不会吗？</p><p>所以就想到，如果我是面试官，面对在应聘区块链开发职位的求职者，我可能会提问哪些问题，然后根据这些问题来判断候选人的水平。这些问题是基本上通用的，其中一些问题能深入和扩展：</p><ol><li>比特币的共识是什么，UTXO 是怎么回事</li><li>以太坊的共识是什么，如何选定出块节点的</li><li>你还知道哪些链，这些链有什么技术特点</li><li>PBFT 的流程是什么，国内有哪些联盟链</li><li>PBFT 有哪些变体，哪些链在用</li><li>Layer 2 有哪几种技术类型</li><li>State channels 的原理是什么，Rollups 的原理是什么</li><li>账户钱包是怎么生成的，keystore 文件是什么</li><li>存储类区块链有哪些，其中的难点是什么</li><li>Solidity 语言有哪些限制，和 Go 语言的不同</li><li>面向对象了解吗，写过 Java 吗</li><li>区块链里有随机数吗，怎么使用</li><li>合约交易是怎么经过虚拟机处理的，怎么增加对另一种语言的支持</li><li>日蚀攻击和女巫攻击分别是什么</li><li>了解过资产跨链吗，大概是什么流程</li></ol><p>这些问题没有明确的先后顺序，也比较浅，抛砖引玉吧。突然想起来我面试还被问到过，区块链里面的区块是怎么连接起来的？答案是下一个区块会存上一个区块的块哈希，这种问题就属于没入门系列，还是问点门里面的问题吧。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近找工作也经历过很多次面试，这几次面试比较大的感受到一个共同的现象，就是和面试官聊不到一块儿，因为一般面试官也只是问他自己会的、关心的技术，很多东西我平时不怎么关心，而我简历上写的东西，对方也不怎么问。举例来说，我简历上有提到 State channels</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="面试题" scheme="https://smallyu.net/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>如何区分公有链和联盟链</title>
    <link href="https://smallyu.net/2023/07/12/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E5%85%AC%E6%9C%89%E9%93%BE%E5%92%8C%E8%81%94%E7%9B%9F%E9%93%BE/"/>
    <id>https://smallyu.net/2023/07/12/%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E5%85%AC%E6%9C%89%E9%93%BE%E5%92%8C%E8%81%94%E7%9B%9F%E9%93%BE/</id>
    <published>2023-07-11T17:00:58.000Z</published>
    <updated>2024-08-03T19:07:10.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简短版"><a href="#简短版" class="headerlink" title="简短版"></a>简短版</h3><p>发币的就是公链，不发币的就是联盟链。</p><h3 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h3><p>因为我经常否定联盟链，就自然而然产生一个问题：到底什么是联盟链？公链和联盟链的根本区别是什么，分界线在哪儿？本以为这是一个简单的问题，但是仔细想想又没那么简单，不是特别容易去下一个明确的定义，</p><p>简单来说，公开给所有人访问使用的区块链就是公链，在一个小范围内部使用的区块链就是联盟链。这种区别就像是互联网和局域网的区别。但是如果把一条联盟链开放出来，给所有人使用了，它就变成公链了吗？如果这条链使用原始版本的 PBFT 作为共识机制，那它仍然还是联盟链，始终都是联盟链。公链和联盟链的区分，不能仅仅根据使用人群范围的大小。</p><p>再比如存在一个主观的问题，什么是所有人？多大范围算是所有人？如果一共有 100 个人，100 个人就是所有人，那么 99 个人算不算？在现实生活中，似乎也算，99 个人在使用的链，不可能说它是一条联盟链。那 80 个人算不算？好像也算，已经是大多数人了，比起 20 个人的小部分，80 个人不至于认为是一个联盟。60 个人呢？已经超过半数了，能代表所有人吗？</p><p>所以如何判断一条链是公链还是联盟链？经过一段时间的思考，从技术特点的角度去考量，我认为要同时满足这三个条件，才算是公链：</p><ol><li>节点之间网络互联互通</li><li>每个节点平等地拥有成为出块节点的机会</li><li>成为出块节点的门槛是合理的</li></ol><p>你可能注意到，在简短版中，把有没有加密货币作为了区分公链和联盟链的唯一指标，而在详细版里却没有提加密货币。主要是判断的维度不一样，有没有发币是整个系统体现出来的使用方式，上面列举的三个条件要更通用一点，是技术方面的特性。满足三个条件而没有发币仍然能认为是公有链，只不过加密货币对于矿工是很重要的激励手段，是整个系统的一部分，一般是不可或缺的，项目方通常会把加密货币设计进去。</p><h4 id="节点之间网络互联互通"><a href="#节点之间网络互联互通" class="headerlink" title="节点之间网络互联互通"></a>节点之间网络互联互通</h4><p>这一点要求节点不能从网络层面设置访问权限，任何人都能通过互联网访问节点。如果节点没有部署在公网上，而是运行在局域网中，这个节点就不属于公链的节点。如果节点部署在公网上，但是仅限指定的 IP 访问和使用，那这个节点就属于设置了访问权限，是不够开放的行为，如果所有节点都存在类似的设置，整条链就不算是公链。</p><h4 id="每个节点平等地拥有成为出块节点的机会"><a href="#每个节点平等地拥有成为出块节点的机会" class="headerlink" title="每个节点平等地拥有成为出块节点的机会"></a>每个节点平等地拥有成为出块节点的机会</h4><p>比如 PoW，只要算力足够，就会被认可成为出块节点。比如 PoS，只要质押 32 ETH，就有机会成为出块节点。这种属于典型的公链的例子。像是原始版本的 PBFT，出块节点是固定的，还不能更换，就属于联盟链。有一些链在 PBFT 的基础上加入了随机更换共识组的功能，每隔一段时间就会随机选择一些节点作为共识节点负责出块，包含这种设计的区块链是属于公链的，不过项目方需要考量这样的做法是否安全，容错能力怎么样，是否面临女巫攻击的风险。</p><h4 id="成为出块节点的门槛是合理的"><a href="#成为出块节点的门槛是合理的" class="headerlink" title="成为出块节点的门槛是合理的"></a>成为出块节点的门槛是合理的</h4><p>合理是一种主观的感受，因为不好量化，需要项目在设计上去权衡。比如 PoW，获得足够算力去出块是有很高成本的，这个成本就是门槛，如果门槛太低，所有节点都轻易出块，网络会乱，如果门槛太高，没有人能达到，出不了块，都是不合适的。这个门槛需要一个折中的、合适的位置。再比如有些 PBFT 联盟链中，成为出块节点需要 CA 发行的证书，而这个 CA 是由项目方控制的，需要线下通过一系列认证，才能够加入联盟获得证书，这种属于典型的联盟链。</p><h3 id="为什么喜欢区块链"><a href="#为什么喜欢区块链" class="headerlink" title="为什么喜欢区块链"></a>为什么喜欢区块链</h3><p>技术属性上，区块链有一种反叛的精神在里面，区块链主张去中心化的技术理念，自成一套体系，既然你中心化的机构靠不住，那我们就各自为营，我们首先相信自己，其次才相信别人，在这样的模式下，历史记录的准确性非常高。目前能在全世界范围达成数据一致的系统，也就只有区块链才能做到。</p><p>资产属性上，加密货币抵抗地缘政治变化的能力非常强，你可以轻易地持有和世界货币锚定的货币资产，不会因为世界局部的货币价值波动而受到影响。</p><h3 id="为什么不喜欢联盟链"><a href="#为什么不喜欢联盟链" class="headerlink" title="为什么不喜欢联盟链"></a>为什么不喜欢联盟链</h3><p>国内的联盟链项目，很多是政府机构搞信息化建设，最后都是政府出钱。假如雄安新区一个信息平台的项目 2000 W，其中会包含各种技术领域像人工智能、大数据、物联网，区块链是其中一项，具体到这一个区块链类目上，可能 300 W，这 300 W 也不是一般小公司能拿下的，至少得有点强硬的关系，比如外包大厂。然后这个区块链类目又包含很多小的部分，比如某个部门的数据管理平台，要接入区块链进行数据上链，如果这家外包大厂不具备区块链的研发能力，就会从 300 W 中分出 30 W，找一家专门开发区块链的公司，把这部分功能完成了。最终开发联盟链的公司，挣个辛苦钱，同时指望一年能多做几个项目，多挣点钱。</p><p>这种项目大都会走招投标的流程，可以想象一下，光是能不能把项目揽下来就会牵扯到多方的利益纠缠，投标的时候人家会给你公司的整体实力打分，包括申请过多少专利、企业过往的营收能力之类。而且这种项目和区块链的理念没有半点关系，换一个名头比如 5G 技术，还是一模一样的项目流程，招标投标做项目交付，只是其中用到的具体技术不一样而已。所以我说联盟链不是真正的区块链，联盟链是在用金锄头锄地。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;简短版&quot;&gt;&lt;a href=&quot;#简短版&quot; class=&quot;headerlink&quot; title=&quot;简短版&quot;&gt;&lt;/a&gt;简短版&lt;/h3&gt;&lt;p&gt;发币的就是公链，不发币的就是联盟链。&lt;/p&gt;
&lt;h3 id=&quot;详细版&quot;&gt;&lt;a href=&quot;#详细版&quot;</summary>
        
      
    
    
    
    
    <category term="公有链" scheme="https://smallyu.net/tags/%E5%85%AC%E6%9C%89%E9%93%BE/"/>
    
    <category term="联盟链" scheme="https://smallyu.net/tags/%E8%81%94%E7%9B%9F%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>对 Layer 2 项目创业想法的回复</title>
    <link href="https://smallyu.net/2023/07/08/%E5%AF%B9-Layer-2-%E9%A1%B9%E7%9B%AE%E5%88%9B%E4%B8%9A%E6%83%B3%E6%B3%95%E7%9A%84%E5%9B%9E%E5%A4%8D/"/>
    <id>https://smallyu.net/2023/07/08/%E5%AF%B9-Layer-2-%E9%A1%B9%E7%9B%AE%E5%88%9B%E4%B8%9A%E6%83%B3%E6%B3%95%E7%9A%84%E5%9B%9E%E5%A4%8D/</id>
    <published>2023-07-08T05:25:31.000Z</published>
    <updated>2024-08-03T19:07:10.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说明：没有任何不尊重来信的意思，邮件中对于 L2 的观点带给我很多启发，因为其中有一些内容和我认知不完全一致，我认真理解和思考了来信的含义，所以想借此表达一下我对 L2 的看法。博客中 L2 相关的内容比较少，就放到博客上来了，这里只是单纯作为技术问题讨论一下</p></blockquote><h3 id="来信"><a href="#来信" class="headerlink" title="来信"></a>来信</h3><pre><code>你好，还在找工作吗？Jul 6, 2023, 5:39 PM (2 days ago)to mewangyu 你好！无意间看到了你的博客，也不知道这个邮箱能不能收到。今年开始 L2 开始火起来了。各种大公司，只要有点钱的，都开始怼 L2从 L2beat 来看，还有不少 L2 即将上线 https://l2beat.com/scaling/tvl#upcoming也不清楚是不是天下 L2 一大抄。但总感觉目前的 L2 技术都差不多来源于几家头部公司的开源代码。如果真的是这样，是不是就可以意味着阿猫阿狗都可以自己 Fork 出一个版本来了呢？如果是的话，那么我们就是那个&quot;阿猫阿狗&quot; :)我们创业团队挺有兴趣蹭蹭 L2 公链&quot;热潮&quot;的，感觉您在这块应该是一把好手。如果你也有兴趣，我们可以进一步聊聊合作方式？我大概的想法是远程、由你自由主导的链演化路线PS: 我的 telegram 是 @****** 欢迎在线联系我。</code></pre><h3 id="回复"><a href="#回复" class="headerlink" title="回复"></a>回复</h3><p>您好！</p><p>非常高兴收到您的邮件，也很抱歉没有太及时回复。</p><p>我尝试认真理解您来信的内容，对于其中提到一些关于 L2 的观点，我想描述一下我的理解。</p><h4 id="1-“技术类型”-和-“项目”-的区别"><a href="#1-“技术类型”-和-“项目”-的区别" class="headerlink" title="1. “技术类型” 和 “项目” 的区别"></a>1. “技术类型” 和 “项目” 的区别</h4><p>Layer 2 有 4 种技术类型，State channels、Sidechains、Optimistic rollups、ZK rollups，所有的项目都属于这 4 种类型内，在即将上线的项目中，大多数是 rollups 类型，但是没有信息他们的代码是不是 fork 已有项目的。</p><img src="a.png" width="50%" /><p>具体项目的话是有这 4 个：</p><img src="b.png" width="30%" /><p>但是从已上线的项目列表看，即使是 fork 相同的项目，他们的应用场景也是有很大差异、高度定制化的:</p><img src="c.png" width="50%" /><h4 id="2-现有的项目不是简单的-fork"><a href="#2-现有的项目不是简单的-fork" class="headerlink" title="2. 现有的项目不是简单的 fork"></a>2. 现有的项目不是简单的 fork</h4><p>以 zkSync 为例，在列表上能看到 3 个项目有这个标识：</p><img src="d.png" width="30%" /><p>分别是 zkSync Era、zkSync Lite 和 ZKSpace，其中 zkSync Era 和 zkSync Lite 是同一家。</p><p>再具体看 ZKSpace，他确实是用了 zkSync 的合约，但并不是单纯的 fork 整个项目，而是使用了 zkSync 的合约代码，在其基础上做一些修改适配自己的业务。同时，ZKSpace 也使用了其他项目的代码。</p><img src="e.png" width="50%" /><p>从 ZKSpace（以前是 ZKSwap）的白皮书能看到，ZKSpace 想做的事情是 Layer 2 上的 Uniswap，包含了 AMM 的功能，也就是交易所市商的那些东西。</p><img src="f.png" width="60%" /><p>zkSync 是一个通用的 Layer 2 项目，本身不提供太具体的功能，ZKSpace 使用了一些 zkSync 的合约代码，在那个基础上做一些事情，而且是业务强相关、有具体目标的事情。他并不和 zkSync 本身抢市场。</p><p>再看比如有 OP 标的项目，也就是基于 OP 项目 fork 的。</p><ul><li>Arbitrum 一开始是 fork OP 的，然后改了一些经济模型方面的东西，后来做大了又重构项目。而且 arb 的运营能力很强，举办过几次奥德赛。</li><li>Boba 的特点是 withdraw 余额不需要等 7 天，马上提取，另外通过他自己叫做混合计算的技术，把 web2 的网页能力带到区块链上。</li><li>Zora 是一个专做 NFT 领域的 layer2.</li><li>Mantle 提供了去中心化的序列器之类。</li></ul><p>总的来说，这些项目都是有具体的目的，想要实现某一种功能，然后把现成的代码拿过来，复用一下，重点可能比较在于这些项目的目标，也就是想干什么样的事情。他们都是结合了自己的业务场景，而不是简单的 fork 下来就能运行。</p><h4 id="3-L2-不是链"><a href="#3-L2-不是链" class="headerlink" title="3. L2 不是链"></a>3. L2 不是链</h4><p>目前的 rollups 项目都是中心化的，本身不是一条链，没有共识之类的东西，主要是项目方在运营。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>所以关于您提到的想做 L2 方向的项目，我的意思是，从您的描述来看，可能没有您想的那么简单，其中会很涉及到一些具体问题。也许需要应用场景上的创新，和 defi 或者 gamefi 场景结合之类，或者技术特点上的创新，能够改善某种痛点。</p><p>我也很想蹭热点，也希望能有合适的创业机会，我现在也是在找工作，不过从我的角度看还是挺迷茫的，我本身没有太直接的想法，一个项目该往什么样的方向做之类，我觉得那些都涉及到挺市场化的东西，需要很大的资本力量。</p><p>不知道您具体是什么样的想法。由于内容比较多，就以邮件的方式回复了。有问题您随时联系我。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>有一些在回复中没有提到的话题，顺便展开聊一聊。</p><p>首先是 Layer 2 为什么火？因为 Vitalik 在最近的博客中频繁提到 zkEVM，比如在文章 <a href="https://vitalik.ca/general/2021/12/06/endgame.html">Endgame</a> 中，把支持 ZK-rollup 认为是以太坊未来的重要工作之一。有些问题没办法在 Layer 1 直接解决，就希望通过 Layer 2 解决。有 Vitalik 这样的备受关注的开发者引领生态上的技术方向，Layer 2 就成为了以太坊的发展热点。</p><p>Vitalik 比较看好 ZK-SNARKs 类的 zkEVM，从技术角度，ZK-rollups 将是所谓的 Endgame。但是 ZK 的开发成本非常高，目前还处于研究开发，小体量的资本玩不起，太贵了。</p><p>Dapp-learning 社区在 Youtube 上有一个 Scroll 的技术分享<a href="https://www.youtube.com/watch?v=SEp5SFaYQHY">视频</a>，内容挺好的。Scroll 的整个技术团队都在国内，从视频的讲解中感觉似乎 Scroll 的技术方案是有一些暴力成分在里面的，就是既然写 circuits 不容易，那就把某一类型的 circuits 结果作为一张表，用的时候查表，然后去不断扩充出各种表以支持整个 EVM。这是 Scroll 对比了各 ZK 项目实现 EVM 完备的方式：</p><img src="g.png" width="80%" /><p>Vitalik 的博客文章 <a href="https://vitalik.ca/general/2022/08/04/zkevm.html">The different types of ZK-EVMs</a> 也提到了对 zkEVM 的分类。不管怎么说，Layer 2 的火热应该是指基于 ZK-rollup 的项目打得火热。</p><p>Optimistic rollups 更像是 L2 的一种过渡方案，相信 ZK 出来后 OP 类的项目都会受到打击，因为 OP 并不依赖于加密技术的可靠性，从命名上就能看出来他是乐观主义，先认为一笔交易没有问题，然后给 7 天的挑战期，如果交易有问题，需要用户自主发起挑战，或者由第三方验证者来完整挑战，有很大程度的人为干预在里面。</p><p>再一个是 L2 项目中心化的问题。除了 Sidechains 的项目，L2 一定是中心化的，因为共识交给 L1 去做，L2 本身不管这个，从动机上，L2 起到的作用是快速地把交易收集起来打包发到 L1 上，一笔交易最终的信任是落到 L1 上的，用户相信的不是 L2 而是 L1 上的交易记录，所以 L2 不需要去中心化，用户不需要，项目方也没有必要。L2 一般是有项目方在发行和运营，用户信任项目的技术方案，才愿意到项目上玩，把资产质押进去。</p><p>还有 L2 使用体验的问题，目前很少有用户会把 OP 或者 ARB 作为低成本资产转移的方案，宁愿用 BNB 或者 TRX 来实现匿名场景的支付，使用比较多的还是治理 token 的投资或者 DApp 项目形式的交互。OP 赎回资产需要 7 天的等待期这一点就挺难用的，L2 链之间的资产转移也是个问题，比如在 OP 上的 USDT 能不能转移到 ARB 上，不然我用 OP，另一个人用 ARB，我们就没法交易了。在这个方面还有很大的提升空间。</p><p>L2 是很有前景的技术方向，期待它能带给我们更好的使用体验，至于其中有没有低成本的获利空间，就不太清楚了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;说明：没有任何不尊重来信的意思，邮件中对于 L2 的观点带给我很多启发，因为其中有一些内容和我认知不完全一致，我认真理解和思考了来信的含义，所以想借此表达一下我对 L2 的看法。博客中 L2</summary>
        
      
    
    
    
    
    <category term="Layer2" scheme="https://smallyu.net/tags/Layer2/"/>
    
    <category term="创业" scheme="https://smallyu.net/tags/%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>对区块链共识机制的理解</title>
    <link href="https://smallyu.net/2023/07/01/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://smallyu.net/2023/07/01/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2023-07-01T09:19:29.000Z</published>
    <updated>2024-08-03T19:07:10.104Z</updated>
    
    <content type="html"><![CDATA[<p>共识机制的作用，是让大多数节点的数据能够保持一致。共识机制有两种大的类型，一种是 PoW 风格的，一种是 PBFT 风格的。几乎所有的共识都在这两种风格之下。</p><p>可以从头思考一下，如果是一个人类的群体，怎么样才能让大多数人保持一致呢？一种方法是选出一个领袖，大家都听领袖的意见，再一种方法是大家一起商量进行决策，达成统一的意见。</p><p>对于第一种方法，问题在于如何选出领袖，依据什么样的标准选出，或者怎么样的人才能够成为领袖。对于第二种方法，问题在于哪些人可以参与商量，如何做出决策。</p><p>先看第一种方法，流程上主要有 3 个步骤：</p><ol><li>通过某种方式选出领袖</li><li>所有人在时间单位内都听领袖的</li><li>所有人在时间单位内将会达成一致</li></ol><p>PoW 的过程就是这样：</p><ol><li>解出哈希难题的矿工成为出块节点</li><li>所有节点接收并验证矿工的块</li><li>所有节点的块数据达成一致</li></ol><p>在这种 PoW 风格的共识过程中，最大的变数是第 1 步，也就是如何选出出块的节点，也因此有了很多 PoW 共识的变种。</p><ul><li><p>Proof of Stake (PoS)：以太坊在使用的共识机制，币种名称为 ETH。质押一定量资产的节点会随机成为出块节点，随机的过程由在信标链上运行 VRF 函数完成，并且质押的资产越多，成为出块节点的可能性越大。</p></li><li><p>Proof of Authority (PoA)：以太坊测试网支持的共识机制。在网络的初始化阶段就已经确定哪些节点可以出块，之后按照顺序依次出块。确认验证者的过程是线下完成的，网络本身不具备对验证节点的纠正能力，比较中心化的一种共识。</p></li><li><p>Proof of Importance (PoI)：Nem 在使用的共识机制，币种名称为 XEM。制定了一些给节点打分的机制，在多少天内交易多少次、交易额度是多少之类，以根据分数对节点进行排名，分数高于指定标准的节点，随机成为出块节点。</p></li><li><p>Proof os Elapsed Time (PoET)：Hyperledger Sawtooth 项目使用的共识机制，是英特尔开发的一个项目。每个节点随机生成一个等待时间，等待时间最短的节点成为出块节点。出块节点需要提供一个最短时间的证明，这个证明和硬件设备相结合，达到无法伪造的效果。</p></li><li><p>Proof of Burn (PoB)：Slimcoin 在使用的共识机制，币种名称为 SLM。节点通过销毁资产的交易获得销毁哈希，销毁哈希的计算包含了销毁的金额以及节点在一段时间内销毁的频率等信息，然后系统对每个节点提交的哈希值进行比较，哈希值最小的节点将进行本轮的出块。</p></li><li><p>Proof of Capacity (PoC)：Burst 在使用的共识机制，币种名称为 Burst。节点使用 hard-to-pebble graph 的数据结构，在磁盘上进行文件的写入，这个步骤需要足够多的磁盘空间，写入完成后节点随机打开文件的某个位置，计算对应的哈希值，直到找到满足要求的哈希值，节点就可以进行出块。</p></li><li><p>Proof of History (PoH)：Solana 在使用的共识机制，币种名称为 SOL。这种共识机制的创新之处在于，每一笔交易或者其他链上的操作，都会对应一个哈希值，然后 PoH 生成器生成块，这个块由一系列连续的哈希值，也就是一系列链上操作组成，从而保证链上数据的一致。这里的 PoH 生成器就是出块节点，PoH 生成器的选择标准则是质押金额最多的节点。</p></li></ul><p>这些是 PoW 风格共识的例子，可以看出它们在想方设法改变选择出块节点的方式，但不管具体使用怎么样的机制，这些区块链都符合 3 个步骤的流程。</p><p>再看第二种方法，流程上也是 3 个步骤：</p><ol><li>通过某种方式选出参与决策的人</li><li>参与决策者进行交流、达成一致</li><li>其余所有人都依照决策结果，达成一致</li></ol><p>PBFT 的过程类似这样：</p><ol><li>从所有节点中选出共识节点，然后共识节点依次作为提案节点</li><li>参与共识的节点经过两轮投票，对提案内容进行决策</li><li>共识节点达成一致，其余节点跟风达成一致</li></ol><p>可以看出和第一种方法相比，由单一的领袖变为了多个决策者。在这种 PBFT 风格的共识过程中，最大的变数也是第 1 步，如何从所有节点中选出共识节点，以及共识节点成为提案节点的顺序。这是一些变种：</p><ul><li><p>Delegated Byzantine Fault Talerance (DBFT)：Neo 在使用的共识机制，币种名称为 NEO。每个持有资产的节点都可以进行共识节点的选举，将自己的资产委托给共识节点。拥有委托资产的共识节点进行排名，前几名将依次作为提案节点。</p></li><li><p>Federated Byzantine Agreement (FBA)：Stellar 在使用的共识机制，币种名称为 Stellar。网络中的所有节点都是共识节点，都可以参与两轮投票。为了减少网络的拥堵，节点也可以委托自己的投票权给另一个节点，使用切片或者子网络的方式提高共识效率。</p></li><li><p>HoneyBadgerBFT：一种支持完全异步网络的 BFT 类共识，不依赖于同步的时间顺序，这是 PBFT 不具备的能力。不过异步网络的共识效率相对低一点。</p></li><li><p>HotStuff：一个允许部分网络异步的 BFT 类共识。它的特点是，网络中可以同时存在多个提案，提案节点将选择最好的一个提案，进行后续的流程。这样的方式相当于产生提案的过程是并行进行的，提高了整个共识的效率。</p></li><li><p>VBFT：Ontology 在使用的共识，币种是 ONT。使用 VRF 随机函数进行提案节点的选择，每一轮的提案节点都是随机、不可预测的。</p></li></ul><p>总体而言，PoW 风格和 PBFT 风格都是通过某种方式，筛选出最终能达成一致的内容，但是在选择内容的方式上存在根本区别。PoW 中其余节点将无条件接受来源的块，只要来源的块是符合某种条件的。而 PBFT 中，其余节点先收到块的内容，然后对这个块的去留进行决策，在接受块之前有一个投票的过程。</p><p>现在也有一些创新类型的共识出现，或者是结合多种共识的混合共识等形式，不管是对节点进行信誉评估、根据历史交易质量之类打分，还是根据手机、物联网等硬件设备进行数据的验证，还是对 PBFT 做某个阶段上并行、容错能力和网络效率之类的优化，共识机制终究还是在 PoW 风格和 PBFT 风格的体系之下。</p><p>因此你可以大胆的说，共识机制也就这么回事，只是在具体的设计和实现上有差异而已。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;共识机制的作用，是让大多数节点的数据能够保持一致。共识机制有两种大的类型，一种是 PoW 风格的，一种是 PBFT</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="共识机制" scheme="https://smallyu.net/tags/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>没找到工作</title>
    <link href="https://smallyu.net/2023/06/24/%E6%B2%A1%E6%89%BE%E5%88%B0%E5%B7%A5%E4%BD%9C/"/>
    <id>https://smallyu.net/2023/06/24/%E6%B2%A1%E6%89%BE%E5%88%B0%E5%B7%A5%E4%BD%9C/</id>
    <published>2023-06-23T18:43:45.000Z</published>
    <updated>2025-06-18T10:51:43.683Z</updated>
    
    <content type="html"><![CDATA[<p>区块链最近一两年都没什么热点，自从 ETH 从 3400 跌到 1200，也是美联储加息最用力的一段时间，市场就一直处于冷淡的状态，后来又发生了 Luna 归零、FTX 破产之类的事情。</p><p>目前来看市场上的工作需求大概有两类，一类是后端开发，一类是智能合约开发。</p><p>先说智能合约开发，也就是 Solidity 合约开发，主要的工作内容是开发 DAPP，工作的要求是熟悉 ERC 标准，熟悉至少一个线上项目比如 Uniswap，关键要对合约安全有经验，最好有线上项目的经历。如果符合这些技能要求，国内工作需求还是比较多的。</p><p>这样的方向我不太适合，一方面缺少相关的经验，另一方面我也不太有兴趣专职搞 DAPP。</p><p>缺少经验好理解，虽然我熟悉 Solidity 的语法和合约的写法，但是并没有资产安全方面的经验，因为项目没有上线，也没有到安全审计那一步。由于工作不相关，对于 DeFi 的机制也了解比较少。</p><p>至于兴趣方面，我知道有一大批人是在学习 DAPP 开发，也就是 Solidity 的开发，有一个专门的学习社区叫 Dapp-Learning，成员还挺多的，集中了不少国内的开发者和学习者，在主流网站上都有账号。从他们的技术分享来看，也有不少人在研究已经上线的项目的论文，主要集中在 DeFi 领域，分享的内容主要是对经济模型的解读，为什么质押多少钱就能获得多少收益，项目方是怎么设计的，这种。</p><p>其实挺没意思的，从我的角度看，如果作为项目方去搞这么一个项目，还是有利可图的，好听点叫割韭菜，难听点叫骗人。如果作为个人，想要撸羊毛，从项目的机制中获利，就属于有钱的傻子。记得很久以前有个项目，开头一句话就是，越早参与进项目的人获得回报越多，简直妥妥的传销模式，但还是有很多人参与，也是有人从中能挣到钱。如果作为学习者，想要学习技术，就得搞清楚到底是学什么技术，是计算机编程的技术，还是骗人的技术。</p><p>另外，Solidity 其实是一种难用的语言，从编程语言的角度，虽然是图灵完备的，但是写法受限制非常大。我甚至难以想象，智能合约工程师的职位，到底是给什么样的求职者准备的，专职写 Solidity 吗？会写其他语言的人不愿意，不会其他语言的人又不可能会 Solidity，什么样的学习和成长路线，才能出来专职写合约的人，搞不懂。</p><p>再说后端开发，和区块链相关的后端职位有两种，一种是钱包的后端开发，另一种是链上数据的量化。这两种职位都有一个特点，就是不懂区块链也能做，只不过是它们处于区块链的业务中，所以就叫区块链后端开发，但是和区块链本身的功能无关。我不止一次听到面试官类似这样的说话，我们要招的就是纯粹的后端开发，懂区块链最好，不懂也无所谓。</p><p>这就涉及到职业规划的问题。我刚毕业的时候做过一年多区块链的应用层开发，后来转到了联盟链的底层开发，再后来跳槽到一个公链的项目，基本上是有路径的。要是现在说放弃区块链的道路，再回头做普通的后端开发，就有一个沉没成本在里面。</p><p>再者是现在的行业趋势，互联网和区块链是两个不同的行业，一般说互联网是 web2，区块链是 web3，哪有从 3 往 2 走的道理。何况互联网已经寒冬好几年了，虽然区块链行业处于熊市，但是互联网不但冷，还处于没落的路上，尤其是国内的互联网大厂，看看有哪家好过的？</p><p>这是一个两难的问题，现在区块链也不好过。其实各行各业都不好过。17 年左右是公链爆发的一段时间，对于区块链开发的需求比较多一点，后来因为比特币和以太坊两座大山，再搞新的 Layer1 链难度太大，现在的区块链开发需求就很少了。除去技术上的市场环境，之前还在职的时候，无意间听到说，国内的投资机构，最近一年没有投过一个 web3 相关的项目。也就是说国内的创业团队是融不到钱、拿不到投资的。</p><p>在国内还招人的，除非是老牌的区块链公司，屈指可数的那几家，扑克牌名下的。再或者就是从国外拉投资，回国内招人开发，主要目的也是为了降低成本，否则没有理由回国，因为目标用户至少要在国外。想在国内融资、面向国内用户、挣国内用户的钱，目前是不可能是事情。也因此，国内区块链开发的职位应该是少之又少。也不一定是开发 Layer 1，哪怕是 Layer 2、链下节点，只要是在公链生态内的呢，同样也很少。</p><p>这里再强调一下公链和联盟链的区别，我是从联盟链走到公链的，就像是从 web2 走到 web3，国内是有不少联盟链的职位需求的，但是我不能回头，至少不能轻易回头。技术上，联盟链不是真正的区块链，市场上，联盟链没有真正的用户需求，价值上，联盟链不值钱、挣不了钱，搞联盟链的公司都没什么钱。</p><p>提到成长空间，当我们要去一家公司的时候，肯定是看中在公司的发展前景，不管是回报上的提升空间，还是技术方面的提升机会，总得占一样吧，要是两样都没有，整个职业生涯不就走下坡路、没有希望了吗？多少得有点盼头的机会才行。</p><p>再讨论一下技术能力的问题。我们经常说一个人的技术能力好或者坏，或者一种技术难或者不难，那么有什么评价的标准吗。我认为可以从一个角度，就是学习成本。如果一个知识点看一眼就能明白，或者半个小时就能理解，或者一两天就能搞清楚，就属于比较简单的，这种东西，在面试之前学会和面试之后学会，有什么区别呢？还有一些东西是学习成本比较高的，比如对行业的理解，对某种技术类型和项目的了解，可能需要至少两三个月或者半年以上，才能够切实的明白，这种就偏难，成本高一点。</p><p>所以面试更多是方向性的面试，面试过程中，面试官可能会问你各种各样的小问题，大多也是捡着他自己会的问，对于有水平的面试官，肯定不会因为学习成本低的问题，就给你不通过的结果。甚至夸张的说，在看到简历的一瞬间，就基本上能确定是不是要招的人了，其余流程都是走个过场。除非简历作假，在面试过程中体现出的能力达不到简历描述的水平。</p><p>我在脉脉上发起过一个投票，统计大家的待业时间都是多长，参与人数还不少：</p><img src="gap.png" width="30%"><p>有一半以上的人，待业时间都超过三个月。现在的市场环境比较差，也许发生什么都不稀奇。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;区块链最近一两年都没什么热点，自从 ETH 从 3400 跌到 1200，也是美联储加息最用力的一段时间，市场就一直处于冷淡的状态，后来又发生了 Luna 归零、FTX</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>公司解散了</title>
    <link href="https://smallyu.net/2023/06/04/%E5%85%AC%E5%8F%B8%E8%A7%A3%E6%95%A3%E4%BA%86/"/>
    <id>https://smallyu.net/2023/06/04/%E5%85%AC%E5%8F%B8%E8%A7%A3%E6%95%A3%E4%BA%86/</id>
    <published>2023-06-04T09:46:24.000Z</published>
    <updated>2024-08-03T19:07:10.030Z</updated>
    
    <content type="html"><![CDATA[<p>我们大老板是扑克牌之一，在香港开了一家新公司，在上海的总公司和在北京的分公司都不再保留员工了。整件事情发生在一个星期之内，并没有太多缓冲的时间。</p><p>本来是提供了两种方案，可以拿 n+1 走人，也可以和香港新公司签一种社区形式的“共建协议”，继续工作，但是由于北京分公司大多数人选择离开，剩下的人也撑不起整个项目，大老板就让北京这边的所有人都离开了。</p><p>我是为数不多一开始愿意留下来的人之一，所以离职对我来说更加突然。早上还做好了继续上班的准备，上午告知离开、签字，中午就走人了。很快。不过公司给钱还是比较大方，HR 按照最高标准计算了赔偿，所以也不至于有失落的感觉。</p><p>按理在离开一家公司后，应该说一些在职期间不方便说的东西，比如公司的坏话，但是我并没有怀着恨意离开，也不是因为不满而主动离开，就暂时没有太多想说的。</p><p>至于为什么一开始选择留下，也是有多方面的原因。比如，国内真的很难搞区块链。</p><p>接下来一段时间，可能得接触很多公司了，还不一定能找到合适的工作。这次比较奇怪的感觉是，稍微有点不知道简历该怎么写，也没有复盘一下这两年工作的冲动。这两年的工作不至于达到理想的地步，但是我也没闲着，倒不是在技术方面的心虚。</p><p>因为我平时已经时刻关注区块链行业的动态了，并且我其实长期处于迷茫的状态，所以对于接下来要找的工作，也是充满迷茫的。也许是我不知道，也许国内真的不存在，在区块链方向上靠谱的项目。就各种赛道哪个靠谱啊，即使放在整个行业新闻的角度，我也看不到，所以对于真实要找的工作，就更是一点儿都没底了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我们大老板是扑克牌之一，在香港开了一家新公司，在上海的总公司和在北京的分公司都不再保留员工了。整件事情发生在一个星期之内，并没有太多缓冲的时间。&lt;/p&gt;
&lt;p&gt;本来是提供了两种方案，可以拿 n+1</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Pebbling Game 鹅卵石游戏</title>
    <link href="https://smallyu.net/2023/05/18/Pebbling-Game-%E9%B9%85%E5%8D%B5%E7%9F%B3%E6%B8%B8%E6%88%8F/"/>
    <id>https://smallyu.net/2023/05/18/Pebbling-Game-%E9%B9%85%E5%8D%B5%E7%9F%B3%E6%B8%B8%E6%88%8F/</id>
    <published>2023-05-18T08:36:33.000Z</published>
    <updated>2024-08-03T19:07:09.972Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个在线的网页游戏：<a href="https://smallyunet.github.io/pebbling-game/" target="_blank">Pebbling Game</a>。可以看这个嵌入进来的网页：</p><div><iframe src="https://smallyunet.github.io/pebbling-game/" width="900px" height="580px" frameborder="0" scrolling="yes" style="border: 5px double #e4e4e4;"> </iframe></div><p>为了直观展示 Pebbling Game 的游戏规则，经过几十次调整，GPT-4 完成了这个在线的游戏页面。</p><p>游戏的规则是：</p><ol><li>点击节点的圆圈，可以在节点中放入鹅卵石</li><li>只有指向当前节点的所有节点，都已经放置了鹅卵石，当前节点才能够放置鹅卵石</li><li>游戏目的是在节点 0 放置鹅卵石</li><li>任何时间都能够从任意节点取走鹅卵石</li></ol><p>如果直接点击节点 0，可以看到两个红色闪烁圆圈的提醒，意思是节点 1 和 2 都还没有放入鹅卵石，所以节点 0 不能放入鹅卵石。</p><p>节点 7 没有来源节点，所以可以直接放入鹅卵石。点击节点 7，能看到节点内出现了黑色的实心圆。此时如果想把鹅卵石放入节点 3，会提示因为节点 6 还空着，放入失败。节点 3 的来源节点是 6 和 7.</p><p>那么在这样的游戏规则下，问：最少需要多少颗鹅卵石？</p><p>如果鹅卵石足够多，这个图中一共有 10 个节点，手里有 10 个鹅卵石，就不需要取走鹅卵石的操作，直接按照顺序把节点填满就行。</p><p>如果鹅卵石有限，寻求鹅卵石数量最少的解法，这个图应该至少需要 5 个鹅卵石。</p><p>鹅卵石游戏的特点就是，总会存在一个最小值，如果鹅卵石的数量少于这个值，游戏将不能完成，因为最终的节点依赖于下层节点，而下层节点依次依赖于更下层的节点。如果中间节点的鹅卵石被取走，还需要从最下层开始重新放置。</p><p>鹅卵石游戏对于 Hard-to-pebble graphs 的数据结构具有启发意义，理解了游戏的规则，就理解了区块链如何证明磁盘空间的大小。</p><h3 id="空间证明"><a href="#空间证明" class="headerlink" title="空间证明"></a>空间证明</h3><p>Hard-to-pebble graphs 是一种结合了 Merkle 树的 DAG，特点就是需要一定数量的储存空间才能够完成最顶点的计算。就像是鹅卵石不够就无法完成游戏，储存空间不够就无法完成挑战。</p><p>由于图的多种多样，需要鹅卵石的数量没有通用的最优解，只能是针对某一种类型的图，去计算空间复杂度。</p><p>区块链场景的需求是既要占用空间大，又要验证速度快。Stack expender graph 的图结构在 Proof of Space 中使用比较广泛。在验证阶段，只需要按照 Merkle 树的特点，验证图中的某些节点，就可以确认图的完整性了，同时也能根据图的深度，推算出占用了多大的磁盘空间。</p><p>如果既要验证空间大小，又要验证空间占用的持续性，就在空间证明的基础上加上对时间的证明，比如 Chia 就用了 Delay Verifiable Function 的方式，先验一遍空间证明，等一段时间后，用 VDF 验证确实经过了足够多的时间，然后再验一遍空间证明，就达到了 Proof of Space-Time 的效果。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;这是一个在线的网页游戏：&lt;a href=&quot;https://smallyunet.github.io/pebbling-game/&quot; target=&quot;_blank&quot;&gt;Pebbling Game&lt;/a&gt;。可以看这个嵌入进来的网页：&lt;/p&gt;
&lt;div&gt;
&lt;iframe</summary>
        
      
    
    
    
    
    <category term="文件证明" scheme="https://smallyu.net/tags/%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>PDP 文件证明的局限性</title>
    <link href="https://smallyu.net/2023/05/17/PDP%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7/"/>
    <id>https://smallyu.net/2023/05/17/PDP%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7/</id>
    <published>2023-05-17T07:53:06.000Z</published>
    <updated>2024-08-03T19:07:09.972Z</updated>
    
    <content type="html"><![CDATA[<h3 id="存储证明"><a href="#存储证明" class="headerlink" title="存储证明"></a>存储证明</h3><p>对于一个文件来说，PDP 最基础的用法，就是根据文件内容生成对应的 TAG，然后把文件发送到另一个环境里。接着用保存下来的 TAG 验证对方是否真的储存了文件。如果对方没有储存文件，是不可能通过第一次验证的。在接下来的验证中。因为挑战是随机生成的，会选择文件不同位置的片段，能在概率上提高验证的可靠性。</p><p>所以这样的用法，至少能够证明文件储存在对方环境中过。但是这样的证明方式存在疏漏，就是文件不需要完整，或者说缺少对文件完整性的证明。如果文件非常大，而挑战的数量一般是固定的，文件越大，挑战越不全面。虽然挑战的文件片段是随机的，仍然存在可能性，对方不需要完整的文件，而只需要文件的一部分，2&#x2F;3、1&#x2F;2、1&#x2F;3，就足以完成挑战了。</p><h3 id="文件完整性证明"><a href="#文件完整性证明" class="headerlink" title="文件完整性证明"></a>文件完整性证明</h3><p>要让 PDP 能够证明文件的完整性，可以把 PDP 证明和 Merkle 树的数据结构结合起来。PDP 证明一般需要把文件拆分成数据片段，根据数据片段生成 TAG，并不强调数据片段的序列化方式。</p><p>和 Merkle 树结合的地方，就是在把文件拆分为数据片段之后，把数据片段序列化到 Merkle 树中。由于 Merkle 树的特性，父节点的值需要依赖子节点的值才能够推算出来，如果验证了父节点是正确的，就足以说明子节点是全部存在的，也就间接证明了文件的完整性。</p><p>在实际的使用中，往往抽取 Merkle 树的一些节点，对 Merkle 节点的路径进行验证。也是验证 Merkle 树完整性的一般方法。在使用了 Merkle 树作为文件的数据结构，并且在验证 PDP 证明的同时验证 Merkle 树的完整性，就能确保文件是完整存在了。</p><p>Merkle 树的验证覆盖率也不可能 100%，但通常认为，伪造 Merkle 树节点的成本比真正保留了完整数据的成本还要高。</p><h3 id="文件大小证明"><a href="#文件大小证明" class="headerlink" title="文件大小证明"></a>文件大小证明</h3><p>PDP 证明本身不包含文件的元信息，它只能证明文件是存在的、文件是完整的，至于是什么样的文件，文件名是什么、文件类型是什么、文件有多大，一概不知。PDP 的证明信息里不包含文件的元信息，而元信息中比较有用的是文件的大小信息。PDP 不是区块链时代的技术，也就没怎么关心这个问题。</p><p>有的区块链用磁盘空间的大小来描述节点的算力，或者根据文件大小来让使用者付费，或者根据储存的文件大小来给予存储节点奖励，这些都意味着文件大小的信息至关重要。</p><p>那么，对于文件的元信息缺失的问题，一种做法是在 PDP 证明系统之外，将元信息与文件数据关联起来。另一种做法是，对文件进行修改，将元信息附加到文件数据里，只要证明文件数据的完整，就能够确认文件元信息的准确。</p><p>然而，无论哪种方式，都不能保证文件元信息的可靠。在区块链的场景下，信任模型发生了一些变化，和 PDP 要解决的问题存在差异。以前的 PDP 是让用户相信存储节点，而现在，是让区块链来相信存储节点。</p><p>第一种方式需要额外的机制保证元信息和文件数据之间的映射关系，这会带来很大的开销。第二种方式在实现上是简便的，问题在于将元信息附加到文件数据的步骤，由谁来完成？是可信的吗？如果恶意附加了错误的信息呢？另外，怎么读取这些元信息？要把文件数据或者一部分文件数据下载下来？下载的信息还不能保证是正确的？</p><p>总之，在加密学的范畴里，PDP 并不能解决对文件大小的证明。</p><h3 id="文件持续性证明"><a href="#文件持续性证明" class="headerlink" title="文件持续性证明"></a>文件持续性证明</h3><p>PDP 证明需要不断地发起挑战请求，对方能够完成挑战则说明文件安好。比如现在发起一次挑战，一个小时之后又发起一次挑战，至少能够说明对方在完成挑战的时刻，文件是完整存在的。那在没有进行挑战的时间呢？没有限制。</p><p>如果在第一次完成挑战后，就把文件转移到了另外一个地方，等第二次挑战的时候，再把文件拿过来完成挑战，这完全是可以的。PDP 并不也没有能力阻止这样的情况。PDP 无法对文件的持续性提供证明。</p><p>这样的能力限制会对区块链造成什么样的影响呢，首先能想到的就是算力换空间。因为在有些区块链的规则里，文件越大，矿工的收益越高。矿工完全可以利用 PDP 的证明间隔，把空间腾给其他文件用，用磁盘的 IO 换取磁盘空间大小。</p><p>再就是证明成本的提高。挑战越频繁，文件越安全，这对寻求证明的一方是一种压力。</p><h3 id="文件多副本证明"><a href="#文件多副本证明" class="headerlink" title="文件多副本证明"></a>文件多副本证明</h3><p>PDP 自然也不具备证明文件有多个副本的能力。如果需要对方存 2 个副本，而对方实际上只存了 1 份，对于 PDP 是没有任何感知的，这很容易理解。</p><p>如果想分散文件损失的风险，把文件存到了不同地方，在使用 PDP 作为验证手段的情况下，是无法达到目的的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;存储证明&quot;&gt;&lt;a href=&quot;#存储证明&quot; class=&quot;headerlink&quot; title=&quot;存储证明&quot;&gt;&lt;/a&gt;存储证明&lt;/h3&gt;&lt;p&gt;对于一个文件来说，PDP 最基础的用法，就是根据文件内容生成对应的 TAG，然后把文件发送到另一个环境里。接着用保存下来的</summary>
        
      
    
    
    
    
    <category term="文件证明" scheme="https://smallyu.net/tags/%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>半年的工作回顾</title>
    <link href="https://smallyu.net/2023/05/06/%E5%8D%8A%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE/"/>
    <id>https://smallyu.net/2023/05/06/%E5%8D%8A%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE/</id>
    <published>2023-05-06T11:24:50.000Z</published>
    <updated>2024-08-03T19:07:10.040Z</updated>
    
    <content type="html"><![CDATA[<p>回顾一下最近半年的工作。从半年前开始，我就迷茫了，因为知道 Filecoin 在做 EVM 的适配，存储赛道已经倒向计算赛道的一边。我们又无法超越 Filecoin。</p><p>不过我还是有收获的，主要集中在对文件证明的进一步理解，以及对项目中代码细节的进一步熟悉，这一块是我之前没了解的。</p><h3 id="扇区证明"><a href="#扇区证明" class="headerlink" title="扇区证明"></a>扇区证明</h3><p>扇区证明一直存在个问题，就是证明会失败。一开始认为是合约进行证明检查的时候，根本没有带上文件列表的信息，导致过期文件没有被删掉。后来发现不止这一个问题，因为在修复代码后，如果文件只存到一个存储节点，是正常的，如果有多个存储节点，证明仍然会失败。</p><p>最后查到的原因是，当一个文件被存到多个节点，其他节点提交证明到合约，如果发现文件过期了，就会在合约里删掉节点对应的文件信息，同时广播给其他节点，要删掉这个文件。而其他节点收到通知后，只删除了本地的问题，没有删除合约里的文件信息，就导致本地的文件经常会少于合约里记录的文件，证明就失败了。</p><p>这个问题解决的过程中，相当于把证明相关的代码看了一遍。</p><h3 id="EVM-合约"><a href="#EVM-合约" class="headerlink" title="EVM 合约"></a>EVM 合约</h3><p>在去年 <a href="/2022/08/27/%E4%B8%80%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE/">一年的工作回顾</a> 中提到，我在做一件把 Go 语言合约用 Solidity 重写的事情，也就是把原有的合约移植到以太坊上运行。</p><p>其中让项目支持以太坊账户的事情早就完成了，存储节点可以顺利地使用以太坊节点，通过以太坊的智能合约实现文件的上传下载。但是合约对文件的证明一直空着，因为项目使用了 Bulletproof 的零知识证明，用 Solidity 写一遍 Bulletproof 的证明太费力了。</p><p>现在的做法是 POA 的方式，在合约里本该进行证明的地方，换成提交证明参数，把证明参数记录到合约中。然后验证节点从合约里把证明参数拿下来，在本地进行零知识证明的验证，再把证明结果提交回合约里。</p><p>因为把证明相关的代码看了一遍，所以现在能够完成 EVM 合约中，证明相关的这一部分。</p><h3 id="为什么忽略-Layer2"><a href="#为什么忽略-Layer2" class="headerlink" title="为什么忽略 Layer2"></a>为什么忽略 Layer2</h3><p>之前有一个想法是，把证明放到 Layer2 的节点上做。我在这个方向上没什么进度，有两个原因：</p><ol><li>Layer2 的定位是 EVM 完备，本身不具备额外的功能</li><li>Layer2 也很难进行验证</li></ol><p>第一点的意思是，对于用户或者开发者来说，Layer2 存在的意义是降低手续费，如果能在使用效果上和 Layer1 一模一样，那就了不得了。给 Layer2 增加一些额外的功能，是不是 Layer2 这种项目的本意呢？</p><p>第二点的意思是，Layer2 的项目也是拿着 Layer1 的节点改了改区块的头信息之类。想要实现文件的验证，需要在虚拟机的字节码层面，识别出一笔交易是调用了某个合约的某个函数，然后把这个函数要操作的变量拿出来，对参数进行一次零知识证明的验证，再把验证结果在字节码层面写入回变量中。这样做的难度很大。不过要真的能搞成，相当于搞了一个业务专用的 EVM 虚拟机，技术门槛挺高，挺能用来炫耀的。</p><p>与之相比，相对简单的做法就是，用一个客户端对证明参数做验证，再把结果提交回去。如果是这样，那就无所谓客户端在 Layer2 的节点上还是其他什么节点上了。 我就选择了这种简单的方式去做，虽然不够酷，但是有生之年能完成，能看到结果，现在确实完成了。</p><h3 id="Solidity-合约"><a href="#Solidity-合约" class="headerlink" title="Solidity 合约"></a>Solidity 合约</h3><p>稍微总结一下 Go 合约迁移到 Solidity 合约遇到的问题。</p><p>合约大小不能超过 24 KB，否则会编译失败。对于业务型的合约，24 KB 是不够用的，需要拆分为两个甚至多个合约，合约之间再通过调用完成相应的功能。拆起来也不难，就是注意在功能上拆明白，哪些是对外的，哪些是内部的。</p><p>storage 的结构体不能包含列表，因为列表不是固定长度的。合约不好计算占用了多少空间。这就需要把原先结构体里面的列表拆出来，用的时候单独用。当然如果对业务逻辑熟悉，这一点不是什么问题，如果对业务逻辑不熟悉，看到一堆陌生的变量名称，还是挺烦的。我就因为当时偷懒，合约里没把逻辑写全，查了两天才查明白问题。</p><p>mapping 不能迭代。原先简单的写法，需要用 library 改为挺复杂的写法。</p><p>mapping 元素不存在会返回默认值。无法判断 mapping 是否包含某个 key，如果业务中类型的默认值有含义，可能会出现意想不到的情况。</p><p>这几点不算什么大问题，但可能会给写代码的过程带来一点麻烦，因为需要用不一样的写法，写出完全一样的逻辑。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;回顾一下最近半年的工作。从半年前开始，我就迷茫了，因为知道 Filecoin 在做 EVM 的适配，存储赛道已经倒向计算赛道的一边。我们又无法超越</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>不要小瞧 ChatGPT</title>
    <link href="https://smallyu.net/2023/03/30/%E4%B8%8D%E8%A6%81%E5%B0%8F%E7%9E%A7-ChatGPT/"/>
    <id>https://smallyu.net/2023/03/30/%E4%B8%8D%E8%A6%81%E5%B0%8F%E7%9E%A7-ChatGPT/</id>
    <published>2023-03-30T09:09:36.000Z</published>
    <updated>2025-04-12T12:46:53.097Z</updated>
    
    <content type="html"><![CDATA[<p>之前我不了解 Filecoin 是如何管理磁盘空间的，既然它使用了 Proof of Space，那么 Sector 在创建的时候就一定会占用掉磁盘空间，当有用户的文件存入 Sector，Filecoin 是如何及时把占用的空间释放出来的？每写入一次文件，就释放一次占用的空间，这种做法太生硬了。</p><p>我看了 Filecoin 的 <a href="https://docs.filecoin.io/basics/what-is-filecoin/storage-model/">文档</a> 和 <a href="https://spec.filecoin.io/systems/filecoin_mining/sector/">Spec</a>，都没能很直接地找到答案。运行 Filecoin 节点的成本又比较高，不但对硬件需求高，而且还得在实际的操作过程中去观察磁盘容量的变化。</p><p>后来无意间问了 ChatGPT 一句，没想到它给出了很详细的解释，让我对 ChatGPT 刮目相看。Filecoin 不会实时释放磁盘空间，只在 Sector 存满文件之后有一个 Sealing 的过程，这个过程会把 Sector 封存起来，然后用真实的数据替换到之前随机生成的用来占用空间的文件，用真实数据进行挖矿并获得收益。</p><p>以前在一个视频上听到过 Filecoin 的磁盘利用率只有 50% 的说法，但没有很理解为什么那么说。现在才算是明白，Sealing 之前 Sector 会占用两倍磁盘空间的含义。</p><p>在这件事情上，最令人惊讶的是 ChatGPT 的能力，其实回头想想，如果有一个经验丰富的 Filecoin 研究者，他很轻易就能够解答我的疑惑。但我经常面临的问题是，找不到那样资深的研究者，我向他咨询问题，他还乐意给我解答。现在我找到了。</p><p>2020年12月21日，我在<a href="/micro-blog/#2020-32">微博</a>上写下这样一句话：</p><blockquote><p>单纯的记忆是没有意义的，把书本和网络上的内容背下来，只能“显得”厉害，欺骗愚昧的人。如果把计算机和互联网理解成另一种形式的生物，它将比任何人类都博学。</p></blockquote><p>没想到，事到如今，这样的 “生物” 真的出现了，ChatGPT 集成了各个领域的专业知识，并且能够以人类的语言进行对话。我以前就知道，单纯提高自己 “死知识” 的储备没有用，总有你无法超越的人，甚至对方不是人。</p><p>最近有一个 ChatGPT 超越人类案例：<a href="https://www.zhihu.com/question/592511373">如何看待一男子宠物狗患病兽医难断病因，询问 GPT-4 后获救？</a>内容大意是，由于兽医经验有限，对于狗狗的病因，兽医只冲着 A 方向去诊断。后来主人把狗狗的各项身体指标让 ChatGPT 分析，ChatGPT 给出了 A、B 两种可能，去医院一查，果然是 B。由于 ChatGPT 不像兽医一样受到过往阅历的限制，ChatGPT 显得比兽医更加博学。</p><p>随着年龄的增长，我们必须学会抛弃极端的思维方式。我们不能相信 AI 会替代人类，因为现在的 AI 没有智能。我们也不能否认 AI 在某一些方面强过人类，可以作为人类很好的助手。</p><p>现在最先进的大语言模型是 GPT-4，需要在 ChatGPT 的网站上花 20 美元一个月开订阅才能用到。免费使用的预览版本是 GPT-3.5，不过 GPT-3.5 也很厉害。当人们以为 AI 聊天只停留在微软小冰和苹果 Siri 那样水平的时候，GPT-3.5 横空出世，广为流传。我以前用 GPT-3.5 也做过一些事情，帮朋友生成播客的好评评论、帮朋友完成专科学校的编程习题作业，等等。</p><p>ChatGPT 的翻译能力也是很强的，个别词汇的翻译比谷歌翻译要厉害。比如 “兜底机制” 这个词，谷歌翻译会翻译成 “Pocket Mechanism”，而 ChatGPT 会翻译成 “fallback mechanism”，显然谷歌翻译是直译，ChatGPT 是在理解词汇含义之后再翻译的。再比如 “布偶猫”，谷歌翻译为 “cat plush”，ChatGPT 翻译为 “Ragdoll cat”，高下立判。</p><p>不过 GPT-3.5 自诞生就存在一个广为诟病的问题，就是 “一本正经地胡说八道”。作为一个语言模型，程序员应该能比较容易理解，为什么会出现这样的现象，像是套模板，从一堆现成的语言模板里挑出比较好的回答。GPT-3.5 似乎就是这样。也就是说，想靠 GPT-3.5 来获取知识，是有很大风险的，它能告诉你正确的内容，也能把编造的内容当作知识讲出来。</p><p>谷歌的大语言模型 <a href="https://bard.google.com/">Bard</a> 不但综合能力比 ChatGPT 差，对代码的处理能力很弱，而且同样存在 “一本正经地胡说八道” 的情况，还经常 “答非所问”。中国的产品就更不用比了。</p><p>与 GPT-3.5 相比，GPT-4 在各方面应该都有所改善，不是很清楚在信息的准确性上具体有多大程度的改善，但对语言的理解能力确实超过 GPT-3.5，比如这里的<a href="https://v2ex.com/t/927744">讨论</a>。GPT-4 用了和 GPT-3.5 不一样的训练模型架构，微软发布过关于 GPT-4 的<a href="https://arxiv.org/abs/2303.12712">技术论文</a>。从论文看， GPT-4 是支持多模态的，也就是支持根据输入数据生成统计图之类，可能现在还没有开放出来给公众使用。</p><p>GPT-4 的能力过分强大也引来很多人的担忧，甚至马斯克都签署了<a href="https://futureoflife.org/open-letter/pause-giant-ai-experiments/">暂停训练比 GPT-4 更强大 AI 的公开信</a>。没有人知道 GPT-4 的出现，会给人类社会带来有益的还是有害的影响。</p><p>目前已经有很多产品接入了 GPT 的能力，微软的 Office 办公套件是首先支持的，毕竟是自家产品。不知道实际使用效果怎么样，也许会带来翻天覆地的变化，很多重复性的工作，GPT 完全具备更出色的处理能力。你不需要知道 Excel 里的某个函数怎么写，那些函数也许专业的程序员都用不来，何况几乎不懂计算机的文员，有了 GPT，用自然语言描述就可以了。以后的计算机教育也许会增加一个门类：如何与 ChatGPTG 高效沟通。</p><p>微软的 Bing 搜索引擎也引入了 GPT 的能力，没有 GPT 的 Bing 在搜索结果上是无法和 Google 相比的，有了 GPT，Bing 就有了使用自然语言搜索的能力。New Bing 的方式是，根据用户要搜索的内容，GPT 去搜索一遍，然后归纳总结，再用自然语言描述出来。这样做的好处是，GPT 说的都是正确的内容，缺点是处理过程比较慢。尝鲜可以，对于程序员来说，快速解决问题还得是 Google。</p><p>更加值得期待的是 GPT-4 的插件，让 GPT 融入到更多的场景中，比如取代 GitHub Copilot，在生成代码的能力上绰绰有余，只是使用形式上的问题。Copilot 这个东西，一旦用过就回不去了，本以为能够这样自动补全代码已经很先进，没到 Copilot 发布没多久，GPT 就出来了。Copilot 是面临危险的，也推出了 Copilot X 方案，不过我更看好 GPT 的未来。我已经取消了 Copilot 每月 10 美元的订阅，买了每个月 20 美元的 ChatGPT Plus，相信以后 GPT 能大放异彩。</p><p>现在 ChatGPT 的使用对于美国之外的用户，还有一些门槛。首先需要能够正常访问 ChatGPT 的网站，然后注册账号需要美国的手机号码，最后订阅 Plus 需要美国的银行卡。经过一系列的折腾，我的建议是直接买现成的账号最划算，150 人民币就可以买到一个独立使用的、开通了 Plus 的账号。否则即使付出很高的成本，也未必能把事办成。</p><p>外国的手机号码可以花 300 块钱买 Ultra 实体卡，不需要 KYC，号码是 +1 开头，长期保号，每月 3 美元月租，开了 Wi-Fi Calling 可以免费使用 100 条短信。美国手机号还是比较有用的，可以开美区的 PayPal 账户，美区的 Apple ID 可以用美区的 PayPal 支付。美区的 PayPal 可以绑国内开的 Visa 信用卡。很多 IM 软件也会需要国外的手机号码作为验证。</p><p>国外的银行卡可以试试 Depay 虚拟卡，最近因为 ChatGPT 会员的需要发展速度很快，充值加密货币，然后以美元消费。但是 ChatGPT 的订单有一系列的风控规则，IP 地址、订单地址不一致都有可能触发风控，导致订阅失败。只是开通 ChatGPT Plus 的话，苹果手机访问 ChatGPT 能看到 Apple Pay 的选项，有美区 PayPal 也可以试试。总的来说，直接买账号是最快最省力的办法。</p><p>另外，最近 AI 领域的文字生成图片也比较火。我试用了比较热门的几个产品。</p><ul><li><a href="https://labs.openai.com/">DALL-E</a> 和 GPT 是同一家，都是 OpenAI 的产品，但是 DALL-E 绘制出来的人物经常是畸形的</li><li><a href="https://replicate.com/explore">Replicate</a> 提供了多种模型的试用，比如 <a href="https://replicate.com/stability-ai/stable-diffusion">stable-diffusion</a>，同样的问题，生成的人物总是怪怪的</li><li><a href="https://www.midjourney.com/">Midjourney</a> 是在 Discord 里面交互的一个产品，生成的图片质量不差，但是图片里的场景都比较小</li></ul><p>从我的感受上，目前文字生成图片的效果并不好，而且生成图片的效果很大程度取决于，输入的描述语是不是精确符合模型的规则，希望以后借助 GPT 的自然语言能力，文字生成图片会更加好用。</p><p>拥有 ChatGPT 就相当于有了一个空前强大的知识库，它拥有丰富的文字能力，一心一意为你服务，你难道不应该拥有一个吗？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;之前我不了解 Filecoin 是如何管理磁盘空间的，既然它使用了 Proof of Space，那么 Sector 在创建的时候就一定会占用掉磁盘空间，当有用户的文件存入 Sector，Filecoin</summary>
        
      
    
    
    
    
    <category term="AI" scheme="https://smallyu.net/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>一个养老金计算器</title>
    <link href="https://smallyu.net/2023/03/26/%E4%B8%80%E4%B8%AA%E5%85%BB%E8%80%81%E9%87%91%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://smallyu.net/2023/03/26/%E4%B8%80%E4%B8%AA%E5%85%BB%E8%80%81%E9%87%91%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2023-03-26T14:31:04.000Z</published>
    <updated>2024-08-03T19:07:09.975Z</updated>
    
    <content type="html"><![CDATA[<p>由于计算机行业特殊的职业规则，假设做一个在最悲观情况下的打算：在 35 岁之前攒出父母全部的养老金。</p><p>这种计划的动机涉及到一些严肃但会让人感觉非常消极问题，确实不想展开去讨论了。</p><p>我写了一个在线的网页来描述具体的计算过程：<a href="/html/pension.html">养老金计算器</a></p><p>有意思的一点是，这个网页的样式是由 ChatGPT 生成的。我懒得写带颜色的 CSS，就把 body 里面的标签代码交给 ChatGPT，让它帮我生成一个清淡色彩风格的样式。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;由于计算机行业特殊的职业规则，假设做一个在最悲观情况下的打算：在 35 岁之前攒出父母全部的养老金。&lt;/p&gt;
&lt;p&gt;这种计划的动机涉及到一些严肃但会让人感觉非常消极问题，确实不想展开去讨论了。&lt;/p&gt;
&lt;p&gt;我写了一个在线的网页来描述具体的计算过程：&lt;a</summary>
        
      
    
    
    
    
    <category term="使命" scheme="https://smallyu.net/tags/%E4%BD%BF%E5%91%BD/"/>
    
  </entry>
  
  <entry>
    <title>为什么炒币不是一个好主意</title>
    <link href="https://smallyu.net/2023/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%82%92%E5%B8%81%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E4%B8%BB%E6%84%8F/"/>
    <id>https://smallyu.net/2023/03/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%82%92%E5%B8%81%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E4%B8%BB%E6%84%8F/</id>
    <published>2023-03-15T10:38:01.000Z</published>
    <updated>2024-08-03T19:07:10.027Z</updated>
    
    <content type="html"><![CDATA[<p>最近很长时间我都被贫穷的痛苦困扰，但我不认为炒币是一个获得财富的好办法。尤其是短线操作，以及各种加杠杆的合约交易。</p><p>币圈就像一个充满金钱诱惑的赌场，各大交易所、各种 DeFi Dapp 都是赌桌上的游戏。赌徒也许会赚钱也许会赔钱，但最终赚钱的一定是赌场。很少有赌徒可以从赌桌上全身而退。</p><p>比较聪明的人都只是把加密货币作为理财手段，按照投资的性质分配一部分可支配财产进去。长线操作才算是投资，短线就是赌。</p><p>造成这样的现象，最根本的原因是，没有人可以预测市场的走向。</p><p>很多人喜欢在行情发生变化后，有理有据地分析行情为什么会发生，消息面有哪些利好、技术面有哪些趋势、周期上有什么规律。这些分析最大的共同点，就是全都在事后分析，事情发生前，没有人知道会发生什么事情。看看近一年的几次黑天鹅事件，有哪一次是被经济学家、区块链科学家预测到的吗？</p><p>究其原因，没有人可以预测未来。</p><p>再就是最简单的道理，如果那些号称量化大师、预测行情的专业人士，真的掌握着财富密码，为什么要说出来呢？为什么唯恐大家不知道呢？说明他们都只是瞎猜而已，扩大知名度能够带来的收益，比财富密码的收益要高。</p><p>从投资的角度，炒币能带来的收益是比较有限的，却需要承担非常高的风险。当然和传统的基金和股票比起来，变化幅度要大很多，但是加密货币的行情波动还远达不到，让人暴富的程度。10 年前也许可以，回到 10 年前，你真的敢买吗？</p><p>站在历史的高点，看任何事情都轻而易举，可做为历史的亲历者，想超前于时代是很困难的事情，需要过人的眼光和魄力。</p><p>另外，加密货币野蛮发展到现在，已经有一点脱离价值投资的范畴，大盘的涨跌、牛熊市的转换，是因为人们对加密货币本身的认知变化吗？至少最近几年不是，大都因为美联储的货币政策。也就是说，现在加密货币的市场就这么大，除非扩大加密市场的容量，不然新出的链只是在和已有的链争市场份额。</p><p>所以扩大加密市场的机会，在 Web 3.0 和元宇宙上。要让更多的非加密行业内的人，参与到加密市场中去。</p><p>炒币能够稳定获利的方式是老鼠仓，前提要有那种层面的信息源。KOL 在一定程度上是能够影响市场的，如果粉丝数量非常庞大，在 KOL 的言论引导下，粉丝跟风集火到某一个点上，也算是操纵市场的一种方式。这种跟风活动最终获利的肯定也不是后来参与进去的人，自然不靠谱。</p><p>至于说为什么需要关心炒币的问题，因为工作本身并不能让你变得富有。打工可以是一个积累财富的过程，但不会出现让你财富突然增长的情况。思考和寻找能带来更多收益的机会是很有必要的事情。</p><p>关于企业运行的逻辑，一般开始的时候花投资人的钱，有盈利后再把收益还给股东。企业往往会有多个产品线，只要整体上营收大于成本，企业就能够生存下去。</p><p>其实企业在裁员的时候也是充满纠结的，假如因为盈利问题，需要裁掉一个产品线，那么纠结之处在于，如果扛一扛过去这段困难时间，也许未来这个产品能带来更多收益，也许因为没有及时裁掉而带来更多亏损。如果直接裁掉，那么以后再想打造这么一个产品线，又要付出的更多的成本。</p><p>还有一个裁员中让人纠结的问题是，一个人在 A 领域打 60 分，另一个人在 B 领域打 80 分，现在因为 B 领域所在的产品线整个裁掉了，B 领域的所有人都要裁掉，也就是说企业裁掉了更加优秀的人。所以裁员这事不好说，和企业的运行情况和战略方向关系比较大。</p><p>总的来说，炒币不可取，盲目依赖于上班所在的企业也不可取。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近很长时间我都被贫穷的痛苦困扰，但我不认为炒币是一个获得财富的好办法。尤其是短线操作，以及各种加杠杆的合约交易。&lt;/p&gt;
&lt;p&gt;币圈就像一个充满金钱诱惑的赌场，各大交易所、各种 DeFi Dapp</summary>
        
      
    
    
    
    
    <category term="炒币" scheme="https://smallyu.net/tags/%E7%82%92%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>在北京吃一顿饭要花多少钱</title>
    <link href="https://smallyu.net/2023/03/11/%E5%9C%A8%E5%8C%97%E4%BA%AC%E5%90%83%E4%B8%80%E9%A1%BF%E9%A5%AD%E8%A6%81%E8%8A%B1%E5%A4%9A%E5%B0%91%E9%92%B1/"/>
    <id>https://smallyu.net/2023/03/11/%E5%9C%A8%E5%8C%97%E4%BA%AC%E5%90%83%E4%B8%80%E9%A1%BF%E9%A5%AD%E8%A6%81%E8%8A%B1%E5%A4%9A%E5%B0%91%E9%92%B1/</id>
    <published>2023-03-11T03:45:57.000Z</published>
    <updated>2025-06-16T00:32:58.006Z</updated>
    
    <content type="html"><![CDATA[<p>偶然回顾近半年的博客内容，有点太严肃沉重。正好最近半年也吃了很多顿饭，才开始对吃饭这件事情有个大概的了解。</p><center style="font-size: 110%;"><strong>中餐</strong></center><p>按照北京的消费水平，人均 180 人民币就可以吃一顿像样的中餐了。如果低于 ¥180，可能会略显寒酸，即使能够刚刚吃饱，也可能会让坐在对面的女生感觉不尽兴。比较好的状态是，吃饱后桌子上还剩小半盘子菜，坐一坐聊会儿天的功夫，还能再补两口。</p><img src="a.png" width="40%" /><p>这是前几天在望京凯德 MALL 吃的麻辣烤鱼，在一家叫南锣肥猫的店，很好吃。鱼软，刺少，微辣，辣度刚刚好。拍出来的照片颜色鲜艳。锅里加了一些配菜，有午餐肉、腐竹、油条之类，人均 ¥180。</p><img src="j.png" width="50%" /><p>这个是蓝色港湾的一家烤鱼的店，不知道这种在汤里泡着的算不算烤鱼，鱼其实不好吃，没有麻辣烤鱼好吃，不过没刺。中间的腊肠是我硬要点，结果全剩下了，也不是不好吃，实在吃不动了。这顿饭人均 ¥300，算是不便宜，不过很多没吃掉，浪费了。当时也没想着打个包。</p><img src="e.png" width="50%" /><p>北京的烤鸭是有名的地方菜，是很经典的一个菜的种类。这是在合生汇的京华烟云，场地稍微亲民简陋，是那种距离比较近的方形的桌子，价格在烤鸭店里算适中偏低，甜口的虾不太好吃，饮品杯子倒是非常可爱，当时是冬天，还给杯子戴个小帽子，可以带回家收藏了。人均 ¥140 就可以吃饱，多点两个菜尝一尝就要人均 ¥180。</p><img src="c.png" width="50%" /><p>这是在望京的四季民福烤鸭店，一家很火爆的连锁店，饭点去几乎要等位 40 多分钟。这家的烤鸭肯定好吃，不过我觉得最好吃的是那个肉汤，尤其是汤，特别好喝，菜刚端上来会觉得气味奇怪，有点排斥，但是喝两口就喜欢上了。还有那个凉菜，不知道是什么拌什么，又细又凉，口感非常好。对烤鸭的印象不深，只记得菜很多根本吃不完，人均不到 ¥200。</p><p>小大董也是一家有名的连锁店，很多商圈都有分店。三里屯太古里三层有小大董，红烧肉真的很爽，爱大口吃肉千万不能错过。小大董的宫保鸡丁也比四季民福好吃，很有味道。也是人均不到 ¥200，菜多的吃不完，很撑。可惜忘了拍照片。</p><p>比较贵的烤鸭店应该是提督了，公司聚餐吃过一回，环境很小资，菜的样式也挺高级。我没单独吃过，估计人均至少得 ¥300。</p><img src="b.png" width="50%" /><p>这是在五道口购物中心一家叫台巷里的台湾菜馆。台湾菜里的三杯鸡是招牌菜，酱味很重的感觉。烤肉拌饭也值得一吃，下饭管饱。但是蟹黄包的味道一般，有点淡，也可能是三杯鸡的味道太重了，吃过之后就感受不到蟹黄的味道。人均 ¥170 吧。</p><img src="p.png" width="50%" /><p>这个是麻辣香锅，便宜又好吃。火锅的价格也差不多，海底捞人均 ¥150 足够吃饱了，多了吃不完。</p><center style="font-size: 110%;"><strong>西餐</strong></center><p>要说环境高级还得是西餐，氛围好，餐桌间距大，桌子上放着花瓶，还可以让工作人员撒上一些花瓣。价格也要比中餐贵不少，便宜一点的西餐，大概人均要 ¥250，贵一点的，人均 ¥500，再贵一点的，没有吃过。</p><img src="k.png" width="50%" /><p>在三里屯的一家西餐店，当时赶时间没吃牛排，点了披萨意面，10 分钟把所有菜全吃掉。记得这家的意面是吃过最好吃的，但是后来再去吃，意面披萨汉堡全部不一样了，材料也不一样，盘子也不一样，找不到以前的味道。对了西餐为啥要配上日语的标语 😂</p><img src="g.png" width="50%" /><p>这是一家小店，在望京一个小商场的 -1 层，靠窗这个位置拍出来的照片还是挺好的。也是随便吃一顿的晚餐，人均 ¥250。</p><img src="i.png" width="50%" /><img src="m.png" width="40%" /><p>这个是有名的花厨，餐厅里面环境好，餐品样式也好。第二张照片是蓝蝴蝶鸡尾酒，把酒倒进去后会有一个变色的过程，从蓝色变成粉色，挺好玩的。人均不到 ¥300 吧。</p><img src="h.png" width="50%" /><p>这个是我吃过最贵的西餐，在牛排家，惠灵顿牛排套餐，牛排肉很软，很嫩，很好吃。人均 ¥500。</p><center style="font-size: 110%;"><strong>韩餐</strong></center><p>韩餐可以试一下最简单的石锅拌饭，在各种商场里面的简餐，人均 ¥50。或者商场里有的部队火锅，辛拉面最好吃了，也不贵。当然平时也可以买几桶 5 块钱的辛拉面泡面尝一尝味道。</p><img src="n.png" width="40%" /><p>这是一家在望京的店，叫元妈妈的安东鸡，在那个一条街的商圈里面，韩式风味的鸡肉，场地不大，看着比较像家常菜，但是这个鸡肉挺好吃的，带点辣，汤看着颜色重但是可以直接喝，而且我很喜欢这个汤的味道。尤其是把汤浇到米饭上，拌饭吃。人均 ¥120。</p><img src="f.png" width="50%" /><p>更硬菜一点的是韩式烤肉，猪五花最好吃了，必须点两份，还有肥牛，再点个海带拌饭。不过要小心烤肉的时候不要着火，有一次用那种铁丝的网烤肥牛，直接烧起来了，肉全焦了。</p><center style="font-size: 110%;"><strong>墨西哥菜</strong></center><img src="l.png" width="40%" /><p>墨西哥菜不贵而且出其不意地好吃，这个肉看着黑但是并不是焦，上面有一层酱汁。墨西哥菜都是饼里卷着菜的风格，餐桌上会有小卡片，告诉你墨西哥的菜，吃的时候手要抬起来，手捏着饼，小臂和桌面平行，头倾斜 45 度，挺讲究的吃法。当然你要真那种姿势吃可能也挺奇怪的。</p><center style="font-size: 110%;"><strong>日料</strong></center><p>日料价格和西餐差不多，刺身之类的生食比较多，我吃的少，寿喜锅是经常出现的菜品，还有各种小烤串。不过日料的店家场地似乎都不大，很挤的感觉。北京有一家店忘了叫什么，可以换上和服到门口拍和式风格的照片，不过衣服都不新，菜也很一般，贵，量少，主打拍照。</p><center style="font-size: 110%;"><strong>甜品</strong></center><p>如果中午没吃饭，下午两三点就得去吃个下午茶。虽然只是甜品，当个点心吃，但是价格并不便宜。甜品的价格有高有低，由甜品店的风格决定。基本上有两种类型。快餐式的甜品店人均 ¥80，一人一个蛋糕一杯饮料，再多点个蛋糕或者冰激凌。还有一种是网红甜品店，装修华丽，专门给小姑娘拍照准备的，人均 ¥180。</p><img src="d.png" width="40%" /><p>这个是快餐式的甜品，在朝阳大悦城里面。甜品的味道一般不会差，饮品的种类花样也比较多，鸭屎口味的饮料我是真的接受不了。</p><img src="o.png" width="40%" /><p>这个属于看着高大上的甜品店，大众点评上好评多，比较火爆，需要预约那种，中古欧式风格，穿一身 Lolita 在这里拍照，背景氛围各种好看。</p><center style="font-size: 110%;"><strong>小结</strong></center><p>总来来说，各种菜系，人均 ¥150 - ¥200 就妥妥的了。真的是吃了很多次开心的饭。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;偶然回顾近半年的博客内容，有点太严肃沉重。正好最近半年也吃了很多顿饭，才开始对吃饭这件事情有个大概的了解。&lt;/p&gt;
&lt;center style=&quot;font-size: 110%;&quot;&gt;&lt;strong&gt;中餐&lt;/strong&gt;&lt;/center&gt;

&lt;p&gt;按照北京的消费水平，人均</summary>
        
      
    
    
    
    
    <category term="生活" scheme="https://smallyu.net/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>区块链需要一场技术革命</title>
    <link href="https://smallyu.net/2023/03/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9C%80%E8%A6%81%E4%B8%80%E5%9C%BA%E6%8A%80%E6%9C%AF%E9%9D%A9%E5%91%BD/"/>
    <id>https://smallyu.net/2023/03/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9C%80%E8%A6%81%E4%B8%80%E5%9C%BA%E6%8A%80%E6%9C%AF%E9%9D%A9%E5%91%BD/</id>
    <published>2023-03-06T10:45:05.000Z</published>
    <updated>2024-08-03T19:07:10.040Z</updated>
    
    <content type="html"><![CDATA[<p>之前偶然看到一个视频，内容是某一年的互联网大会，李彦宏说，百度当年做了一个错误的决定，就是没有抓住移动互联网的机会。以前认为手机短信那么贵，一次要花 1 毛钱，所以不认为手机上的搜索会流行起来，公司也没有在移动端上布局。等到意识到大势所趋，已经来不及了，移动端的搜索不只是把网页尺寸变小那么简单。</p><p>看到这个讲话的内容首先想到，当年 1 毛钱一条的短信，是不是很像现在 10 美元一次的以太坊交易？</p><p>昂贵的短信协议 SMS 按消息次数收费，人们不敢大量使用，结果更廉价的互联网用 TCP 协议，按照流量收费，和消息次数无关，短信就被淘汰了。</p><p>做一个简单的类比，如果以太坊不再按照交易次数收费，而是按照交易金额收费呢？</p><p>这需要改变区块链最基础的运行逻辑。先不考虑如何实现的问题，在 “按照交易金额收费” 的前提下，区块链会怎么样呢？</p><p>按照交易金额收费的含义是，比如设置转账手续费为 1%，转账 100 美元的手续费就是 1 美元。一次性把 100 美元转账给别人，和分 10 次每次转账 10 美元，花费的手续费是一样的。这样最大的好处就是，非常有利于小额交易的流行。</p><p>（然后网络上的交易量暴增，矿工没有能力处理如此庞大的交易量，网络拥堵、瘫痪、混乱，产生了多个分叉……</p><p>小额交易的流行意味着，以太坊不再是理财产品，而成为正真的货币。货币能够更好地承担起价值转移的作用，这也是比特币一开始的愿景。</p><p>也就是说，限制加密货币扩张最根本的因素，是区块链网络处理交易的能力，需要高吞吐量、低手续费。</p><p>在目前的技术框架下，这几乎是不可能的事情。如果比特币是短信，以太坊就是使用短信查资料的服务，闪电网络相当于短信月包，DeFi 提供了短信理财的能力，DAO 是拉了个短信群，GameFi 是用短信玩贪吃蛇，ZK Rollups 给短信做了最安全的加密…… Web 3.0 是融合了各种短信服务的移动时代，元宇宙是使用短信作为 IM 的虚拟世界。</p><p>现在的区块链，始终围绕在 “短信” 上，致力于拓展短信的业务能力。然而正真需要的能引起变革的技术，是互联网。</p><p>再来考虑会引起技术变革的可能性。</p><p>首先是硬件性能的指数级增长，如果网络的传输性能得到非常大的提升，区块链的交易速度也会有明显的提高。</p><p>其次是共识算法的突破性进展，如果共识算法只需要更少的交互次数、更小的网络带宽，也能给交易能力带来提高。</p><p>最后期待主的降临，给地球带来新希望。</p><p>关于区块链的行业现状可以参考一下这篇文章，是 BlockBeats 在今年 ETHDenver 会议的采访记录：<a href="https://www.theblockbeats.info/news/35283">采访 75 位 ETHDenver 参会者，他们在大会中找到了哪些「财富密码」？</a> 我没太仔细看，反正大意是，没有太新的东西，技术发展有阻力，正在期待应用的爆发。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;之前偶然看到一个视频，内容是某一年的互联网大会，李彦宏说，百度当年做了一个错误的决定，就是没有抓住移动互联网的机会。以前认为手机短信那么贵，一次要花 1</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="区块链革命" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9D%A9%E5%91%BD/"/>
    
  </entry>
  
  <entry>
    <title>一种在区块链上生成随机数的机制</title>
    <link href="https://smallyu.net/2023/02/22/%E4%B8%80%E7%A7%8D%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://smallyu.net/2023/02/22/%E4%B8%80%E7%A7%8D%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E6%9C%BA%E5%88%B6/</id>
    <published>2023-02-22T10:19:59.000Z</published>
    <updated>2024-08-03T19:07:09.980Z</updated>
    
    <content type="html"><![CDATA[<p>区块链本身不允许存在随机数，因为全部节点都需要同步计算结果，如果每次运行的结果不一样，整个网络就会混乱。也就是说，在区块链上，如果有一个函数的作用是生成随机数，这个函数需要符合两点要求：1. 返回值是不可预测的；2. 返回值是确定的。</p><p>这两点要求似乎相悖，但目前已经有解决方案了，Chainlink 的预言机提供了使用 VRF 来生成随机数的方法。由于 VRF 的特性，正好适合在区块链的场景中生成随机数。</p><p>不过现在要讨论的是另一个问题：矿工作恶。可以参考一下这篇文章的内容：<a href="https://hackingdistributed.com/2017/12/24/how-not-to-run-a-blockchain-lottery/">How Not To Run A Blockchain Lottery</a></p><p>假如在区块链上运行一个彩票游戏，而矿工也参与了彩票下注，由于彩票中奖后会获得巨额奖励，只要巨额奖励超过矿工的挖矿所得，矿工就有足够的动机作恶。作恶的方式是，因为一笔交易的执行结果是确定的，而矿工会先知道结果，如果交易结果对自己不利，矿工可以拒绝出块。对于矿工来说，在经济上不一定划算，但是这种情况的存在，不但给彩票游戏增加了不公平的性质，还给了矿工作恶的权利。矿工也有被贿赂的可能性，如果矿工集体作恶，网络就乱套了。</p><p>面对这样的情况，我们需要一种方式来生成随机数，要求矿工不能知道这个数字是什么。等区块确认上链后，随机的数字才被公开。</p><p>有什么是真正的随机、难以预测呢？未来，未来无法预测。</p><p>我们可以尝试使用这样的方式：随机数用本次交易块高度 +2 个块的块哈希作为随机数种子。</p><p>比如发起一笔交易，要生成一个随机数，现在的块高度是 1，这笔交易提交后，得到的随机数是 null，真正的随机数将会在块高度达到 3 时才真正显示。因为这个随机数使用 3 的块哈希作为随机数的种子，在块高度达到 3 之前是不可能有人知道，这个数字将会是什么。</p><p>在彩票的场景中，抽奖结果在块高度为 1 是已经确定了，用户在块高度为 1 的交易中已经参与了抽奖，只是块高度为 3 时才公布抽奖结果。这样几乎能避免矿工作恶的问题，因为在块高度为 1 时，矿工也不知道结果是什么，在块高度为 3 时，参与抽奖的顺序和结果已经确定了。</p><p>那矿工在块高度 3 的时候，不还是可以拒绝出块吗？直接拒绝 1 块或者拒绝 3 块没有差别啊？</p><p>这里就需要区分两个情况：</p><ul><li>在块高度 1 发起的请求，在块高度 3、4、5 去查，得到的都是以块高度 3 的块哈希为种子，计算出的随机数</li><li>在块高度 1 发起的请求，以块高度 3 的块哈希作为种子；在块高度 2 发起的请求，以块高度 4 的块哈希作为种子</li></ul><p>要想达到完全随机的效果，应该使用第二种方式。</p><p>那问题又来了，当前块高度是不断变化的，这个随机值不就成变量了吗？用户在块高度是 3 的时候生成随机数，然后想知道这个随机数具体是多少，结果永远没办法得到这个值，因为等块高度是 5 的时候才真正产生这个数，而块高度是 5 的时候去查询，要等到块高度 7……</p><p>这里还需要区分两个概念：生成随机数和查询随机数。上面两种情况都是按照查询随机数的机制来描述的。</p><p>按照生成随机数的机制来设定，使用第二种方式是必须的，不然随机数就成常量了。那查询呢？不能否认的事实是，只要用户能查到的结果，矿工一定能查到，而且会提前知道。问题回到了一开始的困局，似乎无解了。</p><p>不对不对。</p><p>为什么要设定为使用块高度 +2，而不是 +1 块高度的块哈希呢？是为了避免矿工提前知道结果，如果是 +1，矿工挖出 1 个块就能知道结果，如果是 +2，矿工一般很难领先网络 2 个块。</p><p>所以更好的做法，是在块高度 1 发出生成随机数的请求，然后将块高度 2 和块高度 3 的块哈希，作为随机数种子。在这种情况下，矿工手里的第 3 个块会对随机数产生一定影响，但又不是决定性的影响，有可能第 2 个块就已经确定矿工与中奖无缘了，矿工将没有必要在第 3 个块上进行违规操作。</p><p>那如果第 3 个块也能很大程度决定随机数的内容呢？矿工仍然可以拒绝出块。</p><p>从这个角度来看，延后的块数越多，矿工的影响力越小。假如随机数由 +10 个块的块哈希决定，前 9 个块已经让所有矿工都出局了，矿工就不作恶了。</p><p>还有其他更好的方案吗？好像没有。假如将 +2 个块的块哈希作为对称加密的私钥，在 +2 块产生前随机值已经产生但是无法被解码，问题在于，合约也无法提前把 +2 块作为密钥对随机值进行加密。</p><p>只能降低矿工的影响力了。</p><p>未来无法预测，但当未来来临的时候，总有人能先知先觉。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;区块链本身不允许存在随机数，因为全部节点都需要同步计算结果，如果每次运行的结果不一样，整个网络就会混乱。也就是说，在区块链上，如果有一个函数的作用是生成随机数，这个函数需要符合两点要求：1. 返回值是不可预测的；2.</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="MEV" scheme="https://smallyu.net/tags/MEV/"/>
    
  </entry>
  
  <entry>
    <title>为什么以太坊的私钥计算不可逆</title>
    <link href="https://smallyu.net/2023/02/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%A7%81%E9%92%A5%E8%AE%A1%E7%AE%97%E4%B8%8D%E5%8F%AF%E9%80%86/"/>
    <id>https://smallyu.net/2023/02/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%A7%81%E9%92%A5%E8%AE%A1%E7%AE%97%E4%B8%8D%E5%8F%AF%E9%80%86/</id>
    <published>2023-02-20T15:42:24.000Z</published>
    <updated>2024-08-03T19:07:10.026Z</updated>
    
    <content type="html"><![CDATA[<p>你有没有过好奇，为什么以太坊的私钥无法从账户地址逆推算出来？当你拥有一个私钥，想要得到这个私钥对应的账户地址，你可以在 MetaMask 里导入这个账户，或者使用 ether.js 这样的 SDK 在代码层面导入一个账户到钱包，然后打印出账户的地址。这个导入账户的过程有没有黑箱操作？</p><p>我前几天无意中在 Medium 上看到一片文章，作者用很简洁的代码写出了从私钥到地址的计算过程，作者的代码在这里 <a href="https://gist.github.com/RareSkills/eb51623908f348663cd6a241d9dbf115">RareSkills&#x2F;generate-ethereum-address-lower-level.py</a>。</p><p>我把代码复制过来：</p><pre><code class="python">from ecpy.curves import Curvefrom sha3 import keccak_256private_key = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80cv     = Curve.get_curve(&#39;secp256k1&#39;)pu_key = private_key * cv.generator # just multiplying the private key by generator point (EC multiplication)concat_x_y = pu_key.x.to_bytes(32, byteorder=&#39;big&#39;) + pu_key.y.to_bytes(32, byteorder=&#39;big&#39;)eth_addr = &#39;0x&#39; + keccak_256(concat_x_y).digest()[-20:].hex()print(&#39;private key: &#39;, hex(private_key))print(&#39;eth_address: &#39;, eth_addr)</code></pre><p>这段代码只有四五行，计算的关键有两个地方，<code>private_key * cv.generator</code> 和 <code>keccak_256(concat_x_y)</code>。除了这两个地方，其他的部分都是常量计算，乍一看挺复杂，仔细看看拆解一下，都是很简单的字符串拼接。</p><p>其中，<code>private_key * cv.generator</code> 是椭圆曲线的计算，上看定义的私钥 <code>private_key</code> 是一个 16 进制的数字，注意是 <code>int</code> 类型，然后用椭圆曲线的生成器去计算出一个值。这个计算过程是不可逆的，就是在椭圆曲线上绕圈那个过程，可以类比理解为，一个数字取余之后，你无法还原出取余之前的数字。椭圆曲线只是用更复杂的方式，提供了比 RSA 更加安全的计算结果。</p><p>第二个不可逆的计算是 <code>keccak_256(concat_x_y)</code>，这是一个计算哈希值的过程，keccak 是 sha3 的一种。摘要算法不可逆，这也是毫无疑问的事情。</p><p>也就是说，从私钥到地址的计算过程，有两处是不可逆的，所以整体上，无法从以太坊的账户地址，逆推计算出私钥。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;你有没有过好奇，为什么以太坊的私钥无法从账户地址逆推算出来？当你拥有一个私钥，想要得到这个私钥对应的账户地址，你可以在 MetaMask 里导入这个账户，或者使用 ether.js 这样的 SDK</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>关于以太坊的私钥碰撞</title>
    <link href="https://smallyu.net/2023/01/18/%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%A7%81%E9%92%A5%E7%A2%B0%E6%92%9E/"/>
    <id>https://smallyu.net/2023/01/18/%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%A7%81%E9%92%A5%E7%A2%B0%E6%92%9E/</id>
    <published>2023-01-18T07:27:25.000Z</published>
    <updated>2024-08-03T19:07:10.031Z</updated>
    
    <content type="html"><![CDATA[<p>如果你有 1&#x2F;100000000 的机会暴富，你愿意尝试一下吗？</p><h3 id="以太坊私钥"><a href="#以太坊私钥" class="headerlink" title="以太坊私钥"></a>以太坊私钥</h3><p>以太坊的账户完全由私钥控制，根据私钥可以推算出账户的地址。私钥是一个 64 位长度的 16 进制字符串，比如：</p><pre><code>0xd110227375ab838e8743192d278c105e30f253c966987c50b754412c9b986fe3</code></pre><p>你可以在任何支持以太坊账户的钱包，用这个私钥导入对应的账户。这个私钥对应的账户地址是：</p><pre><code>0x00000006A3D4DA3A559829B1730603CAeE97cC3D</code></pre><p>你也可以根据这个账户地址，在以太坊浏览器上查询到账户相关的<a href="https://etherscan.io/address/0x00000006A3D4DA3A559829B1730603CAeE97cC3D">交易记录</a>等信息。</p><h3 id="私钥碰撞"><a href="#私钥碰撞" class="headerlink" title="私钥碰撞"></a>私钥碰撞</h3><p>既然私钥只是一个字符串，那么有没有可能，随机生成一个字符转，这个私钥对应的账户地址，正好有钱？因为有了私钥就能够控制账户上的所有资产。以太坊上有钱的账户那么多，有的余额还特别高，万一正好生成了一个私钥，那岂不是直接暴富。</p><p>当然随机生成的字符串，必须是 64 位长度 16 进制。为了避免以太坊的 SDK 存在某些防碰撞的规则，我们可以直接粗暴一点生成，比如这样：</p><pre><code class="javascript">let s = &quot;0123456789abcdef&quot;;let hex = &quot;0x&quot;;for (let i = 0; i &lt; 64; i++) &#123;  hex += s[Math.floor(Math.random() * 16)];&#125;</code></pre><p>这样做足够直观，在字符串层面随机拼接出 64 位长度的。LeetCode 的简单题就是天天搞这种。虽然实际上以太坊并没有防碰撞的机制。</p><h3 id="碰撞概率"><a href="#碰撞概率" class="headerlink" title="碰撞概率"></a>碰撞概率</h3><p>我们来计算一下，随机生成私钥，碰撞到有效账户的概率。假如存在一个地址，我们想要正要随机生成这个地址的私钥，可能性是多大？</p><p>16 进制就代表每一位字符，和目标私钥一致的可能性是 1&#x2F;16，一共 64 位长度，概率就是 (1&#x2F;16)<sup>64</sup>。</p><pre><code>p = (1/16)^64  = 1 / 16^64  = 1 / 115792089237316195423570985008687907853269984665640564039457584007913129639936</code></pre><p>把零头抹掉，只计算数量级的话：</p><pre><code>p = 1 / 115792089237316195423570985008687907853269984665640564039457584007913129639936  = 1 / 100000000000000000000000000000000000000000000000000000000000000000000000000000  = 1 / 10^77</code></pre><p>这是一个非常低的概率，中国中奖率最低的大乐透彩票，中奖概率是千万分之一，也就是 1&#x2F;10^8。以太坊的私钥碰撞，想正好是某一个账户的可能性，相当于连续中 10 次彩票。这是几乎不可能发生的事情。</p><p>不过彩票的中奖是有速度限制的，比如需要 1 天才开奖。加密货币领域的私钥可不是，如果提高随机生成私钥的速度，能不能增加碰撞成功的概率呢？</p><p>目前比特币全网的<a href="https://www.blockchain.com/explorer/charts/hash-rate">哈希率</a>是 270M TH&#x2F;s。比特币挖矿的过程本身就是不断地做哈希计算，直到找到拥有 n 和前导 0 哈希值的字符串，所以比特币的哈希率也可以用来描述私钥的生成速率。做一下<a href="https://en.bitcoinwiki.org/wiki/Hashrate">单位换算</a>：</p><pre><code>r = 270M TH/s  = 270000000 TH/s  = 270000000000 GH/s  = 270000000000000 MH/s  = 270000000000000000 kH/s  = 270000000000000000000 /s  = 100000000000000000000 /s  = 10^20</code></pre><p>这个结果只保留了数量级。假如你拥有全球比特币矿机的算力，去做以太坊的私钥碰撞，每秒钟的概率是：</p><pre><code>ps = p * r   = 1 / 10^57   = 1 / 1000000000000000000000000000000000000000000000000000000000</code></pre><p>这仍然是一个低到遥不可及的可能性。如果碰撞持续尝试 1 年呢？</p><pre><code>py = ps * 60 * 60 * 24 * 365   = ps * 31536000   = ps * 10000000   = ps * 10^7   = 1 / 10^50   = 1 / 100000000000000000000000000000000000000000000000000</code></pre><p>持续运行 1 亿年呢？</p><pre><code>pb = py * 100000000   = py * 10^8   = 1 / 10^42   = 1 / 1000000000000000000000000000000000000000000</code></pre><p>可以看到，时间对于概率的增加幅度，是微乎其微的。计算能力也许有可能成倍增长，比如苹果 M 系列芯片，比 Intel 芯片高几倍速度的提升。但是在 70 个 0 的数量级面前，这样的提升仍然微不足道。</p><p>即使拥有 1 亿个地球的比特币算力，运行 1 亿年，也只是能再减少几个 1 后面的 0，远远达不到碰撞成功的目的。</p><h3 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h3><p>虽然可能性非常小，但我还是想尝试一下。</p><p>我写了一个脚本 <a href="https://github.com/eth-collision/eth-collision-random">eth-collision&#x2F;eth-collision-random</a>，随机生成私钥后，根据私钥的账户地址，自动去 <a href="https://etherscan.io/">etherscan.io</a> 上查询账户余额，如果余额大于 0 会把私钥输出到日志文件里。由于 Etherscan 对 API 的调用次数有限制，脚本会以每秒 20 个地址的速度去查询，也就是一天能尝试 172 万个地址。</p><p>这个速度不够快，有更好的办法吗？凡是第三方服务，大多数会有 API 速率的限制，想不受限制进行查询，只能自己运行一个以太坊节点了。以太坊节点最低的硬件要求，是 4 核 16G 内存 1T 硬盘。这样配置的服务器，在 <a href="https://www.vultr.com/">Vultr</a> 上的价格至少要 300 美元一个月。有点贵。而且运行起节点后，还需要自己写一写程序，根据每个块的交易信息统计出有余额的地址。整个周期会很长。</p><p>我注意到 <a href="https://etherscan.io/accounts/1?ps=100">这个页面</a> 提供了以太坊上余额最多的地址列表，1 页 100 个，总共 100 页。我写了一个爬虫 <a href="https://github.com/eth-collision/eth-address-top-list.git">eth-collision&#x2F;eth-address-top-list</a> 到这个页面上抓取数据，这样就能得到以太坊余额最多的 10000 个账户地址的列表。</p><p>根据抓到的 10000 个地址，程序就可以比较快地运行了，而不需要受到 API 速率的限制，也不需要自己跑全节点。由于不看好 JavaScript 的运行速度，我用 Golang 写了一个程序 <a href="https://github.com/eth-collision/eth-collision-match-address.git">eth-collision&#x2F;eth-collision-match-address</a>，启动 100 个协程来加快生成私钥的速度。程序会把 10000 个地址读到一个 map 里，然后判断随机生成的账户是否在目标列表内。JavaScript 的一个 for 循环也足够把 CPU 跑满，但是直觉上总感觉 Golang 会更快一点。</p><p>对了，Golang 中的 map 记得加互斥锁。因为 map 不是并发安全的。不过加锁会降低速率。为了解决需要加锁的问题，因为只有 10000 个地址，占不了多少内存，所以可以实例化多个 map，有多少个协程就有多少个 map，每个协程在自己的 map 上做验证。这样就能充分保证私钥的生成和验证效率。</p><p>10000 个地址是不是太少了？以太坊一共有那么多个地址。一共有多少个呢？从 Etherscan <a href="https://etherscan.io/chart/address">统计</a>目前有 230M 左右，大概 2 亿多个。</p><p>后来我发现了一个仓库 <a href="https://github.com/eth-collision/Wallet-private-key-collision-brute-force-tool">eth-collision&#x2F;Wallet-private-key-collision-brute-force-tool</a>，这个仓库里提供了一个 OneDrive 文件的下载链接，是一个包含 1.8 亿条账户地址的文件，这些账户都在链上有过交易记录。文件的压缩包有 4.4G 大，解压后 16G 左右，是 pkl 格式的文件，然后我用 Python 解析成了 txt 文件。</p><p>在得倒这么多账户地址的列表后，现在的问题就变成了，该怎么利用这些数据。</p><p>首先是像原先一样，把所有数据读到 map 里。这么多的数据读到内存里，占用的内存可能至少 16G，也就是需要 24G 内存的服务器。Vultr 上最便宜的符合要求的服务器，接近 150 美元一个月。况且那么大数据量，Golang 的查询效率也是个疑问，还得加锁，限制比较多。</p><p>有没有好的方案？用数据库的话，MySQL 是支撑不住亿级别的数据查询的，记得之前参与的一个项目，在上亿数据里做最简单的查询要 10 秒以上，还是单次查询。现在的需求是每秒钟查询上千次。Redis 呢？Redis 的查询效率应该是有保证的，可 Redis 还是会把所有数据读到内存里。在 Redis 的<a href="https://redis.io/docs/getting-started/faq/">介绍</a>里，1M 个 key 需要 85M 的内存，换算一下：</p><pre><code>1M   -&gt; 85M180M -&gt; 180 * 85M     = 15300M     = 15G</code></pre><p>Vultr 上，16G 的 Redis 价格很高，比服务器贵多了，需要 480 美元一个月。至于更沉重一点的数据库，像 Elasticsearch 或者更专业一点的 HBase 之类，从数据库搭建到导入数据，然后处理数据，一整套下来确实麻烦了一点。服务器开销也不见得更低。</p><p>再后来，看到有个东西叫布隆过滤器，正好符合这样的使用场景。我试了一下，容量 2 亿条数据的布隆过滤器，容错率 10 亿分之一，在加载完 1.8 亿条数据后，导出的<a href="https://github.com/eth-collision/eth-address-all">二进制文件</a>，只占用 1G 的磁盘空间。加载到内存中，也只需要占用 1G。</p><p>这样的方案其实挺好了。我在服务器上运行碰撞程序，每个月需要 30 美元的 2核 4G 服务器，每个小时可以尝试 60M 个地址。每个月需要 600 人民币的 8核 16G 服务器，每个小时可以尝试 160M 个地址。</p><p>当然，用再好的服务器都没有用，用整个地球上的算力都没用。</p><h3 id="靓号地址"><a href="#靓号地址" class="headerlink" title="靓号地址"></a>靓号地址</h3><p>以太坊的账号地址也有靓号一说，比如地址 <code>0x00000006A3D4DA3A559829B1730603CAeE97cC3D</code> 包含有 6 个前导 0。关于靓号地址可以参考<a href="https://www.theblockbeats.info/news/33808?from=telegram">这篇文章</a>。</p><p>我写了这个程序 <a href="https://github.com/eth-collision/eth-collision-find-address">eth-collision&#x2F;eth-collision-find-address</a> 来寻找靓号地址，一般来说，找到 6 个前导 0 的地址是非常容易的事情，在 Macbook Air M1 上几分钟就可以。包含 7 个前导 0，可能需要半个小时。包含 8 个前导 0，就需要一两天。</p><p>包含有 10 个前导 0 的地址，已经算是非常非常稀有了。不过当然靓号地址没什么用，你一旦知道私钥，这个账号就是你的了，给别人别人也不要。</p><h3 id="在线手动碰撞"><a href="#在线手动碰撞" class="headerlink" title="在线手动碰撞"></a>在线手动碰撞</h3><p>这是一个在线手动进行私钥碰撞的网页，可以根据私钥计算出公钥，也可以生成随机的公私钥对，并且点击链接能够直接跳转到 Etherscan 检查地址对应的余额。</p><p>地址：<a href="http://eag.smallyu.net/">http://eag.smallyu.net</a></p><p>源码：<a href="https://github.com/smallyunet/eth-address-generator">smallyunet&#x2F;eth-address-generator</a></p><p>页面是纯前端实现的，可以离线使用，不会有任何安全问题。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;如果你有 1&amp;#x2F;100000000 的机会暴富，你愿意尝试一下吗？&lt;/p&gt;
&lt;h3 id=&quot;以太坊私钥&quot;&gt;&lt;a href=&quot;#以太坊私钥&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>“猜均值的2/3” dApp 游戏设计</title>
    <link href="https://smallyu.net/2022/12/27/%E2%80%9C%E7%8C%9C%E5%9D%87%E5%80%BC%E7%9A%842-3%E2%80%9DdApp-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://smallyu.net/2022/12/27/%E2%80%9C%E7%8C%9C%E5%9D%87%E5%80%BC%E7%9A%842-3%E2%80%9DdApp-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-12-27T07:48:46.000Z</published>
    <updated>2024-08-18T05:02:42.886Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.m.wikipedia.org/zh-cn/%E7%8C%9C%E5%9D%87%E5%80%BC%E7%9A%842/3">猜均值的2&#x2F;3</a> 是一个经典的博弈游戏，现在把它改造成运行在区块链上的 dApp 游戏，这是游戏的基本规则：</p><ol><li>玩家支付 <code>任意金额</code> 参与游戏</li><li>计算所有用户支付的 <code>金额总和</code></li><li>计算 <code>金额总和</code> 平均值的 2&#x2F;3 作为 <code>胜利数字</code></li><li>玩家支付的 <code>任意金额</code> 最接近 <code>胜利数字</code> 则获胜</li></ol><p>游戏的奖励规则是：</p><ol start="5"><li>获胜者获得本轮游戏所有用户支付的 <code>金额总和</code></li><li>合约在每轮游戏抽取 <code>金额总和</code> 的 1% 作为服务费</li></ol><p>一个重要的问题是，每轮游戏多少玩家参与？或者说每轮游戏什么时候结束？关于游戏结束的规则是这样：</p><ol start="7"><li>每一轮游戏，当玩家参与的时候，可以知道玩家是第 <code>n</code> 个参与的</li><li>生成一个随机数 <code>x</code>（10&lt;&#x3D;x&lt;&#x3D;100）</li><li>根据 <code>n</code> 和 <code>x</code>，生成一个随机数的边界 <code>l, r = n-x, n+x</code></li><li>在 <code>[l, r]</code> 的区间内生成一个随机数 <code>y</code></li><li>如果 <code>y == n</code>，本轮游戏结束</li></ol><p>还有一点补充规则：</p><ol start="12"><li>如果一个用户多次参与游戏，以第一次参与结果为准</li><li>如果多个用户支付的 <code>任意金额</code> 相同，第一个参与的用户获胜</li></ol><p>上面是这个游戏的全部规则。</p><p>结束游戏的规则有点复杂，举一个具体的数值，比如有一个玩家，是第 <code>n=50</code> 个参与进游戏的，然后生成了一个随机数 <code>x=10</code>，那么生成的随机数边界就是 <code>l, r = 45, 55</code>。在范围 [45, 55] 中再生成一个随机数，如果正好是 50，本轮游戏结束。</p><p>为什么要这样做？因为区块链上的数据是公开的。在原版的“猜均值的2&#x2F;3”游戏中，玩家选择的数字，相互是保密的。但在区块链上很难做到这一点。所以这里提出的 dApp 版本游戏规则，至少有两点和原版规则不同：</p><ul><li>玩家参与游戏支付的金额是无限制的，可以是 0，也可以无限大，而原版规则有上限</li><li>玩家数量是不确定的，原版规则是知道有几名玩家参与</li></ul><p>这样差异的设计都是因为，区块链上的数据是公开的，所以要引入一些随机的机制。如果没有随机结束的机制，在玩家数量确定的情况下，越是后面参与的玩家，越有优势，因为可以根据前面参与玩家的记录，推算出自己用哪个数字参与更有可能获胜。</p><p>当然，最后参与的玩家并不一定有能力扭转局势，尤其是在参与数值有上限的情况下。但如果玩家数量是随机的，就不存在“后面参与的玩家”一说，因为谁都不知道游戏什么时候结束，谁是最后一个玩家。所以即使玩家能够支付出扭转局势的金额，也会被后面的玩家拉下来。</p><p>至于原版游戏要求参与数值为整数，dApp 版本的参与数值可以没有限制，可以是小数。是因为原版游戏是人为给出参与数值，而 dApp 版本可以在计算机上自由输入，并且结果是智能合约计算的，不限制精度也没有影响。</p><p>然后解释一下游戏结束的规则。这个规则的效果是，能在大多数情况下，让游戏在参与人数为 [10, 100] 的区间内结束。这个区间对应 <code>规则 9</code> 中 <code>x</code> 的范围。</p><p>这个规则可以这样理解，每个用户都拥有能力结束游戏，但是能力是随机的，最高 1&#x2F;10，最低 1&#x2F;100。如果拥有 1&#x2F;10 的能力，就是有 1&#x2F;10 的可能性让游戏结束。</p><p>假设所有用户都拥有最高的能力 1&#x2F;10，那么游戏大概率会在 10 个人参与后结束。每个人触发“游戏结束”这个事件的概率是独立的，不管多少人参与都是 1&#x2F;10。参与的人数越多，结束的可能性越大，因为不结束的可能性是 9&#x2F;10 的人数次方。</p><p>假设所有用户都拥有最低的能力 1&#x2F;100，那么游戏大概率会在 100 个人参与后结束。</p><p>所以 <code>规则 9</code> 中 <code>x</code> 的范围大概就限定了参与人数的范围。当然，这里的人数范围 [10, 100] 不是严格的概率计算。</p><p>按照上面定义的游戏结束规则，这里模拟了 10 万次运行的结果，记录下游戏会在“有多少个玩家参与”的时候结束，代码在这里：<a href="https://github.com/guessavg/emulate_tool">guessavg&#x2F;emulate_tool</a></p><img src="chart1.png" width="60%"><p>这个图的横坐标是参与游戏的玩家数量，纵坐标是在对应的数量上，游戏结束的次数。比如在接近 1 的位置上，有 2500 次，说明在 10 万次游戏中，有 2500 次 1 个玩家参与就结束了。</p><img src="chart2.png" width="60%"><p>如果次数不够直观的话，可以看这个比例的图，每个数字上结束的比例不超过 2.5%。越靠前的位置，游戏结束的可能性越大，因为每次都是从 0 开始，前面的位置结束游戏的机会更多一点。</p><img src="chart3.png" width="60%"><p>这个比例统计图更能够说明结果，游戏有接近 20% 的概率在参与人数小于 10 的情况下结束，有接近 70% 的概率在参与人数为 [10, 100] 的范围内结束。参与人数大于 300 才结束游戏的概率，只有 0.07%。</p><p>虽然这个规则形成的结果，概率上不是完整的正态分布，但是基本上能够满足一开始的需求，也就是让游戏在随机的时间点结束，并且结束的时间不会很离谱，不会导致参与人数太少或者太多，而且还提供了一定的小概率，允许参与人数达到 500 左右。</p><p>相信这会是一个合理的设计。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zh.m.wikipedia.org/zh-cn/%E7%8C%9C%E5%9D%87%E5%80%BC%E7%9A%842/3&quot;&gt;猜均值的2&amp;#x2F;3&lt;/a&gt; 是一个经典的博弈游戏，现在把它改造成运行在区块链上的 dApp</summary>
        
      
    
    
    
    
    <category term="dApp" scheme="https://smallyu.net/tags/dApp/"/>
    
  </entry>
  
  <entry>
    <title>Proof of Storage/Space/Replication 的区别</title>
    <link href="https://smallyu.net/2022/12/20/Proof-of-Storage-Space-Replication-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://smallyu.net/2022/12/20/Proof-of-Storage-Space-Replication-%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-12-20T09:58:48.000Z</published>
    <updated>2024-08-03T19:07:09.972Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><style>table {    display: inline;}</style><center><table><thead><tr><th>简称</th><th>全称</th><th>年份</th></tr></thead><tbody><tr><td>PDP</td><td>Provable Data Possession</td><td>2007</td></tr><tr><td>PORs</td><td>Proofs of Retrievability</td><td>2007</td></tr><tr><td>PoS</td><td>Proofs of Storage</td><td>2009</td></tr><tr><td>PoS</td><td>Proofs of Space</td><td>2013</td></tr><tr><td>PoST</td><td>Proofs of Space-Time</td><td>2016</td></tr><tr><td>PoRep</td><td>Proof of Replication</td><td>2017</td></tr><tr><td>PoC</td><td>Proof of Capacity</td><td>2017</td></tr></tbody></table></center><h3 id="Proofs-of-Storage"><a href="#Proofs-of-Storage" class="headerlink" title="Proofs of Storage"></a>Proofs of Storage</h3><p>PDP 和 PORs 在 2007 年各自独立地发表，在文件证明的方式上各有优劣，是对同一类问题不同分支的解决方案。</p><p>PoS（Proofs of Storage）的概念至少在 2009 年就已经出现，是一种统称，指客户端对服务端上文件进行验证的交互式协议，同时包含了 PDP 和 PORs 的范畴。比如论文《Proofs of Storage from HomomorphicIdentification Protocols》，第一作者是 Giuseppe Ateniese。</p><p>由于 2009 年区块链还没什么发展，所以 PoS（Proofs of Storage）和共识机制没有关系，和 PoS（Proof of Stack）也仅仅只是简称撞了，没什么联系。</p><p>PDP 和 PORs 属于 PoS 的前身，PoS 把它们用一个名字统一起来了。</p><h3 id="Proofs-of-Space"><a href="#Proofs-of-Space" class="headerlink" title="Proofs of Space"></a>Proofs of Space</h3><p>PoS（Proofs of Space）开始于 2013 年的论文《Proofs of Space》，第一作者是 Stefan Dziembowski。</p><p>也是巧合，PoS（Proofs of Space）和 PoS（Proofs of Storage）的简称一样，有时候可能会引起混淆。这个小节的 PoS 指 Proofs of Space。</p><p>PoS 的理念是，对标 PoW（Proof of Work）。所以从 PoS 开始，就是区块链中的概念了，它是一种共识机制。</p><p>PoW 是用 CPU 的算力进行挖矿，PoS 的想法是用磁盘的容量进行挖矿，想办法证明服务器上有某个数值的磁盘空间。</p><p>最基础的办法，是客户端生成一个文件，比如 1G，然后发送到服务器上，接着只要验证服务器上保存了那个文件，就能证明服务器确实有 1G 的磁盘空间了。不过这个办法太笨了，不但消耗客户端的磁盘空间，还会给网络传输带来非常大的压力。</p><p>PoS 提供的办法是，使用一种 hard to pebble graphs 的数据结构，比如 Merkle hash tree。这种数据结构的特点是，生成上层的数据必须要依赖于下一层的数据。</p><p>比如在使用了 Merkle hash tree 的系统里，客户端可以要求服务端，返回某一个上层节点的整条链路，然后自行验算路径是否正确。可以交叉验证多条链路，基本上就能保证服务端的可信了。</p><h3 id="Proofs-of-Space-Time"><a href="#Proofs-of-Space-Time" class="headerlink" title="Proofs of Space-Time"></a>Proofs of Space-Time</h3><p>PoST（Proofs of Space-Time）出现于 2016 年，论文标题《Simple Proofs of Space-Time and Rational Proofs of Storage》，第一作者是 Tal Moran。</p><p>PoST 是基于 PoS（Proofs of Space）的方案，因为 PoS 可以证明服务器端拥有一定量的磁盘空间，但是不能证明，服务器端的空间容量一直保持在期望的水平。比如，在进行验证的时候，服务器的磁盘空间是 1G，一旦验证结束，服务器就把空间用到别的地方了。再验证的时候，就再生成一遍 1G 的文件，用于验证。</p><p>所以 PoS 提议每 1 分钟都进行一次验证，以保证服务器的诚实。这显然不是很聪明的做法。</p><p>PoST 期望解决这个问题。PoST 提供的方法是，加大初始化阶段的难度，也就是 PoS 生成文件的阶段，想办法让服务器，必须要足够多的时间，才能够生成文件。</p><p>怎么保证需要足够多的时间呢，PoW（Proof of Work）就能够做到，比如计算 2^30 次哈希值，就意味着花费了那么多的时间。</p><p>PoST 就把 PoW 和 PoS 结合了起来，在初始化的阶段，让服务器必须消耗足够多的时间，才能够生成文件，然后在证明的阶段，去验证初始化阶段生成的文件。</p><h3 id="Proof-of-Replication"><a href="#Proof-of-Replication" class="headerlink" title="Proof of Replication"></a>Proof of Replication</h3><p>PoRep（Proof of Replication）源自 2017 年的论文《Proof of Replication》，第一作者是 Juan Bene。</p><p>PoRep 属于 Proofs of Storage 的一种，是 Protocol Labs 的研究成果，Protocol Labs 还开发了 IPFS 和 Filecoin。PoRep 也是 Filecoin 在使用的共识机制。</p><p>PoRep 基于 Proofs of Space 和 Proofs of Retrievability，在其基础上增加了一种能力，就是可以区分出服务器端的副本数量。做法也相对简单，就是在生成 Tags 的阶段，给每个副本都带一个唯一标识，让每一份副本都变得独一无二。</p><p>因为是去中心化的网络，Filecoin 需要保证整个网络中存在多个副本，如果节点联合起来作恶，之前的证明方式是无法应对的，所以 Filecoin 使用了 PoRep 的共识机制。</p><p>2017 版的 PoRep 相对简单，在 2018 版的 PoRep 里，才开始提到使用 Depth Robust Graphs 的数据结构。论文标题是《PoReps:  Proofs of Space on Useful Data》，第一作者是 Ben Fisch。</p><h3 id="Proof-of-Capacity"><a href="#Proof-of-Capacity" class="headerlink" title="Proof of Capacity"></a>Proof of Capacity</h3><p>PoC（Proof of Capacity）是 2017 年 Burstcoin 区块链使用的一种共识机制，</p><p>PoC 提供了一种挖矿的方式，产生新的区块需要一个 nonce 值：</p><pre><code>1 nonce = 8192 hash value = 4095 scoops</code></pre><p>其中 hash value 是使用 Shabal 作为哈希函数计算出的哈希值，每两个哈希值为一个 scoops。</p><p>在 0 到 4095 个 scoop nubmer 中随机选出一个，然后和相应的 nonce 结合，去计算出一个 <code>deadline</code> 值。和其他所有节点相比，谁的 deadline 值最小，谁就可以产生新的区块。</p><p>PoC 更倾向于一种纯粹的共识机制。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;时间线&quot;&gt;&lt;a href=&quot;#时间线&quot; class=&quot;headerlink&quot; title=&quot;时间线&quot;&gt;&lt;/a&gt;时间线&lt;/h3&gt;&lt;style&gt;
table {
    display:</summary>
        
      
    
    
    
    
    <category term="文件证明" scheme="https://smallyu.net/tags/%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E/"/>
    
    <category term="共识机制" scheme="https://smallyu.net/tags/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Proofs of Retrievability 文件证明的含义</title>
    <link href="https://smallyu.net/2022/12/16/Proofs-of-Retrievability-%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://smallyu.net/2022/12/16/Proofs-of-Retrievability-%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E%E7%9A%84%E5%90%AB%E4%B9%89/</id>
    <published>2022-12-16T09:22:05.000Z</published>
    <updated>2024-08-03T19:07:09.972Z</updated>
    
    <content type="html"><![CDATA[<p>PORs（Proofs of Retrievability）的论文和 PDP 在同一年 2007 年发表，论文题目是《PORs: Proofs of Retrievability for Large Files》，第一作者是 Ari Juels。</p><p>PORs 不但可以证明文件确实被保存在服务端，而且可以知道文件有没有被修改、删除，这是 PDP 不具备的能力。不过 PORs 的局限性在于，只能用于加密文件，或者说必须对文件进行加密。PORs 实现的关键在于复杂的 setup 阶段。</p><p>PORs 的思路是，客户端生成一些随机的编码记录在数组中，这些编码被称为哨兵。比如 <code>[6, 4, 0]</code> 是三个哨兵。</p><p>先对客户端的文件进行对称加密，而且必须使用 block cipher 的方式。在加密过程中，把哨兵加入到文件随机的位置。两个哨兵之间，可能隔着 1 个 block 或者无数个 block，哨兵的位置是随机的。</p><p>然后把加密后的文件发送到服务端保存。</p><p>客户端发起挑战的内容，就是要服务端返回，文件在随机 n 个位置上的编码。挑战中包含哨兵所在的位置。</p><p>由于文件是加密的，服务端并不能判断，挑战的位置是原始文件的数据，还是哨兵位置的数据，服务端是难以推测出哨兵位置的。</p><p>对于客户端来说，只需要验证哨兵所在位置对应的编码，就可以判断文件是否存在以及完好无损。如果文件被修改或者中间的某些数据丢失，哨兵所在位置的编码一定是大相径庭的，挑战无法完成。</p><p>Retrievability 是可检索的意思，在 PORs 中的含义是，对于客户端来说，我可以通过指定哨兵位置的方式，对文件的某个部分验证，比如想验证第 1 个哨兵到第 3 个哨兵之间的文件是否完好，或者去验证第 5 个哨兵到第 9 个哨兵之间的文件，指哪打哪。</p><p>至于说为什么一定要对文件进行加密，应该一方面 PORs 依赖于对称加密的 block cipher，另一方面，对于不加密的文件，服务端比较容易推测出哨兵的位置。所以 PORs 只能用于加密文件。</p><p>论文中还通过引入纠错码的方式，来增加文件的容错能力。在 setup 阶段，先对 block 加入纠错码，再进行对称加密。引入纠错码的好处，就是在两个哨兵之间，在一定的错误范围内，如果文件有损坏，可以去修复文件。</p><p>为什么在 PORs 的机制中，纠错码开始显得重要？因为要和 PORs 的特点 Retrievability 结合。如果文件被储存在多个服务器环境，遭到了不同程度的损坏，因为有哨兵的存在，比较容易从其他服务器中恢复文件的一部分。在这样的背景下，引入纠错码就是对文件容错能力的进一步加强了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;PORs（Proofs of Retrievability）的论文和 PDP 在同一年 2007 年发表，论文题目是《PORs: Proofs of Retrievability for Large Files》，第一作者是 Ari Juels。&lt;/p&gt;
&lt;p&gt;PORs</summary>
        
      
    
    
    
    
    <category term="文件证明" scheme="https://smallyu.net/tags/%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>对 S-PDP 文件证明的示例和解释</title>
    <link href="https://smallyu.net/2022/12/14/%E5%AF%B9-S-PDP-%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E%E7%9A%84%E7%A4%BA%E4%BE%8B%E5%92%8C%E8%A7%A3%E9%87%8A/"/>
    <id>https://smallyu.net/2022/12/14/%E5%AF%B9-S-PDP-%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E%E7%9A%84%E7%A4%BA%E4%BE%8B%E5%92%8C%E8%A7%A3%E9%87%8A/</id>
    <published>2022-12-14T13:39:59.000Z</published>
    <updated>2024-08-03T19:07:10.104Z</updated>
    
    <content type="html"><![CDATA[<p>我们现在说的 PDP，一般指发表于 2007 年论文《Provable Data Possession at Untrusted Stores》里的 PDP，第一作者是 Giuseppe Ateniese。这篇论文之前，已经有一些文件证明的概念，比如 B-PDP，但是都没有做到，能够保证服务器端保存了文件。</p><p>S-PDP 是论文中首次提出的一种 scheme，可以用于客户端确认，某个文件确实被保存到了服务器环境上，这个服务器环境是不受信任的。</p><p>PDP 在解决的问题，就是我把一个文件保存到服务器上，不是说服务器告诉我它保存了，我就相信它真的保存了，我需要一种机制，确认文件真的在服务器上了。</p><p>PDP 也有很多种类型，有公开的、私有的、静态的、动态的。S-PDP 是比较基础的一种公开验证的 PDP。</p><p>同态加密是实现 S-PDP 的关键。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我想举一个简单的例子来说明 S-PDP 的过程。因为论文中不着边的东西比较多，概括性的定义比较多，而且语焉不详，没有提供太具体的实现方式。我是按照自己的理解来解释。</p><p>现在客户端有一个原始的文件，内容是：</p><pre><code>F = 12345</code></pre><p>把这个文件分割成小的 block，比如分成 5 份：</p><pre><code>F = [1, 2, 3, 4, 5]</code></pre><p>在客户端这边生成一个随机数组成的数组 W，数组的长度和文件的 block 数量一致。W 的内容一定要是不可预测的：</p><pre><code>W = [8, 1, 7, 3, 6]</code></pre><p>生成同态加密标签分 2 步，首先，我们对 F 和 W 使用加法同态加密，接着，使用客户端公钥对同态加密后的数组，进行非对称加密：</p><pre><code>T = r[ h(9),  h(3),  h(10),  h(7),  h(11)]  =  [rh(9)) rh(3), rh(10), rh(7), rh(11)]</code></pre><p>客户端将会把原始文件 F、同态加密标签 T 一起发送到服务端进行保存，客户端只保留本地生成的随机数组 W，W 是唯一私密不能泄漏的内容。客户端发送完毕后，就可以把本地的原始文件 F 和同态加密标签 T 都删掉了。</p><p>当客户端想要验证服务端的文件，由客户端生成一个挑战，比如随机验证第 1 个和第 3 个 block：</p><pre><code>chal = [1, 3]</code></pre><p>服务端在收到挑战后，生成证明也分 2 步，首先，使用客户端的公钥对原始文件 F 的第 1 个和第 3 个 block 进行非对称加密，接着，使用同态加密标签 T 去做减法同态加密：</p><pre><code>V = [rh(9), rh(10)] - r[h(1),  h(3)]  = [rh(9), rh(10)] - [rh(1), rh(3)]  = [rh(8), rh(7)]</code></pre><p>客户端拿到证明 V 后，使用私钥对证明进行非对称解密：</p><pre><code>sW = r&#39;[rh(8), rh(7)]   =   [ h(8),  h(7)]</code></pre><p>可以验证，证明经过解密后的 sW 正对应随机数组 W 第 1 个和第 3 个索引的值。由于同态加密的使用，整个过程中，W 的内容都没有泄漏。</p><p>用户只要手里有一开始生成的随机数组 W，在没有原始文件的情况下，就可以验证服务端的文件确实存在。这个随机数组 W 的数据占用是非常少的。而且过程中由于非对称加密的使用，服务端必须同时拥有同态加密标签 T 和原始文件 F，才能够完成挑战。因为 T 是公钥加密的，如果服务端作恶，客户端会解密不出来，服务端挑战失败。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>在 PDP 的过程中，存在个问题：既然 V &#x3D; T - F，如果服务端事先把整个 V 保存下来，即使删掉 T 和 F，也是可以通过挑战的，而且客户端并不会发现？</p><p>这是 PDP 的局限性，PDP 只能保证服务器至少保存了这个文件 1 次（如果一次都不保存，是不能生成 V 的），但是无法保证文件持续保存在服务器上，也无法反复验证证明的有效性。</p><p>假如第一次挑战是 [1, 3]，服务器通过了挑战并且保存了挑战为 [1, 3] 的证明，那么之后只要是 [1, 3] 的挑战，服务器都可以直接返回已经通过挑战的证明，而不需要对文件进行计算。客户端无法知晓，证明是立即生成的，还是早已生成的。这是所有 PDP 证明的局限性。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我们现在说的 PDP，一般指发表于 2007 年论文《Provable Data Possession at Untrusted Stores》里的 PDP，第一作者是 Giuseppe Ateniese。这篇论文之前，已经有一些文件证明的概念，比如</summary>
        
      
    
    
    
    
    <category term="文件证明" scheme="https://smallyu.net/tags/%E6%96%87%E4%BB%B6%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>我的加密货币交易机器人</title>
    <link href="https://smallyu.net/2022/12/03/%E6%88%91%E7%9A%84%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E4%BA%A4%E6%98%93%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>https://smallyu.net/2022/12/03/%E6%88%91%E7%9A%84%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E4%BA%A4%E6%98%93%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2022-12-03T07:29:27.000Z</published>
    <updated>2024-08-03T19:07:10.108Z</updated>
    
    <content type="html"><![CDATA[<p>当然不是什么机器人，只是一个简单的脚本。不过值得一说的是，它确实能带来收益。</p><p>目前运行了 10 天左右，收益约 5%，在我看来已经是很好的结果，比自己操作要靠谱很多，反正我手动炒币只有亏钱的份。</p><p>如果本金是 $100，那么按照 5% 的收益率，一个月可以赚 $15，至少能把开服务器的钱挣回来。能平衡开支也是一件值得开心的事情。</p><p>换个角度想，10 天 5%，一个月 15%，一年 150% ……这收益率简直逆天。这还只是用 spot 交易，如果加上杠杆，收益会高很多。</p><p>经过最近几天的运行调试，解决了一些常见的错误情况，程序已经基本上稳定了。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://www.bi123.co/">https://www.bi123.co/</a> 这个网站提供了各种加密货币的信号，会在整点的时候，通过邮件发送过去，某一种加密货币是看涨还是看跌。经过很长时间的人为观察，这个信号挺准的，至少在大方向上没有错。</p><p>那么脚本在收到邮件后，就根据信号，自动在 Binance 上进行交易。Binance 提供了完善的 API。</p><p>脚本会实时推动消息到 Telegram 的机器人，方便查看和关注交易结果。</p><h3 id="收益分析"><a href="#收益分析" class="headerlink" title="收益分析"></a>收益分析</h3><p>在一个价格波动的周期中，如果能做到低点买、高点卖，那么每一个上升的波段都是收益。无所谓价格最终有没有变高，只要有波动，就能有收益。</p><p>bi123 的信号是整点发的，也许会感觉不及时，会错过收益的机会或者带来更大的损失，不过以至少一个小时为周期，也可以防止太小幅度的波动，带来不必要的买卖。</p><p>由于各种加密货币的价格涨跌不一致，脚本支持配置多种不同的加密货币，随个人喜好选择。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>也没什么技术含量，代码在这里：<a href="https://github.com/smallyunet/txbot">smallyunet&#x2F;txbot</a></p><h3 id="2023-01-12"><a href="#2023-01-12" class="headerlink" title="2023.01.12"></a>2023.01.12</h3><p>现在已经过去了一个多月的时间，来总结一下我实际的使用情况和结论。</p><p>首先是由于犯了很多错误，导致我最近一个月的余额是亏损的，大概亏损 3% 左右。一开始我没有留意，信号是分级别的，有 1 小时级别、4 小时级别、1 天的级别。不同的级别对市场的响应速度不一样。bi123.co 的 “信号趋势” 这个种类的信号，原理是对比收盘价，比如现在的价格是 1500 美元， 4 个小时之前是 1300 美元，那么就发出看涨的信号，就这么简单，就这么暴力。所以不同级别强度的信号，差异很大。一般来说，不推荐使用 1 小时的信号，我也确实在使用 1 小时信号的情况下，亏损率比较高。后来换成 4小时级别的信号，效果好多了。我推荐用 4 小时的信号。</p><p>再一个是信号种类。bi123.co 提供了 “信号趋势”、“RSI 背离”、“MD5 短线”、“多空头排列” 等多种信号，我之前只用了 “信号趋势” 一种，比较容易导致对市场的反应不及时。我推荐所有种类的信号一起用。</p><p>现在交易机器人脚本是支持配置使用，不同级别的信号强度以及信号种类的，默认配置是我感觉比较好的一种配置。</p><p>再看机器人的效果，目前机器人是无法逆市场而为的，也就是说很难在熊市的情况下获利，因为目前机器人只支持 spot 交易，没有添加做空或者倍率的交易方式，后期可以考虑加入。而且机器人会在市场短期震荡的情况下，发生亏损，也就是横盘的情况，机器人不但无法获利，而且会有少量亏损。从这个角度看，机器人似乎很肋助。</p><p>但机器人也不是毫无用处，机器人可以帮助你顺应市场，在跌的时候及时卖出，涨的时候及时买入，而不至于发生，跌的时候继续持有、涨的时候没有买入等情况。而这些操作都不需要手动完成，你甚至不需要关心这笔资产的情况，一切都会自动发生，它可以帮助你，不错过任何时候市场的机会。市场下跌及时止损，市场上涨及时跟进，就是这样。</p><p>机器人的另一个用处是，支持多币种的配置，可以让你不错过某个币种疯狂上涨的获利机会。市场上经常出现，某一个币种逆势上涨的情况，其他币都没怎么动，某个币拉疯了。如果是手动操作资产，很难不错过这样的机会，但如果是机器人自动批量操作，似乎很容易，也很自然而然可以抓住这样的机会。</p><h3 id="2023-01-15"><a href="#2023-01-15" class="headerlink" title="2023.01.15"></a>2023.01.15</h3><p>短短两天，市场疯涨，机器人的表现也符合预期，市场拉升，机器人会自动买入，及时跟上收益。这是最近一整个月，在机器人的控制下，我的资产变动情况（纵坐标的单位不重要）：</p><img src="balance.png" width="100%"><p>在一段时间的实践之后，我仍然推荐使用这样的机器人。</p><h3 id="2023-03-16"><a href="#2023-03-16" class="headerlink" title="2023.03.16"></a>2023.03.16</h3><p>经过最近一段时间对机器人的试用，我决定放弃并停止使用这样的机器人。我一共标的了 56 种加密货币，接受它们的信号，并且根据信号自动进行交易，这是最近一个月的资产变动情况：</p><img src="balance2.png" width="100%"><p>也许是标的货币的种类太多，导致单种货币投入的金额太小，又或者是其他什么原因，总之由于机器人实际效果的不理想，以及现在我对炒币这件事情的不认可，不再推荐使用这样的机器人。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;当然不是什么机器人，只是一个简单的脚本。不过值得一说的是，它确实能带来收益。&lt;/p&gt;
&lt;p&gt;目前运行了 10 天左右，收益约 5%，在我看来已经是很好的结果，比自己操作要靠谱很多，反正我手动炒币只有亏钱的份。&lt;/p&gt;
&lt;p&gt;如果本金是 $100，那么按照 5%</summary>
        
      
    
    
    
    
    <category term="加密货币" scheme="https://smallyu.net/tags/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>对区块链行业的见闻</title>
    <link href="https://smallyu.net/2022/11/15/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%8C%E4%B8%9A%E7%9A%84%E8%A7%81%E9%97%BB/"/>
    <id>https://smallyu.net/2022/11/15/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A1%8C%E4%B8%9A%E7%9A%84%E8%A7%81%E9%97%BB/</id>
    <published>2022-11-15T09:05:50.000Z</published>
    <updated>2024-08-03T19:07:10.104Z</updated>
    
    <content type="html"><![CDATA[<p>最近有点迷茫，随便写写，可能比较乱。之前只写过工作方面的回顾，没有概念方面的内容。这一年过的很快，发生了很多事情，又没什么大的变化。</p><p>最近一年都是熊市，尤其是五月份之后，区块链行业进入严重的寒冬，没有像之前各种概念层出不穷，似乎没有大事发生，大家都还在想，下一轮加密货币行业的叙事会是什么？</p><h3 id="ETH"><a href="#ETH" class="headerlink" title="ETH"></a>ETH</h3><p>以太坊是加密行业的半壁江山，很多项目都是基于以太坊构建的，很多 token 都在以太坊的合约里，很多概念也都是以太坊提出来的，比如 DAO，这样的体量是不会轻易倒下的，如果倒下那些项目要跟着死。比特币的价值在于开创了整个行业，但未来区块链拓展应用场景和生态，还得是以太坊，以太坊能玩得起来。</p><p>再一个是公链的开发周期长，当年以太坊也是苦苦拉投资，“2017 年 Vitalik 来中国学中文”，后来回西方国家开发了两年，EVM 才成型，并且现在几乎已经成为智能合约的标准，各种链都开始试图兼容 EVM，因为智能合约的虚拟机和生态，没有完成度比 EVM 高的。以太坊一开始发布的白皮书，也是以智能合约为卖点，PoS 是后来版本的白皮书才有的。</p><p>2017 年到 2019 年是公链爆发的时间段，在共识机制上创新，或者应用场景上创新，现在的很多链都是那个时候留下的，投资人也愿意往底层链上投资。现在发链的比较少，因为竞争力不大，回报周期也比较长。今年的 Aptos 和 Sui 主打 Move 编程语言，共识机制上没有太大创新，我觉得 Move 编程语言也不会很流行。</p><p>号称历史上最大升级的以太坊 merge，其实啥事都没有，对于普通用户来说，发生了和没发生一样，一点感觉都没有。合并之后，币价从 1700 跌到了 1400。说好的发行量减少、会通缩、价格会涨，都没有。</p><p>不过以太坊合并之后价格没崩，说明以太坊的价值不来源于挖矿。有的人认为挖矿是币价的保障，因为有一个成本在里面。以太坊的事情说明，不用算力挖矿、没有硬件设备做抵押，也能行。</p><h3 id="CEX"><a href="#CEX" class="headerlink" title="CEX"></a>CEX</h3><p>加密货币的价格和美股关联性很强，涨跌全看美联储的加息幅度和 CPI 之类的指标。不过也有不那么相关的时候，如果用户对美股失去信心，资金就会进入加密货币，如果对加密货币失去信心，资金就会进入美股。</p><p>加密货币行业的盘子比较小，好像全部只有几千亿美元，和美股几十万亿的盘子比起来，影响不会很大。有的阴谋论会说，加密货币是美国货币的蓄水池，为了缓解通胀。</p><p>这两天 FTX 暴雷，挪用用户的加密货币资产，导致用户对加密货币尤其是 CEX 失去信心，加密货币进入新一轮熊市，以太坊价格好不容易回到 1700 左右，一下打回 1300。各大交易所开始公布资产证明。</p><p>交易所里面的交易真的是赌博，我玩不来。我曾经也有一个暴富的梦，拿着 100 美元，开了 125 倍的杠杆，做空 Mask，几秒钟被拉爆仓。后来又拿着 100 美元，做多 Sol，只剩下一半左右。不敢玩了，币圈都是赌狗，涨跌全靠消息，doge coin 全靠 Musk 喊单。FTX 拿的 SHIB 都比 ETH 多。</p><p>顺便说一句，凉兮素质很低，马一龙没啥文化，KOL 都是跳梁小丑。孙宇晨其实是看不起这些人的，只是借助他们的流量和噱头。</p><h3 id="Finance"><a href="#Finance" class="headerlink" title="Finance"></a>Finance</h3><p>NFT 的出圈挺突然的，但是现在热度也下来了。看到一篇文章里说，区块链的场景有两种，一种是 web 2 转移到 web 3，那不叫创新，叫链改，另一种是 web 3 原生。本来想着用 NFT 作为艺术品的链上存证，没起来，结果蓝筹 NFT 在链上搞原创，链下搞周边，火了。现在的 NFT 还是投资的属性多一点，靠品牌大和稀有度。</p><p>各种 Fi 其实最终都落在 Finance 上，SoicalFi、GameFi、DeFi，都在金融的圈子里。目前还没有靠谱的场景能行得通，最大的 web 3.0 和元宇宙都是概念阶段。国外都没玩通，国内就更不行了，天然抵制 Fi。在这样的背景下，你说绝望吧。</p><p>有聊天室和邮箱基于 ENS 的，问题是谁用啊。有小游戏结合链上资产的，玩家挣不到钱，项目方也挣不到钱，那怎么办。</p><p>在一些一线机场买 VPN 的时候，发现支持 TRC-20，还挺意外的，原来 Tron 还活着，还有商家在用，倒是给了我下载 Trx 钱包的理由，它真的能用来买东西，不用担心国内的支付方式有问题了。不过遗憾的是，依然是 Finance 场景。</p><h3 id="DSN"><a href="#DSN" class="headerlink" title="DSN"></a>DSN</h3><p>分布式储存网络有两个头部，Filecoin 和 Arweave。</p><p>Filecoin 是链下储存的典型，或者说基于合约的 DSN，链下用 IPFS 存数据，链上做存证、结算、挑战。Filecoin 的学术能力很强，先是做出了 IPFS，在 PoC 方面也基本上是老大，在文件证明的方向有很多创新，超越了基础的 PDP、Proof of Retrivailiabily。在链式的文件证明上都是发顶会的论文。</p><p>链下储存的优点是文件可以很大，不会影响到链的效率，但是 Filecoin 广为人知的问题是，数据有丢失的风险，数据没了就真的没了。而且 Filecoin 的节点和 SDK 真的不怎么好用，至少不亲民，据说因为要根据磁盘空间计算算力，故意控制文件的编码速度到一个频率，导致用户的体验非常差，可能要一两个小时才能知道，文件有没有成功储存。现在也少有项目是用 Filecoin 构建项目。</p><p>Arweave 是链上储存的典型，或者说基于链的 DSN。Arweave 的创新能力比起 Filecoin 差很多，块结构和 Filecoin 类似，会在块中记录一个 calldata，随机验证上一个块 calldata 前 10% 的内容。Filecoin 的 PoC 共识比较纯粹一点，Arweave 还是要依赖 PoW 挖矿，先做文件的校验，然后 randomX 挖矿。</p><p>Arweave 利用经济模型，文件越稀有，挖矿的几率越高，用这样的方式达到文件永久储存的效果，以区别于 Filecoin 的临时储存。Arweave 和 Meta 合作也让 Ar 的价格涨了很多。</p><p>链上储存的好处就是，文件永远不会丢。问题是数据膨胀量也比较大，对于大文件的储存可能不是很友好，比较适合存 NFT 之类的数据。以太坊也早就有结合 IPFS 做链下储存 NFT 的方案。</p><p>我理解链上储存和链下储存，或者基于链的储存和基于合约的储存，简单的区分方式是，看生成新的块要不要依赖上一个块的文件数据。</p><p>有人认为目前的区块链，基本方向还在于分布式计算，至于分布式储存，可能路径不是特别明确。Filecoin 也是在搞一种 actor 的节点，支持 EVM 的执行环境。其实早在多年前《硅谷》的电视剧里，就已经畅想过分布式储存的前景了。</p><p>参考之前的思维方式，分布式储存是要做链改，替换掉 web 2 的云服务器市场呢，还是在 web 3 上搞创新呢。</p><h3 id="Layer-2"><a href="#Layer-2" class="headerlink" title="Layer 2"></a>Layer 2</h3><p>首先 layer 2 还在 Finance 的范畴里。以太坊计划把 layer 2 发扬光大，提高主网的性能，分散主网的计算压力。</p><p>目前 layer 2 还没有真正的头部，各个 layer 2 项目是割裂的，相互之间不能交互，对用户的体验是很大的问题。用户需要选一个 layer 2 站队，那么只有一些小项目会放到 layer 2 上。layer 1 的大合约不太可能会放到 layer 2 上。</p><p>layer 2 的技术设施也不完善，zk 就不用想了，op 和 arb 相对能用，但是比较中心化，和 layer 1 的交互也比较慢。arb 今年在奥德赛的时候，由于用户的突然增加，gas 费接近主网的 3 倍，属于世界名画了，问题也一时难以修复。</p><p>op 的挑战周期比较长，据说是一到两周，对于普通用户有点不能接受，而且问题在于，谁来验证主网上的交易。用户自己肯定不干，交给第三方的话，又要把信任放到第三方上。</p><p>state channels 和侧链的局限性都比 rollups 要大，更加不那么安全，op 似乎是从 plamsa 演进来的。</p><p>以太坊对 layer 和 sharding 都有很多蓝图，但是就像不知道谁说的，“以太坊啥都好，就是啥都慢”，我们对以太坊的期待要等很久。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>DID 几年前就有了，没有项目真正做起来。现在阶段，还是认为小狐狸或者钱包是 web 3 的入口，如果要搞 DID，可能还需要一大波市场的清洗。</p><p>Solana 的价格在 FTX 的事件中跌的厉害，Solana 的特点是 PoH 共识，因为经历过之前的几次宕机，大家不是特别看好。</p><p>Polkadot 主要是它不好用啊。</p><p>DeFinity 看起来挺好用的，理念上也结合了各种链的优点，号称无限扩容，全部数据上链。问题是他没有太大创新，更多的是把各种东西整合到一起。</p><p>Conflux 是国内的链，从大学实验室里开始的，在国内根本做不起来，啥场景都没有。</p><p>比特币由于耗费大量算力的问题，长期看会被淘汰，也会被历史记住。它最稳，也最不稳。</p><p>其他的我也不知道了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近有点迷茫，随便写写，可能比较乱。之前只写过工作方面的回顾，没有概念方面的内容。这一年过的很快，发生了很多事情，又没什么大的变化。&lt;/p&gt;
&lt;p&gt;最近一年都是熊市，尤其是五月份之后，区块链行业进入严重的寒冬，没有像之前各种概念层出不穷，似乎没有大事发生，大家都还在想，下一</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>随机确认块的共识机制</title>
    <link href="https://smallyu.net/2022/09/25/%E9%9A%8F%E6%9C%BA%E7%A1%AE%E8%AE%A4%E5%9D%97%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    <id>https://smallyu.net/2022/09/25/%E9%9A%8F%E6%9C%BA%E7%A1%AE%E8%AE%A4%E5%9D%97%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</id>
    <published>2022-09-25T09:43:28.000Z</published>
    <updated>2024-08-03T19:07:10.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>在一个时间窗口内，一个节点会收到多个通过验证的块，在这些块中随机选取一个作为自己的下一个块。</p></li><li><p>在下一个时间窗口，节点如果没有收到块，同时发现网络整体的块高度已经高于自己，将丢弃掉上一个确认的块。</p></li><li><p>如果块高度相同，少数服从多数。</p></li></ol><h3 id="为什么要这样"><a href="#为什么要这样" class="headerlink" title="为什么要这样"></a>为什么要这样</h3><ul><li>收到多个通过验证的块</li></ul><p>Proof of work 的思路是，在一个时间窗口内，只有一个正确答案，这样就保证了整个网络的一致。换个思路的话，为什么不能在同一个时间窗口内，产生多个正确答案呢？</p><ul><li>随机选取一个块</li></ul><p>由于网络中同时存在多个正确的块，那么就需要一种机制来从中选取一个，公平起见，就用完全随机的方式。</p><ul><li>丢弃上一个块</li></ul><p>丢弃块的机制是为了给系统提供自我纠错的能力。Ethereum 的 DAO 攻击事件，需要开发者带领社区对区块链进行硬分叉，说明系统本身是没有纠错能力的，需要人为干预，似乎目前所有区块链系统都是这样。</p><ul><li>少数服从多数</li></ul><p>在没有交易发生的情况下，有可能所有节点都处于等待的状态，此时因为块高度相同，没有节点愿意丢弃自己的块，整个网络是割裂的。这是一种博弈的状态，所以要按照少数服从多数的原则打破平衡。</p><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul><li>为什么要随机？</li></ul><p>为了避免富有的人越富有，有算力的节点更富有，有财产的节点更富有，公平地给予每个参与到网络中的节点，获取块奖励的机会。</p><ul><li>谁来随机？</li></ul><p>每个节点各自随机，选取一个块。而不是使用类似 Varifiable random function 的方式，让每个节点都使用确认的结果。</p><ul><li>完全随机还是有限制的随机？</li></ul><p>完全随机。</p><p>完全随机是指，节点收到 100 个块，选中某个块的概率就是 1%。有限制的随机是指，例如，上一个块已经是某个节点提供的，下一个块就不再使用它的块。相应的，块奖励也不会给它。</p><p>如果是有限制的随机，已经产生过块的节点，和没有产生过块的节点，就有了不一样的权重，无论权重侧重于哪一边，都不是合理的方式。如果产生过块的节点更有权重，依然会存在富有的人越富有的问题。如果没有产生过块的节点更有权重，网络中的参与者就会疯狂创建新的账户，使用没有获得过块奖励的节点产出块。</p><ul><li>随机会带来分叉？</li></ul><p>一定会，但分叉是小范围的。如果网络效率很高，那么只有最新的一两个块会处于不确定的状态，等大多数节点确认下来，就成为主流的一条链了。</p><ul><li>分叉会一直存在吗？</li></ul><p>不会，因为分叉会被淘汰。新加入网络的节点，肯定要选择某一个节点同步数据。对于其他节点，随机选择是指从通过验证的块中选择，通过验证的含义是，历史数据和自己一样。那么当某一条分叉链没有交易产生，由于纠错机制的存在，分叉链会不断丢弃掉自己的块，直到和主网络一致。</p><ul><li>如果新节点不同步数据呢？</li></ul><p>如果新加入的节点不同步已有数据，而是另起炉灶，那么它需要拉拢超过整个网络大多数节点规模的追随者。比如有 1000 个节点，由于完全随机的机制，它需要另外 1000 个节点，自己的链才会变为网络中的主流。这种做法可以视为攻击网络的一种方式。难度似乎比 51% 攻击还要高。</p><ul><li>存在 51% 攻击？</li></ul><p>由于块高度优先的方式加上少数服从多数的原则，可能会认为，攻击者甚至不需要 51%，只需要掌控块高度最高节点数的 51%，就可以形成攻击。</p><p>这里也许存在概念上的误区，攻击是指颠覆原有的数据而不是产生新的数据。51% 是不存在的。</p><ul><li>回滚会带来不确定性？</li></ul><p>对于用户来说，确实是不好的体验，可能上一分钟交易已经成功了，下一分钟节点丢弃了块，交易撤销了。</p><p>不过好在这种不确定是短暂的，可以认为确认一个块需要两个时间窗口或者更多个。因为即时网络中存在小范围的分叉，最终也会趋于大多数一致。</p><p>所以问题变成了客户端确认一笔交易的时机。</p><ul><li>未确认的块会造成资源浪费？</li></ul><p>一个节点收到 10 个块，确认 1 个，其他的块就浪费掉了。包括反复的纠错，也属于资源的浪费。</p><p>PoW 浪费的是算力资源，这种随机确认块的方式，浪费的是网络传输的资源，因为如果一个节点想要自己的块被确认，它首先要让其他节点接收到它的块。那么假如网络中有 1000 个节点，就需要每一轮都把块广播给 1000 个节点。</p><p>好在网络传输资源的浪费是有上限的，区块链网络本身就需要把每一笔交易广播到网络中，与其相比，现在只是需要多广播一个块的内容，算不上太大的负担。而且由于是完全随机地选择块，节点试图通过更高的网络配置来多次广播块也是没有意义的。</p><ul><li>如果网络异常，节点会丢弃所有块？</li></ul><p>如果节点获取到网络中块高度非常低，按照规则 2，是不是就会逐渐丢弃掉所有块？</p><p>不会。要区分清楚，从网络中获取到异常信息，和连接不到网络、无法从网络总获取信息，是两回事。假如一个节点的路由表中有 1000 个节点的连接记录，由于网络状况异常，只能连接到 10 个，此时就属于异常情况，节点不应该按照正常的共识流程丢弃块。</p><ul><li>有哪些已有的提案？</li></ul><p>在这篇论文《<a href="https://arxiv.org/abs/2001.07091">Blockchain Consensus Algorithms: A Survey</a>》的第 16-17 页，提到了随机选择出块节点的共识方式，以及基于 coin-age 的选择方式。这确实是一个随机的概念，但论文描述的是随机是指随机选择节点，而不是针对块，并且是在 PoS 的语境下讨论的，出块节点有被选定、被内定的意味。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="共识机制" scheme="https://smallyu.net/tags/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>VRF + BFT 共识引起交易失败的问题</title>
    <link href="https://smallyu.net/2022/09/03/VRF-BFT-%E5%85%B1%E8%AF%86%E5%BC%95%E8%B5%B7%E4%BA%A4%E6%98%93%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://smallyu.net/2022/09/03/VRF-BFT-%E5%85%B1%E8%AF%86%E5%BC%95%E8%B5%B7%E4%BA%A4%E6%98%93%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-09-02T22:39:51.000Z</published>
    <updated>2024-08-03T19:07:09.973Z</updated>
    
    <content type="html"><![CDATA[<p>昨天遇到一个问题，是 Ontology 的节点不出块了。节点使用的是 VBFT 共识，网络互通没有隔离，也就没有分叉，报的错是提案（proposal）过来的块，和预期的块哈希（MerkleRoot）不一样。由于种种原因，昨天的问题没有深入去查，用比较暴力的方法先让网络恢复正常。不过提到 VBFT，我想到了以前公司的一些事情。</p><p>我是在之前的公司开始接触区块链的，当时的项目号称自研区块链，也是用 VBFT（VRF + BFT）的共识，不过在共识方面不那么说，叫成 UBFT 还是什么。</p><p>我猜测 VRF + BFT 的主意是 Ontology 提出来的，我之前的公司把这种创意抄了过来，模仿着实现了一下。说来讽刺。</p><p>主要想说的是之前公司由于对 VRF + BFT 不靠谱的实现，引起的一个隐藏的 bug。那件事情距今快 2 年了，不记得当时为什么没有写博客记录一下，可能是在忙着做 PPT？昨天遇到共识相关的问题，我想起有那么一回事，正好现在有时间有心情写一下。由于过去时间太长了，细节上可能有出入。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>先介绍一下那个项目的情况，主打的特点有几个。</p><p>一个是异构多链，含义是可以在同一个节点上包含多条异构的链。异构是指一条链可以使用不同的共识机制、基于不同数据库运行起来。多链是指多条链可以在同一个节点上运行，因为觉得一条链不够用，一条链就相当于传统业务里的一张数据表，多条链可以方便地进行数据拆分，在联盟链的场景下更好地支持业务。异构多链，可以理解为把以太坊不同 chain id 的链，用同一个二进制包启动了。现在的某条开源联盟链，还在拿从异构多链演变来的灵活装配作为一大特点呢，猜猜为什么。</p><p>再一个是多数据库的支持，同时支持很多关系型数据库和非关系型数据库，做法是针对各种数据库，写数据操作的中间层做适配。</p><p>还有就是共识机制方面，基于开源的 Tendermint 项目。Tendermint core 是一个对 BFT 类共识的实现，在那个基础上，做的改动是把轮询选择提案节点，用 VRF 函数，替换为随机选择提案节点。另外还增加了对分层共识的支持，也就是共识组的概念，每隔多少个块换一次共识组，换共识组的方式借鉴 BFT 的流程，保证换共识组过程的安全性。分层共识这个理念也不知道起源于哪儿，可能同时期的项目流行这个？</p><p>项目的这些特点都是在我接触之前就已经开发完成的，我也只是有所了解。</p><p>我当时遇到的问题是，如果向区块链发送一笔失败交易，节点会立即返回交易失败的结果，然后如果再次发送一笔失败交易，第二笔交易的结果将迟迟不返回，节点不出块了。接下来如果仍然是失败交易，第三笔、第四笔，都会是同样的现象。这个时候，如果发送一笔正确的交易，节点会立即返回结果，之后一切恢复正常。而且这种现象是概率性出现的，并不是每一次失败交易都会引起问题。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>首先是失败交易指合约返回执行结果为失败的交易。区块链系统的交易失败有两种，一种是交易不能被执行，另一种是交易能被执行，但是合约中返回了合约层面的失败。那个项目并没有严格区分这两种失败的类型，合约有权限返回交易层面的失败，这其实是有问题的设计。</p><p>不正确的交易，将会在提案的时候，被忽略掉，因为不正确交易没有必要记录在区块链上。加上项目对失败交易错误的处理，造成的现象就是，合约执行失败的交易，会被忽略掉。这是前提。</p><p>BFT 共识的基础，是投两轮票，最终确定一个块。不管是什么 BFT，在前面加什么字母，不管通过多么复杂的流程决定出哪个节点提案、如何提案，不管对共识的效率做什么优化，是并行提案还是流水线共识什么的，只要是 BFT 类的共识，都是投票两轮。对两个阶段的命名可能不一样，不管是用 proposal 还是 prepare 来描述，都是那样一个过程。</p><p>BFT 的流程，是先有一个节点生成一个块，然后把这个块发送给其他节点，如果超过 2&#x2F;3 节点同意，会进行下一轮投票。第二轮投票如果超过 2&#x2F;3 节点同意，这个块就算确认下来了。两轮投票是理解 BFT 共识的关键。至于为什么投票两轮就可以达到 3f + 1 的容错效果、为什么至少要两轮，我也不知道。</p><p>忽略掉失败交易的操作，是在检查交易的过程中完成的。项目里有两次检查，共识前检查和共识后检查。有一些交易是没办法在共识前进行检查的，比如在合约里进行的写数据库操作，如果共识前就写库了，然后共识失败了，数据不就乱套了吗。所以只能共识后进行检查。这是第二个前提。</p><h3 id="第一笔失败交易"><a href="#第一笔失败交易" class="headerlink" title="第一笔失败交易"></a>第一笔失败交易</h3><p>我们根据 bug 的现象分析一下，第一笔失败交易的流程是正常的。一笔失败交易进来，在共识之前是不会检查出失败的，所以预提案的节点正常提出了一个块，分发给其他节点，进行第一轮投票。之后正常进行第二轮投票，在确认块的阶段，写入块之前，会进行共识之后的检查，检查过程中发现交易失败，并且这个块只包含这一笔交易，这个块就作废了，没出块。同时，其他节点也都会返回消息告诉提案节点，这个块没出来，这笔交易失败了。所以第一笔失败交易是正常返回结果的。</p><p>第二笔失败交易进来，按照同样的处理流程，一切都应该是正常的才对。因为即使是失败交易，即使是在确认块的阶段，如果检查失败了，也会广播处理结果给其他节点。整个协议中投票失败或者落块失败，都是用空消息表示。其他节点不会因为交易失败，就收不到消息苦苦等待超时。那么既然 BFT 协议的流程没有问题，为什么还是出现 bug？</p><p>这个时候要提到项目在 VRF 方面的改造。</p><p>在 BFT 的协议中，是需要一个节点去生成一个块，分发给其他节点开始进行第一轮投票的。那么由哪个节点来进行这个生成块的操作呢？总不能是同一个节点吧，那就太中心化了。Tendermint 的做法是依次进行，比如有 4 个节点，第一次节点 A，第二次节点 B，这样轮询。</p><p>VRF（Verfiable Random Function）做的事情，是改变依次选择节点的方式。因为如果按照顺序来，那很容易预测到下一轮要由哪个节点去生成块，顺序可以预测之后，就存在节点被贿赂、节点被攻击等安全隐患。VRF 的功能是参数相同结果一定相同，参数不同则结果随机。把块高度、投票的轮数作为参数，就可以很好地实现，每一个块都能由随机的节点来生成，无法预测。这个改动也是作为项目的一个亮点的。</p><p>不过 VRF 存在一个问题，既然是随机的，那就有一定可能，第一次随机到节点 A ，第二次也随机到节点 A，这样的概率还是不小的。如果节点 A 是恶意节点，然后由节点 A 连续两次生成块，会给网络带来一些负担，虽然不至于破坏网络，但也是一点小小的麻烦。所以项目为了解决这个问题，在 VRF 的基础上加了黑名单的机制。</p><p>如果上一轮是节点 A 生成块，就把节点 A 放到黑名单里。如果 VRF 的结果在黑名单里，就再 VRF 一次，避免重复选择相同的节点。</p><h3 id="第二笔失败交易"><a href="#第二笔失败交易" class="headerlink" title="第二笔失败交易"></a>第二笔失败交易</h3><h4 id="不返回结果"><a href="#不返回结果" class="headerlink" title="不返回结果"></a>不返回结果</h4><p>结合 VRF 和黑名单，再来看看第一笔失败交易发生了什么。节点 A 收到交易，会先把这笔交易广播给其他节点，然后打包成块进行投票的流程。此时节点 A 在黑名单里。投票失败后，节点 A 返回失败，并且这笔交易已经不在节点 A 的交易池里了，因为已经处理过了。</p><p>那么节点 B 呢？块里面的交易验证失败了，但是交易池里收到的交易还在，因为这笔交易还没有处理啊，处理的只是广播过来的块里面的交易。这个时候是不是应该把交易池里面的交易删掉？对，但是没删。所以造成一个问题，节点 B 被选作生成块的节点，把这笔交易打包了一下，广播了出去。这个块当然也是提案失败的。此时节点 A、节点 B 都在黑名单里。</p><p>以此类推，就这一笔交易，一轮下来，4 个节点全在 VRF 的黑名单里。但是对这笔交易结果的返回是没有影响的，因为交易结果在节点 A 的时候就已经返回了。</p><p>第二笔失败交易过来了，所有节点全在黑名单里，会发生什么？当然不能选不出节点，节点全在黑名单里，黑名单就失效了。VRF 的结果是哪个节点，就是哪个节点。</p><p>分析一下第二笔失败交易。同样是节点 A 收到交易，假如这一次是节点 B 负责生成块，然后这个块验证失败了，节点 B 就会删掉这笔交易，对吧，这个没问题。</p><p>注意，删掉交易的同时，通知客户端，交易失败了，返回交易结果。节点 B 被选中，节点 B 生成块，节点 B 返回通知。但提交这笔交易的客户端，连的是节点 A 啊！</p><p>第一笔失败交易为什么会收到响应？因为黑名单还没有失效，所有节点都处理了一遍交易，所有节点都返回了一遍交易结果。现在黑名单失效了，只有节点 B 会返回结果，所以节点 A 的客户端收不到交易结果。</p><p>那为什么黑名单失效，就不能像第一笔交易一样，所有节点都处理一遍？</p><h4 id="阻塞后续交易"><a href="#阻塞后续交易" class="headerlink" title="阻塞后续交易"></a>阻塞后续交易</h4><p>接着分析一下第二笔失败交易，节点 C 还有交易啊，节点 C 上面的这笔失败交易还没处理呢，节点 C 就开始用 VRF 选节点了。</p><p>刚才提到，此时黑名单失效，VRF 选出哪个就是哪个。刚才选出了节点 B，这一轮有没有可能再选一次节点 B？黑名单失效，就变得可能了。这个时候如果又是节点 B 负责生成块，会发生什么？</p><p>节点 B 生成不了块，因为节点 B 已经没有交易了，它已经把唯一的失败交易，在上一轮就删掉了。也就是说，在新一轮的共识过程中，4 个节点全部在等节点 B 生成块，节点 B 自己也知道该自己了，但是节点 B 拿不出块，节点 B 直接放弃这一轮共识，进入下一轮，并且节点 B 没有发出任何消息。</p><p>在分布式系统中，没有消息是一件可怕的事情。其他节点都在等节点 B 呢，节点 B 自己玩了。这个时候，节点 B 的轮数要比其他节点快一轮。</p><p>在 BFT 共识中，有两个索引值，一个是块高度，一个是共识的轮数。同一个块高度，有可能因为块没确认，就经过很多轮共识。由于节点 B 自己没生成块，轮数增加了，其他节点还不知道。</p><p>现在，所有节点都在 VRF 的黑名单里，节点 B 的共识轮数高于其他节点，</p><p>如果节点 A 再收到失败交易，有两种情况。一种情况是 VRF 又选中节点 B 了，节点 B 提出的块会被拒绝，因为其他节点还在等节点 B 上上轮的块，它拿出了高轮数的块，是对不上的。另一种情况是，VRF 选中了其他节点，那其他节点首先要等节点 B 上上轮的出块超时。超时之后，其他节点把轮数最高的数值同步一下，共识就算恢复正常了，然后 VRF 再选。</p><p>但是注意，这可是一笔失败交易，此时黑名单仍然失效，即使共识恢复正常，也还是有概率重蹈整个覆辙，节点 A 仍然收不到交易结果。至于具体的概率是多少，就懒得算了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，这个 bug 是由很多系统性的不合理设计共同造成的，直接原因在于 VRF 黑名单的失效，因为所有节点都在黑名单里了。或者说，黑名单没有及时清空，原先的错误之处在于，只有在块高度变化的时候才清空黑名单，可能是认为每个块的产生都应该由不同的节点来处理。这种想法的失误在于忽略了相同块高度的时候，共识的轮数也会发生变化，每一轮都会产生一个新的块。所以只要在共识轮数发生变化的时候，也清一下黑名单就好了。实际的代码改动只有两行。</p><p>上面写的东西，可能我自己也不想仔细去看，不好理解、抽象，而且文字的表达能力也弱，看起来费劲。这种类似状态机状态转换的文字描述，看起来是很痛苦的事情。尤其是内容和当时项目的耦合很深。总的来说，对于这个问题的分析和解决，我认为在逻辑上是自治的，能很好的解释成因和现象，以及用最简单的方式在表面上修复它。</p><p>时隔近 2 年的时间，我竟然还能记起来这些，感觉也是很奇怪。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;昨天遇到一个问题，是 Ontology 的节点不出块了。节点使用的是 VBFT</summary>
        
      
    
    
    
    
    <category term="BFT" scheme="https://smallyu.net/tags/BFT/"/>
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>一年的工作回顾</title>
    <link href="https://smallyu.net/2022/08/27/%E4%B8%80%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE/"/>
    <id>https://smallyu.net/2022/08/27/%E4%B8%80%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE/</id>
    <published>2022-08-27T03:17:16.000Z</published>
    <updated>2024-08-03T19:07:09.975Z</updated>
    
    <content type="html"><![CDATA[<p>来到公司一年多了，想要简单做一点阶段性的回顾，因为平时会把大致的工作内容记录在内部的 Confluence 上，所以总结起来会有据可循。</p><p>一年的时间内发生了很多事情，我交到了一个很好的朋友，也因此在工作上不是那么专心，相比以前不管是工作效率还是用心程度都大打折扣。不过总的来看仍然有很大收获。</p><h3 id="State-channels"><a href="#State-channels" class="headerlink" title="State channels"></a>State channels</h3><p>来到公司的第一个月主要是熟悉项目，这个项目比之前公司的项目规模大很多很多，功能上相当于整合了 Filecoin、IPFS、Raiden Network、Ontology 等公链项目，还自己实现了类似于 libp2p 的网络模块和网络代理。一开始看起来还是有点吃力的，一方面因为代码体量大，另一方面因为确实不了解公链，虽然知道区块链本身的技术模块，但不知道什么是 Layer 2、IPFS、PoC。第一个月把项目搭建运行起来，了解了上传下载的基本流程，主要看了 p2p 网络在协议层面的交互实现，第一次知道了 DHT 是什么意思。</p><p>第二个月除了深入熟悉代码细节外，做了一件事情就是把 State channels 中的路由查找从 DFS 换成了 Dijkstra 算法。项目里有一个类似于 Raiden Network 的 Layer 2，用来解决文件下载过程中要对其他节点频繁支付的问题。改路由查找是因为这个部分相对独立，不会给整个项目带来麻烦，至于 Dijkstra 算法可以考虑路径长度做出选择而 DFS 不能，这点优化其实没有意义，因为我们 DNS 节点不会那么多，这个和 Raiden Network 完全 P2P 的模式是不一样的。</p><p>后来两个月也就是第三、四个月，主要做的事情是在 State channels 中增加手续费，在中转节点上扣掉一部分转账金额。那是一个痛苦的过程，因为我当时不懂 Layer 2 也不懂 State channels。好在用了两个月的时间还是把协议搞明白了，由于项目场景的限制不能由发起转账的节点直接验证交易，引起一些 channel 状态不稳定的情况，不过无伤大雅。</p><p>进入公司后我几乎没有请教同事关于项目的情况，不管是项目的整体架构还是具体的代码细节，全部是自己去看代码、查文档，尤其是要面对很多自己完全不了解的概念，这样做当然是有意而为之。全部自己折腾效率低是理所当然的事情，不过好处就是，在那个过程之后我可以有足够的信心，仅凭自己的实力就可以搞明白那样规模的项目，完成该做的事情。</p><p>因为我是第一次跳槽，我对自己的能力是疑惑的，不知道在之前公司的感觉是错觉还是事实，我觉得之前公司的项目不行、技术也不行，而且跳槽是有工资的增长，我多少有点心虚，想知道在进入一家新的公司后，我能不能够称职地独立应付起这样的项目，有没有实力对得起工资。请教同事是多么简单的事情！在之前的公司我也受到了很多关照，不过我希望自己有独当一面的能力，这正好是个机会，必须不依赖外部帮助去解决问题了。</p><h3 id="Solidity-合约"><a href="#Solidity-合约" class="headerlink" title="Solidity 合约"></a>Solidity 合约</h3><p>第五个月，我在纠结 Layer 2 该往什么方向优化，有点难以下手，正准备解决性能低下的问题，但也没有思路。后来得到一个需求是把项目里的原生合约用 Solidity 写一遍，因为后续有想支持 EVM 的计划。当时我不了解以太坊也不了解 Solidity，花了大概一周时间看 Solidity 文档。</p><p>第六个月也就是今年一月份，用 Solidity 重写合约，那其实是一段愉快的时间，因为不太需要思考做什么、怎么做，照着现成的写就行，产出的代码量还大。只是用不同的编程语言，你知道的，换编程语言没什么压力。</p><p>第七个月今年二月份，在节点的 SDK 中加入对以太坊 SDK 的支持。折腾了一下以太坊的测试网发现不太好用，最后还是先用节点的开发模式了。</p><p>Solidity 虽然语法容易理解，但是由于 EVM 的限制，也有很多需要注意的问题，以及很多语言上的细节需要时间不断熟悉，当时用一个月写完合约，后面却断断续续用了不少时间去修改完善。总之在那个过程里，那个需求上，我学会了写 Solidity 合约，熟悉了以太坊智能合约的开发，尽管对于生产级别的合约安全问题还缺少经验。</p><h3 id="文件夹上传下载"><a href="#文件夹上传下载" class="headerlink" title="文件夹上传下载"></a>文件夹上传下载</h3><p>今年三月份开始，做的一件事情是文件夹的上传下载。这个想法的起点是项目对 Git 的支持，想要支持 Git 协议，能够直接用 git 命令克隆 Git 仓库，结果发现普通文件夹的上传下载都没有，只有对文件的上传下载。</p><p>我们的项目用了一部分 IPFS 的 IPLD 协议，把文件转换成块进行传输，但是没有用 IPFS 的文件管理部分。IPFS 有一层针对文件系统操作的 API，可以统一处理文件和文件夹，数据结构之间还能方便地互相转化。我们是直接读取文件转化成块的，这也给文件夹上传下载的实现增加了难度。</p><p>这件事情一直断断续续持续至今，因为总是不断有各种各样的小问题出现，也感谢测试同事耐心的配合。文件夹的处理比单个文件复杂一点点，因为文件夹会存在无限的嵌套，文件夹内同时包含文件和文件夹，子文件夹内还会有文件和文件夹。以及其他问题像空文件夹、大文件的处理。</p><p>IPLD 节点储存在 Merkle DAG 的数据结构中，单个文件会生成一个 Merkle Tree，而文件夹需要做的是在上传的时候，把多个 Merkle Tree 组织起来成为同一个树，然后在下载的时候根据这个树反序列化成文件夹、把内容写入到磁盘上。</p><p>其实实现思路是简单的，这个树结构中有数据块 raw node 和用来做中间节点连接数据块的 proto node，只要把文件夹相关的额外信息写到 proto node 的 links 中，就可以把文件之间的关联信息储存传输到其他节点了。</p><p>不过在具体的实现过程中花了不少功夫，也绕了一些弯路，比如上传生成块的时候因为添加了额外的数据导致块数据验证不成功，不能生成完整的树结构，不得不深入到 IPLD 的代码里 debug；下载的时候对块数据的解析不熟悉，也没有意识到节点之间块数据的传输是没有顺序的，在功能不成功的时候一度怀疑整体思路出了问题。</p><p>由于块数据的传输是无序的，就需要在下载的时候自己整理块的顺序，排序过程中因为搞混了树的层序遍历和前序遍历，一开始深度优先生成顺序发现总是有几个块的位置错乱，debug 了好久才定位到问题改成广度优先。</p><p>这是一个无关紧要但是有意思的功能，在这个过程中加深了对文件的上传下载的了解。</p><h3 id="文件的非对称加密"><a href="#文件的非对称加密" class="headerlink" title="文件的非对称加密"></a>文件的非对称加密</h3><p>今年四五月份疫情严重，居家办公一个多月，做的事情是文件对非对称加密的支持，之前只支持 AES 的对称加密。</p><p>这个没太多可说的，就是要注意 ECDSA 是数字签名算法，没有加解密这回事，要用 ECIES 之类的混合模式，结合对称加密去实现对文件的非对称加解密。</p><h3 id="支持以太坊账户"><a href="#支持以太坊账户" class="headerlink" title="支持以太坊账户"></a>支持以太坊账户</h3><p>今年六七八月份，重点关注新 Layer 2 的方案，想要实现基于 Optimistic rollups 的 Layer 2。</p><p>Rollups 部分还没怎么动，目前停留在存储节点对以太坊账户的支持上。这一段不短的时间内，除了编译运行一下 Optimism 的项目、增加储存节点对多种网络模式的选项，还花了不少时间完善之前的 Solidity 合约、解决像合约大小超过限制需要拆分、节点真实运行过程中合约结果和预期不符等问题。</p><p>由于账户地址和公私钥都变成了另外一种格式，储存节点的协议消息也需要使用另外的签名方法，这些内容的改动都还在进行中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实没多少事情，但也没怎么闲着。不算太认真，但也收获很多。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;来到公司一年多了，想要简单做一点阶段性的回顾，因为平时会把大致的工作内容记录在内部的 Confluence</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>为什么要重视编程思想</title>
    <link href="https://smallyu.net/2022/07/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E8%A7%86%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <id>https://smallyu.net/2022/07/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E8%A7%86%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</id>
    <published>2022-07-24T14:53:55.000Z</published>
    <updated>2024-08-03T19:07:10.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>前两天遇到一个小问题，Solidity 写的智能合约超过 24 KB，不能部署到以太坊主网上，因为 EVM 对合约的代码小小有限制。于是考虑怎么减小合约的大小，当时对合约大小的概念都是模糊不清的。</p><p>其中注意到一个地方，合约是可以引入其他合约、调用其他合约方法的，只需要把部署后的合约地址作为参数传到合约里：</p><pre><code class="solidity">contract Demo &#123;&#125;contract Main &#123;    Demo demo;    constructor(Demo _demo) public &#123;        demo = _demo;    &#125;&#125;</code></pre><p>合约大小包括引入的合约吗？EVM 在执行合约的时候，会不会先把其他合约的代码也加载进来，然后一起运行？代码大小的计算要包括所有合约？那可就麻烦了。</p><p>后来注意到，可以使用接口替代合约：</p><pre><code class="solidity">contract IDemo &#123;&#125;contract Demo is IDemo &#123;&#125;contract Main &#123;    IDemo demo;    contract(IDemo _demo) public &#123;        demo = _demo;    &#125;&#125;</code></pre><p>接口的代码量一定是少于具体实现的，因为接口不包含方法体，把引入的合约全部替换成接口，合约不就小多了？</p><p>当然，在这里纠结的不是 Solidity 合约怎么写或者合约代码大小怎么计算的问题，后来搞清楚了。比较在意的是，那个时候突然有点恍惚，用接口和直接用合约，有什么区别？</p><p>之前给合约定义接口是为了提供一个对外方法的描述，这里才意识到接口可以替代合约本身，直接用来定义变量，并且使用接口定义的变量，去调用合约里面的方法。但为什么可以呢，它不就只是一个接口吗？</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>如果你刚学习过 Java，或者使用 Java 作为工作语言，一定会有哑然失笑的感觉，这个问题太幼稚了，这不就是多态吗？</p><p>上第一节 Java 的课程，老师就告诉我们，面向对象有三大特性，封装、继承、多态，这句话时至今日我都能想起来，这是多么基础的概念，结果在工作多年后的今天，我竟然在实际工作上因为如此简单的问题犯了难，一时没反应过来，用接口作为类型的写法是什么意思。这太荒唐了。可能也是因为很久没写 Java，现在一直在用 Golang。</p><p>不得不说 Java 是面向对象编程语言的标杆，Solidity 虽然是一种看似新的用于智能合约的脚本语言，揉杂了多种语言的特性，但基本的编程思想还是基于面向对象的。合约就是类，部署一个合约就是实例化了一个对象，合约地址就是对象的内存地址，合约调用就是对象的方法调用……</p><p>只要是支持面向对象的编程语言，就包含有面向对象的特性，就可以使用面向对象的写法，就离不开最基本的像多态一样的特性。从面向对象的角度去理解，Solidity 有什么难的呢？无非不就是换了一些表面上的形式，编程思路甚至可以一模一样，此外再添上一些区块链特有的概念，像转账、块高度之类，就没了。</p><p>从编程语言的角度看，Solidity 和 Java 那样成熟的语言自然没法比，面向对象的特性是残缺的，modifier、require 之类的写法看似好用却增加了很多理解成本，而且代码结构也变得不是太统一。EVM 怎么能和 JVM 相提并论呢？但作为一种轻量级的脚本语言，Solidity 又要使用静态类型那样冗余的写法。</p><p>当然要注意，编程思想是先于编程语言的，我仍然会认为形式上的编程语言<a href="http://smallyu.net/2022/02/16/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">不值得学习</a>，但是不否认从学习编程语言的角度入手去学习编程思想。比如<a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">多态</a>这个概念，含义是使用统一的符号去代表不同的类型，包括三种类型的解释，一是支持多种类型的参数，对应 Java 里方法的重载，二也是支持多种类型的参数，对应 Java 里的范型，三是子类型，也就是把接口作为类型，对应上面提到的场景中的多态的含义。</p><p>面向对象是一种编程思想，包含很多计算机科学的概念，而 Java 是一种完全的面向对象的编程语言，不但涵盖众多有用的特性，而且实现的完整漂亮，如果你学习了 Java，自然也就知道面向对象是怎么回事了，受用无尽。从这个角度看，和 Java 相比，Golang 有什么值得学习的地方吗？是 struct 的写法还是 * 号的用法？可能 Golang 更像是一种快餐式的语言吧，可以很方便地 go func()。不过要是为了学习，就不是太推荐了。</p><p>花了几分钟看 Java 文档的目录，倒是能很快想起来那些内容，毕竟实在是太基础了。也是要告诫自己，别忘了代码怎么写。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h3&gt;&lt;p&gt;前两天遇到一个小问题，Solidity 写的智能合约超过 24 KB，不能部署到以太坊主网上，因为 EVM</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>对 Web 3.0 的理解</title>
    <link href="https://smallyu.net/2022/06/19/%E5%AF%B9Web3.0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://smallyu.net/2022/06/19/%E5%AF%B9Web3.0%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2022-06-19T11:47:30.000Z</published>
    <updated>2024-08-03T19:07:10.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Web-3-0-开发"><a href="#Web-3-0-开发" class="headerlink" title="Web 3.0 开发"></a>Web 3.0 开发</h3><p>Web 3.0 是一个几年前就存在的概念，可能随着区块链的推广越来越有名了。当人们还不知道 3.0 版本的 Web 会是什么样子的时候，区块链出现了，尤其是以太坊的 dApp 提供了一种很大的可能性，于是 Web 3.0 就和区块链、去中心化、自我主权这些概念绑定在一起。</p><p>前几天<a href="https://smallyu.net/micro-blog/#2022-18">提到</a>说。「Web 3.0 开发」是可以作为一种职业定位去描述的，而且这个词可以涵盖区块链开发的范畴，立意比「区块链开发」这个描述高一点。</p><p>Web 2.0 时代，我们说的 Web 开发指普通的前后端开发，前端用所谓的三大框架 React.js、Vue.js、Angular.js 结合组件库，后端用 Spring 全家桶，加上各种中间件 Zookeeper、Kafka、Elasticsearch 之类，还有常用的数据库 MySQL、Oracle，就是 Web 开发的常用技术栈。</p><p>Web 3.0 开发的技术栈，可能会演进为 Remix、Hardhat、Ruffle 这些智能合约的开发工具和框架，人们像关注 Java 的语言特性一样去关注 Solidity，以及各种区块链节点的搭建运行调用、二次开发，甚至及区块链节点本身的开发等等。当然，很难简单地把这些技术栈去和 Web 2.0 一一对应。一个简单的例子是，当你从事区块链开发的工作，你已经很难用前端开发或者后端开发来形容自己的工作内容了，就只能是区块链开发，或者智能合约开发，或者其他的描述方式。</p><p>现在已经有一些岗位在用「web3 开发」的形容了，不过我们要区分清楚 Web 3.0 和 web3 不是一回事，目前很多岗位说的 web3 指以太坊的那个 web3 框架。我们需要一个新的描述，同时我们需要有一个更好的、更有前景的职业定位，那就是 Web 3.0 开发。</p><p>我这里想说的是，要相信我们走在正确的道路上。</p><h3 id="一级市场和二级市场"><a href="#一级市场和二级市场" class="headerlink" title="一级市场和二级市场"></a>一级市场和二级市场</h3><p>区块链的一级市场，指比特币、以太坊这种原生的链。二级市场更多是基于这些链，衍生出的一些项目，基于以太坊的项目尤其多，Layer 2、预言机、NFT、ENS，都属于二级市场。</p><p>有一些团队是做一级市场也就是区块链开发的，Solana、Filecoin、Neo 都是在以太坊之后出现的，Dfinity 的 IC 也是处于活跃的一种一级市场的例子，再比如像 Bitcoin SV 是在做 “支持智能合约的比特币” 这样的事情。</p><p>还有很多创业团队是在做二级市场，比如有从 360 出来的去做智能合约的安全，把合约扫描一遍报出安全漏洞给你；还有做 NFT 的交易协议，去定制一些类似 NFT 交易所的 API，想建立通用的交易网络；还有炒元宇宙概念的，给虚拟人物定制不同样式的衣服；也有基于 IC 做去中心化邮箱的等等。以太坊的各种扩容方案当然也算二级市场，OP 前段时间还发行 token 了。</p><p>从商业角度没有什么高下之分，从技术角度也不好说简单和难，不过我觉得还是一级市场更基础一些，但是技术上的发展相对缓慢，花样没那么多。具体倾向于哪一种看个人意愿了，这里想提醒的是，Web 3.0 开发是统称，要了解这些不同层级市场的区别。</p><h3 id="去中心化是历史的倒退"><a href="#去中心化是历史的倒退" class="headerlink" title="去中心化是历史的倒退"></a>去中心化是历史的倒退</h3><p>刚才说希望 Web 3.0 是有前景的方向，这个部分想说的是 Web 3.0 的前景也没有那么好。</p><p>想到这个话题是在关心钱包安全的时候，意识到一个问题，就是账户的私钥一旦泄露，你就永远失去了对账户资产的控制权，或者说别人永远拥有了你账户资产的控制权。</p><p>因为我们知道，账户地址是可以从私钥解码出来的，私钥就是你的资产，在备份钱包的时候，备份的就是私钥。你的私钥泄露，就相当于把金钱摆到别人手里，至于别人会不会及时拿走，你能不能在对方动手之前抢回来，那就是另外的问题了。</p><p>这个和传统的账户模型是不一样的，你不可能说你的用户密码是你的财产，因为中心化账户是基于 KYC 的，你只要能证明自己的身份，身份证或者指纹或者长相，都可以找回你的财产，因为财产是和你绑定在一起，而不是你的账户，你的账户密码是可以修改的，即使泄露，别人也只能在短时间内拥有你账户的控制权，你把密码改掉，别人就没办法了。</p><p>私钥是不可能更改的，你能做的，就是及时把资产转移到另外的私钥。去中心化的世界有意区分了身份和数字身份的概念，增加了数字身份的主权，但同时也削弱了身份对数字身份的控制能力。</p><p>这里衍生出的问题就是，去中心化的资产安全吗？把钱拿在自己手里，比把钱存到银行，更加安全吗？考虑到比特币诞生的背景，是出于对中心化机构的不信任，才有了去中心化的理念。</p><p>想想吧！一开始就是没有中心化机构的，人们以物换物，打一开始，就是去中心化的世界。后来为了降低个人保护自己财产的成本，为了增加对坏人作恶更有力的惩罚机制，人们共同组建起中心化机构，保护大部分人的利益。</p><p>现在炒作去中心化的理念，不正是一种历史的倒退吗？去中心化并非新产生的事物，而是早就已经存在的、被人们选择性抛弃的东西。</p><p>不过现在的去中心化和以前的去中心化，最大的不同就是现在的技术手段更为先进，有可能做到之前做不到的事情，把世界推到一种新的愿景上。但是也要注意现在的技术不是那么先进，还远没有发展到那种程度，区块链的技术瓶颈非常多。</p><p>所以我的观点是，现在的去中心化理念不是中心化世界的演进，而是中心化世界的补充。在接下来的时间，中心化和去中心化会同时存在。</p><p>要注意的是，去中心化不等于 Web 3.0，Web 3.0 是 Web 2.0 的演进，因为版本号增加了。Web 3.0 将是中心化和去中心化同时存在的时代。 </p><h3 id="LUNA-归零"><a href="#LUNA-归零" class="headerlink" title="LUNA 归零"></a>LUNA 归零</h3><p>前段时间有一件搞笑的事情，有一天，LUNA 的价格早上还是 80 美元一个，晚上的时候就跌到 1 美元一个了。在接下来的三四天，LUNA 的价格从 1 美元，跌到了 0.00001 美元。几天之内，近万倍的跌幅。曾经号称前十的加密货币，突然归零了。</p><p>我粗浅的理解是，UST 有一个交易池，当短时间有大量卖出的时候，交易池会有小幅的倾斜。当时先是小幅的波动，然后随着社交媒体的传播，大量散户失去了对 UST 的信任，开始大幅卖出，越卖价格越低。Terra 团队是有 5 万个比特币作为储备的，当时也及时打进去想把平衡拉回来，结果比特币也在跌，质押进去的比特币在结算的时候已经不值预期那么多钱了，没能把价格拉回来，后来 Terra 团队也放弃了，任由价格下跌。</p><p>LUNA 的事情发生后不久，看到有的人讨论说，LUNA 还有机会吗？有一种机会是，Terra 团队还有 20 亿，等 UST 的价格跌到总市值小于 20 亿的时候，Terra 团队可以把市场上所有 UST 都买下来，销毁掉多余的 UST，只留 20 亿个，UST 的价格就可以回到 1 美元了。不过 Terra 团队可能没打算那么做，后来发行了新的 LUNA。</p><p>LUNA 的失败不意味着算法稳定币的失败，有的团队也在研发新的算法稳定币，据说是想把美联储的运行模式，用算法模拟出来，正在写白皮书。</p><p>在 Web 3.0 宏大的时代背景下，LUNA 的事情就算是先行的笑料吧。</p><h3 id="Web5"><a href="#Web5" class="headerlink" title="Web5"></a>Web5</h3><p>最近新出一个 Web5 的概念，就是 Web 5.0 的意思。提出这个概念的人<a href="https://blog.web3labs.com/web5">说</a>，跳过 Web4 是因为 Web2 + Web3 &#x3D; Web5。好家伙，不愧是 Web5，提出 Web5 的能是一般人吗？但凡对软件工程有了解的敢这么说？</p><p>简而言之，我的结论是，Web5 一定不会成功。不管它叫 Web5 还是 Web6、Web7，它的理念还是围绕去中心化、SSI 那一套，还在我理解的 Web 3.0 的范畴之内。如果认真了解过 DIDs 的理念，就知道现阶段所谓的 Web5 完全是噱头了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;Web-3-0-开发&quot;&gt;&lt;a href=&quot;#Web-3-0-开发&quot; class=&quot;headerlink&quot; title=&quot;Web 3.0 开发&quot;&gt;&lt;/a&gt;Web 3.0 开发&lt;/h3&gt;&lt;p&gt;Web 3.0</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Web3" scheme="https://smallyu.net/tags/Web3/"/>
    
  </entry>
  
  <entry>
    <title>如何面对误解</title>
    <link href="https://smallyu.net/2022/04/21/%E5%A6%82%E4%BD%95%E9%9D%A2%E5%AF%B9%E8%AF%AF%E8%A7%A3/"/>
    <id>https://smallyu.net/2022/04/21/%E5%A6%82%E4%BD%95%E9%9D%A2%E5%AF%B9%E8%AF%AF%E8%A7%A3/</id>
    <published>2022-04-21T13:31:39.000Z</published>
    <updated>2024-08-18T05:04:15.940Z</updated>
    
    <content type="html"><![CDATA[<p>所有误解都来源于，用自己的思维方式，去理解别人的行为。</p><p>每个人都是独立的个体，善良、自由、快乐。</p><img src="1.png" width="80%"><p>每个人都有属于自己的世界观，那是在经历过曲折人生之后沉淀下来的，用以面对残酷世界和复杂人性的武器，也许像一面魔法镜，有丰富而神奇的魔力。</p><p>世界观给予每个人不同程度的理解能力，可以把别人的话在内心中翻译成，自己能够理解的含义。</p><img src="2.png" width="80%"><p>当你想要表达某种想法，你会将想法转换为语言，转换的过程由表达能力负责。你的魔法镜是红色的，你说出的话也是红色的，这句红色的话是善意的。</p><img src="3.png" width="80%"><p>经过一些媒介的传播，你的话会到达对方的位置。</p><img src="4.png" width="80%"><p>不幸的是，对方的魔法镜，是蓝色的。你理解这样的情况，因为很难要求每个人，都拥有和你一样的理解能力、一样颜色的魔法镜，这个世界本就是多姿多彩的。</p><p>所以很可惜，你红色的话，经由蓝色魔法镜的解析，被理解为了粉色的含义。红色是不带恶意的，但粉色，就包含了一些其他意味在里面，偏离了你原本要表达的心意。</p><img src="5.png" width="80%"><p>对方基于粉色的含义，用蓝色的话语回复了你。对方在回复你的时候，就已经有一些偏颇了，因为对方误解了你的意思。</p><img src="6.png" width="80%"><p>蓝色的内容也许没有恶意，也许带有一点恶意，总之会朝你飞来。</p><img src="7.png" width="80%"><p>再次不幸的是，你的魔法镜是红色的。对于对方蓝色的内容，你的魔法镜，会把它解析为黄色。</p><img src="8.png" width="80%"><p>这实在是加深了误解。原本赤红、纯蓝的两颗心，都感觉受到了不可原谅的伤害。对方怎么可以这样！</p><img src="9.png" width="80%"><p>久而久之，两个人的隔阂越来越大。</p><img src="10.png" width="80%"><p>作为聪颖的魔法师，你力图改变这种状况。经过自己的勤学苦练，你想办法拥有了蓝色的魔法镜。</p><img src="11.png" width="80%"><p>今后，当对方使用蓝色魔法镜和你交流。</p><img src="12.png" width="80%"><p>你可以拿出自己的蓝色魔法镜，来解析对方的内容。</p><img src="13.png" width="80%"><p>经过蓝色魔法镜的解析，对方善意的内容可以原封不动到达你的脑海里。</p><img src="14.png" width="80%"><p>你不会因此而受伤了。</p><img src="15.png" width="80%"><p>当然，你没有理由去要求别人，拥有和自己一样的红色魔法镜。这太难了，且不说别人愿不愿意，对方也不一定有足够的实力，驾驭你的红色魔法镜。</p><p>如果你想和对方沟通，只要拿出自己的蓝色魔法镜就可以了。</p><p>总而言之，就是让自己变得强大。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;所有误解都来源于，用自己的思维方式，去理解别人的行为。&lt;/p&gt;
&lt;p&gt;每个人都是独立的个体，善良、自由、快乐。&lt;/p&gt;
&lt;img src=&quot;1.png&quot;</summary>
        
      
    
    
    
    
    <category term="观点" scheme="https://smallyu.net/tags/%E8%A7%82%E7%82%B9/"/>
    
    <category term="梦想" scheme="https://smallyu.net/tags/%E6%A2%A6%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>之前公司存在的问题（2）</title>
    <link href="https://smallyu.net/2022/03/11/%E4%B9%8B%E5%89%8D%E5%85%AC%E5%8F%B8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98_2/"/>
    <id>https://smallyu.net/2022/03/11/%E4%B9%8B%E5%89%8D%E5%85%AC%E5%8F%B8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98_2/</id>
    <published>2022-03-11T10:58:39.000Z</published>
    <updated>2024-08-03T19:07:10.028Z</updated>
    
    <content type="html"><![CDATA[<p>最近<a href="/micro-blog/#2022-10">注意到</a>服务集成这个软件开发的领域，以及在这个方向上有所成就的<a href="https://coolshell.cn/articles/20765.html">创业公司</a>，同时看到有人来公司面试，偶然想起一些以前的事情，回想起我在上家公司的经历。之前文中没有具体说的是，部门的市场定位不清晰。当然造成那样的结果，有很多历史原因，公司一开始是有靠山的子公司，作为甲方立场很足，后来转变为乙方的形式，没有活跃在市场上的基因。这里只说结果。</p><p>如果部门的定位是拥有技术基础去自研产品，那么问题就很严重。</p><p>我在正式接手核心产品的开发后，发现项目的代码在工程上有凌乱不堪，不是代码乱，是没有顶层设计，没有明确的模块划分，没有清晰的目录结构，没有靠谱的软件设计。项目支持四五种数据库，然而数据库的配置方式竟然不统一，分散在不同配置文件的不同位置，哪儿生效哪儿不生效，哪个功能好使哪个功能不好使，要么靠经验，要么靠猜。API 的设计也很糟糕，我在《<a href="/2021/11/23/%E9%9A%8F%E6%83%B3/">随想</a>》中提到过关于 URL 参数的问题，另外 URL 的配置和参数的校验是写在单个的配置文件中，意味着如果在智能合约中想新增 URL，就需要改配置文件然后重启节点。至于配置规则的热加载，好像没有人关心。</p><p>智能合约的机制也有问题。交易在提交到合约后，交易的检查和执行分为两个步骤，检查函数的入参和出参都是 bitMap，必须要严格保证入参和出参的长度一致，否则节点就会 panic，因为外面是用循环处理的，会 out of index。问题在于，那可是智能合约，怎么会用那么生硬的写法。后来前面的人告诉我，写智能合约的原则就是，“绝对不能出错”，因为说是智能合约，其实是和项目耦合很深的功能模块，美其名曰系统合约，是底层链的开发人员去开发的，而不是交给用户使用。开发合约，就需要对底层链有足够的了解。当时的人似乎还对这种事情有一点自豪感，感觉像是，“我们能写，因为我们比较熟悉”，丝毫不认为那是一种功能的不健全，而认为是有门槛的 feature。听说本来是没有打算支持智能合约的，由于需要的不断扩张，就硬生生加上了。当时的某人还拿 leader 的某篇文章奉为真理，说，其实区块链也不一定需要智能合约，对那种和广义智能合约理念背道而驰的设计大加赞赏。</p><p>多写几个合约后，就会注意到每个合约的检查函数上，都会有一个判断交易是否为空指针的语句。本以为系统内部的函数调用，怎么会凭空出现空交易呢，经过复现和排查，发现在并发情况下，队列偶尔会出现异常，push 一批交易进去，pop 出来就有空交易了，这纯粹是数据结构的问题。然后虽然定位到问题，但没有去解决，因为大不了每次都在合约上写个判断，算是我偷懒。也不知道前面的人，还埋了多少隐性 bug 在里面。</p><p>当用合约处理业务的时候，就会发现数据库的读写性能会成为交易性能的瓶颈，比如 MySQL，而且存在一个我一直没想通的问题：合约里的检查函数，怎么判断交易是成功还是失败？因为合约是要针对业务去开发的。合约对交易的检查和执行，都是是在 BFT 共识的 commit 阶段，这个时候已经完成共识了，检查函数并不能去预执行数据库的写操作（如果合约依赖数据库的特性比如事务，区块链就没有意义了），难道要把所有有可能失败的场景全排除一遍？是语义层面的排除，还是执行层面的排除？即使能够枚举出异常，又会损耗多少性能？那可能会产生疑问，为什么不在共识前检查？共识前的检查也是有的，但不管在共识前还是共识后，对数据库的操作总量不会变，对性能的损耗不会变。（延伸思考：为什么公有链不存在这样的问题，联盟链存在。）</p><p>版本管理的混乱也是在工程方面的问题之一，甚至都没有人能说清楚，当前的版本号到底是多少，是 2.0 吗？配置文件里可还写的是 1.4，是 2.0.1 吗？仓库里可还有 2.0.3，但不知道是谁改的，有哪些变动。甚至主干代码中会出现用于测试的 case，有些需要异常场景测试的情况，比如在 BFT 共识过程中恶意投票，只能通过改代码的方式观察效果，结果那部分代码就保留在了项目中，可以通过配置启用。其他原因的代码冗余也存在，比如智能合约的公用接口，为了兼容 UTXO，就不得不增加对应的接口，但其他合约完全用不到那些，又不得不实现。</p><p>项目在技术方面是存在各种各样问题的，包括我之前解决的由于使用 VRF 导致共识在提案阶段黑名单失效的问题，都说明系统尤其是在比较核心的地方都不够完善，而重构项目的成本又非常高。项目存在的最大价值和意义，就是参加一个行业内知名的测试活动，测试通过后某机构会给企业颁发证书，以证明这个软件是合格的、有资质的、符合标准的。然后企业拿着这个证书就可以宣传、投标、卖钱。至于软件本身好不好，并不重要。我当时光看测试项还感觉没啥，都是一些对区块链的基本要求，能通过测试没什么大不了的。直到亲手操作后发现，测试过程中存在大量的困难，都是人为困难，由于之前开发人员的不专业、团队管理的松散，以及项目本身很多不合理的设计，加上文档和人员的流失，都大大增加了测试过程的准备难度。也许大家没有意识到，什么是有效的困难，才造成了一种项目很好的假象。</p><p>如果部门的定位是服务集成，提供解决方案和技术支持，也是不合格的。</p><p>除了区块链底层，部门还有 Bass、中间件、SDK、浏览器之类的项目，会涉及到 Kafka、Zoopeeper、Redis、普罗米修斯等组件，但用的很浅，本身技术含量低，整体上做的也不到位，没有产品、没有 UI、没有用户思维、没有 owner 意识，全是在有业务需求的情况下临时改进，结果每次都手忙脚乱，总是以优先应付客户为要务。服务集成的事情，可以简单也可以难，可以做好也容易做不好。然而部门另一方面又不太想做服务集成，比如在用 Hyperledger Fabric 做一些什么事情的时候，leader 就说：客户会问，你们底层用的 Fabric，只是拿来用，也没干什么呀，为什么要收钱？至少能体现出部门的定位有多混乱了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近&lt;a href=&quot;/micro-blog/#2022-10&quot;&gt;注意到&lt;/a&gt;服务集成这个软件开发的领域，以及在这个方向上有所成就的&lt;a</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="问题" scheme="https://smallyu.net/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>我为什么不学习编程语言</title>
    <link href="https://smallyu.net/2022/02/16/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <id>https://smallyu.net/2022/02/16/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</id>
    <published>2022-02-16T06:20:30.000Z</published>
    <updated>2024-08-03T19:07:10.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2021-06-27-原文"><a href="#2021-06-27-原文" class="headerlink" title="2021.06.27 原文"></a>2021.06.27 原文</h3><p>这里的 “编程语言” 特指编程语言具体的实现形式，而不是编程语言的设计思想或者语言特性。</p><ul><li>因为我早已知晓顶级编程语言专家的样子。</li><li>因为学习某种编程语言的某个特性，对我而言已经是手到擒来的事情。</li></ul><p>至少在短时间内，我会保持和坚持目前的观点和做法。</p><h3 id="2021-08-08-更新"><a href="#2021-08-08-更新" class="headerlink" title="2021.08.08 更新"></a>2021.08.08 更新</h3><p>昨天剧本杀，遇到一个 00 后的女学生，拼场来的，但同时也是那家店的兼职 DM。稍有感慨，自己 20 岁的时候在干嘛？</p><p>旧博客的链接一直挂在博客最下面，一般也不去看。稍微认真回忆了一下，感慨的事情先不管，我忽然明白，为什么我在毕业的时候会看不起同学的编程水平，为什么我刚参加工作的时候可以以至少平等的水平面对同事，为什么最近在面试过程中即使代码能力受到质疑我也不为所动，为什么现在我已经不屑于学习编程语言在形式上的那些东西。</p><p>站在国家图书馆的书架前，我忍不住回想起自己大学时候在图书馆里度过的日子。</p><h3 id="2021-08-29-更新"><a href="#2021-08-29-更新" class="headerlink" title="2021.08.29 更新"></a>2021.08.29 更新</h3><p>我又来补充这个问题了。 &#x2F;捂脸</p><p>在 QQ 空间上看到一个大学同学发的动态，是一个 Geek 风格的同学。最近的一条是「重学 Unix 高级编程」，上一条是「B 站上某技术会议的视频」。我曾经也尝试去找一些技术会议、meetup，后来发现除了演讲者本人受益，听众都是在陪跑而已，你不会真的指望从中学到什么。会议是一种圈子里面的事情。</p><p>对于 Unix 编程或者编程语言这样的东西，我心底是喜欢的，我能想象到，亲手写出一些命令按照自已的意愿达到预期效果，是一件多么原始的能让程序员开心的事情。如果我想学习这些内容，现在的我有足够可靠的信息源、足够有效和明确的方式方法，只要假以时日就可以足够全面系统地掌握这些内容以及其中的细节。</p><p>可是我总觉得，我应该关注更加「高级」、更加「上层」的东西，我甚至不知道这里的「高级」和「上层」是什么含义，但是我总觉得，我有更加重要的需要了解和掌握的内容，我不可以专门花费时间在这些东西上。</p><h3 id="2022-02-16-更新"><a href="#2022-02-16-更新" class="headerlink" title="2022.02.16 更新"></a>2022.02.16 更新</h3><p>最近在工作上遇到一个可能搞不定的问题。大体是需要把 Golang 的智能合约用 Solidity 写一遍，在以太坊上运行。其中有一部分内容是基于 Bulletproofs （零知识证明的一种）来实现文件完整性的证明。且不说 Solidity 语言的表达能力好不好实现 Bulletproofs，零知识证明一直是我的黑洞，用什么语言都不会写，而且源文件中存在 magic number，有一个二进制文件和 seed 列表暂时不知道来源是什么。</p><p>当然工作问题还是交给工作来解决。我只是由此想到一些问题，感到困惑。例如，什么样的人可以写出 Bulletproofs 的实现？我为什么不可以？差距在哪儿，有多大？Bulletproofs 的学习成本有多大，门槛有多高？</p><p>于是几天前我在一个聊天室问了一下，这个是我的发言（<a href="https://t.me/c/1711254099/593">https://t.me/c/1711254099/593</a>）：</p><blockquote><p>大家好，想借聊天室这个机会，请教一下大家的看法。</p><p>最近在了解零知识证明的时候，发现原理比较难理解。想要用代码实现像 bulletproofs 这样的系统（<a href="https://cathieyun.medium.com/building-on-bulletproofs-2faa58af0ba8">https://cathieyun.medium.com/building-on-bulletproofs-2faa58af0ba8</a> ），仅仅了解编程语言、会编程是不够的，需要一些其他方面（加密学）的前提知识。</p><p>由此想到，程序员的工作，或者设计一种软件、协议，很重要的是把编程的技能应用到各种领域中，对编程语言的掌握可能是最基础的技能。</p><p>《解密计算机科学》的文章中，最后提到文章已经包含了计算的全部内容。bulletproofs 的本质也是计算，但是要复杂更多吧。</p><p>所以我不确定这种看法：计算机科学其实位于比较 “基础” 的一层，研究编程语言是专业性很强的事情，并不适用于大多数人？即使编程技能很好，也还是需要花费很多时间去了解其他领域的。</p></blockquote><p>这是一个专门讨论编程语言的聊天室，所以发言中强调了编程语言的概念。紧接着有人回复道（<a href="https://t.me/c/1711254099/595">https://t.me/c/1711254099/595</a>）：</p><blockquote><p>我觉得不同的编程语言类似于钢铁、木材这种基础材料，我如果想做个凳子，简单了解下材质的用法特性就可以用木材制作一个，如果要做把刀，就需要用钢铁来进行制作，也很简单。如果我要做一个汽车底盘，就需要了解更多的钢铁材质特性和力学知识来进行制作。如果建造摩天大楼就需要学习建筑相关知识，再结合材质特性进行制作。计算机 + 音频知识 &#x3D; 数字音乐、计算机 + 图形学 + 设计知识 &#x3D; ps 等…</p></blockquote><p>他形象地比喻了编程语言和领域知识的关系。几天之后，另外一个人同意了我的说法（<a href="https://t.me/c/1711254099/757">https://t.me/c/1711254099/757</a>）：</p><blockquote><p>计算的定义，我想引用 yin 的博客：计算就是“机械化的信息处理”</p><p>编程语言就是一种表达“计算”的工具&#x2F;手段。用 sicp 的话来讲是 “capture how to knowledge”.</p><p>所以会用编程语言就可以表达 domain knowledge 了。而研究编程语言就是为了创造更好的工具（让表达力更强）。</p><blockquote><p>即使编程技能很好，也还是需要花费很多时间去了解其他领域的。</p></blockquote><p>很赞同</p></blockquote><p>总而言之就是，光会写代码是不够的！只了解编程语言是不够的！</p><h3 id="2022-03-05-更新"><a href="#2022-03-05-更新" class="headerlink" title="2022.03.05 更新"></a>2022.03.05 更新</h3><p>编程语言应该学习到什么程度呢？我的观点是，学习到可用的程度。对于不同的人，“可用” 有不一样的含义，需要自己掂量。</p><p>前几天看到一个关于 Personal development 的视频，YouTube 搜应该第一个就是，里面提到几句话，大概意思是，“当你寻找一份工作的时候，不要关心你会得到什么，而是关心你会成为什么（What you become）”。</p><p>如果你想成为编程语言专家，就竭尽全力研究编程语言。如果你想成为专精的资深开发者，就专研在自己岗位的技术方向上。如果你没有目标，或者志在别处，就降低对编程技能的要求，“不学习编程语言”。</p><p>所以最重要的问题还是，你想成为什么样的人？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;2021-06-27-原文&quot;&gt;&lt;a href=&quot;#2021-06-27-原文&quot; class=&quot;headerlink&quot; title=&quot;2021.06.27 原文&quot;&gt;&lt;/a&gt;2021.06.27 原文&lt;/h3&gt;&lt;p&gt;这里的 “编程语言”</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="学习" scheme="https://smallyu.net/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>中式英语</title>
    <link href="https://smallyu.net/2021/11/25/%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD/"/>
    <id>https://smallyu.net/2021/11/25/%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD/</id>
    <published>2021-11-25T13:50:59.000Z</published>
    <updated>2025-06-16T00:51:57.269Z</updated>
    
    <content type="html"><![CDATA[<p>最近注意到几个典型的中式英语的词汇：</p><ul><li>这本书里没有 magic，只是一些词法表达式的教程</li><li>这种做法太 low 了；那个方案太 low 了</li><li>我是不是 out 了</li></ul><p>这些都是中文句子里夹杂英文单词的例子，类似的现象很多，包括很多（国内的）影视剧、综艺节目都频繁出现。</p><p>问题在于，这些英文单词，在这些句子里面，怎么翻译？直译肯定是不能表达全部含义的（为什么？）。有一种悲哀的可能性就是，这样说话的人，英文不好，中文也不好，无法把中文全部替换为英文，也无法把英文全部替换为中文。</p><p>如果把中式英语也理解为一种语言的话，就属于第三种混合的语言了，不会英文的人无法理解，不会中文的人也无法理解。看到一个视频说，也许是段子，一个英国人在中国生活，回到英国后他和家人聊天，说 “这个太 low 了、那个太 low 了”。他的家人问他，“low” 是什么意思？他说，“low 就是 low ……”</p><p>语言的含义也会受到意识形态的影响。在国内的一些平台，很多中文词汇都打不出来了，但是并不影响人们理解在谈论什么。</p><p>有的人宣称自己有 “语言洁癖”，无法容忍中英混杂的句子，认为这是一种不干净的表达，应该用纯粹的中文或者英文。这样的人是有民族主义的嫌疑的。</p><p>无论是象形文字还是拉丁字母，都是人类用来表达自己想法的工具，都是人类社会在思想上达成共识的媒介。90 后的火星文字、00 后的拼音简写，都是属于一代人的集体记忆，同样属于一种另类形式的语言。</p><p>言尽其意就好。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近注意到几个典型的中式英语的词汇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这本书里没有 magic，只是一些词法表达式的教程&lt;/li&gt;
&lt;li&gt;这种做法太 low 了；那个方案太 low 了&lt;/li&gt;
&lt;li&gt;我是不是 out</summary>
        
      
    
    
    
    
    <category term="观点" scheme="https://smallyu.net/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>知识的诅咒</title>
    <link href="https://smallyu.net/2021/11/24/%E7%9F%A5%E8%AF%86%E7%9A%84%E8%AF%85%E5%92%92/"/>
    <id>https://smallyu.net/2021/11/24/%E7%9F%A5%E8%AF%86%E7%9A%84%E8%AF%85%E5%92%92/</id>
    <published>2021-11-24T14:19:55.000Z</published>
    <updated>2024-08-18T05:05:29.804Z</updated>
    
    <content type="html"><![CDATA[<p>一开始，每个人都是一个空的容器：</p><img src="1.png" width="20%"><p>随着经历的增长，容器内增添新的内容：</p><img src="2.png" width="20%"><p>并且会不断增加新的内容：</p><img src="3.png" width="20%"><p>当两个容器相遇，容器内装着不同的内容：</p><img src="4.png" width="40%"><p>两个容器会尽可能拿出内容相同的一面，产生关联，在某些问题上达成一致，并且形成更密切的关系：</p><img src="5.png" width="40%"><p>随着各自内容的继续增长，它们相同的一面占比由 1&#x2F;2 变为 1&#x2F;3，它们之间的联系变弱了：</p><img src="6.png" width="40%"><p>相同内容占比变为 1&#x2F;4 的时候，它们不再继续有联系：</p><img src="7.png" width="40%"><p>此时第三个容器出现了：</p><img src="8.png" width="60%"><p>最左边和中间的容器，相同之处占比为 2&#x2F;4 &#x3D; 1&#x2F;2，它们产生了联系：</p><img src="9.png" width="60%"><p>随着时间的继续增加和内容的继续增长，中间的节点获得了一些特殊的独一无二的内容，这个独特的内容是一个容器区别于其他容器的关键，俗称独立思考能力：</p><img src="10.png" width="70%"><p>这一部分特殊的内容不仅自己特殊，还会影响之前存在的已有的内容，将之前的内容变为更加丰富的、带有独立思考的内容：</p><img src="11.png" width="70%"><p>由于特殊内容对之前内容产生了干扰，混杂在之前的内容中，之前内容相同的占比已经降低，最左边容器和中间容器的关系变弱了：</p><img src="12.png" width="70%"><p>甚至再没有关联：</p><img src="13.png" width="70%"><p>最左边的容器，始终没有获得那样特殊的内容：</p><img src="14.png" width="70%"><p>直到有一天，最右边的节点获得了一些特殊的内容，只不过是三角形的：</p><img src="15.png" width="70%"><p>中间的容器和右边的容器无法达成一致：</p><img src="16.png" width="70%"><p>中间容器的内容没有停止增长，在有了特殊内容之后，再增添的内容也变成彩色了：</p><img src="17.png" width="70%"><p>中间的容器和左右两边的节点，都没有联系了，也难以再产生联系：</p><img src="18.png" width="70%"><p>中间的容器，只剩自己了，和一开始一样：</p><img src="19.png" width="70%"><p>中间容器的内容继续增长着：</p><img src="20.png" style="width:25%"><p>和其他容器一起，各自独立地继续累加内容：</p><img src="21.png" width="60%"><p>林林总总，花花绿绿：</p><img src="22.png" width="40%">]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;一开始，每个人都是一个空的容器：&lt;/p&gt;
&lt;img src=&quot;1.png&quot; width=&quot;20%&quot;&gt;

&lt;p&gt;随着经历的增长，容器内增添新的内容：&lt;/p&gt;
&lt;img src=&quot;2.png&quot; width=&quot;20%&quot;&gt;

&lt;p&gt;并且会不断增加新的内容：&lt;/p&gt;
&lt;img</summary>
        
      
    
    
    
    
    <category term="观点" scheme="https://smallyu.net/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>随想</title>
    <link href="https://smallyu.net/2021/11/23/%E9%9A%8F%E6%83%B3/"/>
    <id>https://smallyu.net/2021/11/23/%E9%9A%8F%E6%83%B3/</id>
    <published>2021-11-23T15:40:59.000Z</published>
    <updated>2024-08-03T19:07:10.129Z</updated>
    
    <content type="html"><![CDATA[<p>现在是凌晨快 1 点，睡不着，稍微写写。今天白天（昨天），测试提醒我，REST 接口的输入参数应该以大写字母开头。</p><p>我一开始还紧张了一下，我 out 了？我没有按照该有的规范开发？REST 接口的参数大写开头？（接口的 <code>Content-Type</code> 是 <code>application/json</code>）</p><p>然后就去查了一下 GitHub 的 API 文档，又看了一眼 DIDs (Decentralized Identifiers) 的标准文档，以及结合长时间接触使用 json 的经验，没有啊，json 的 key，哪有大写字母开头的习惯？</p><p>后来想到了一个吐血的原因，就问了一句，“参数首字母大写，是公司的规范吗？”。测试回复的原话是：</p><blockquote><p>我之前问过，就是你们开发自己都这么写，好像是，公有变量还是私有变量，就要首字母大写</p></blockquote><p>果然是。（微笑）</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>Java 里的权限修饰符是很基础的概念，用来控制类的访问权限，一共有 3 个关键词、4 种情况，比如 <code>public</code> 表示公开，<code>private</code> 表示私有：</p><pre><code class="Java">public class aaa &#123;    public int a;    private String b;&#125;</code></pre><p>具体内容可以参考 Java 的文档： <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">Controlling Access to Members of a Class</a></p><p>像 Python 那样的脚本语言本身没有访问权限控制的概念，所以约定俗成地认为以 <code>_</code> 开头命名的变量是私有的，不过没有代码层面的保护，只是命名上的区别。</p><pre><code>class aaa:    a = 1    _b = 2</code></pre><p>Pthon 里 <code>__</code> 开头的变量名可以达到代码层面私有变量的效果，但把 <code>__</code> 用做私有变量并不完全是 Python 的本意。参考 Pthon 的文档：<a href="https://docs.python.org/3/tutorial/classes.html#private-variables">9.6. Private Variables</a></p><p>众所周知，Golang 是一种奇葩的语言，不但要求你大括号必须写在函数名同一行，还会要求你必须做一些什么事情，比如，大写字母开头的变量意味着公开，小写字母开头的变量意味着私有。</p><p>Golang 对变量大小写的区分，可不仅仅是命名上的区别，而是代码层面的控制。下面的代码会输出什么？</p><pre><code class="Golang">func main() &#123;    a := struct &#123;        i int    &#125;&#123;        i: 1,    &#125;    s, _ := json.Marshal(a)    fmt.Println(string(s))&#125;</code></pre><p>当然是 <code>&#123;&#125;</code>，由于 <code>i</code> 是小写的，在 marshal 的时候自动忽略了。</p><p>这其实算是比较不正常的要求了。Golang 为了设计上的 “简洁”，很大程度上减少关键字、关键字复用，但是又不得不提供某些能力，就需要一些奇怪的方式做变通。 </p><p>我在上面的 Java 代码中，刻意用了小写的 <code>aaa</code> 做类名。Java 的类一般使用大写字母开头，但是不会在代码层面限制你把代码写成什么样子。</p><p>虽然我工作使用 Golang，但我不是它的教徒，当然，也不是其他语言的教徒。如果你仍然是某种语言的教徒，祝愿你可以尽早改变一下观念。</p><p>所以，由于 Golang 的一些 “特性”，为了在序列化的时候方便一点，项目的 REST 接口就习惯于使用大写字母开头的变量名作为 key 了。</p><p>睡觉了，明天再写。</p><h3 id="没有问题"><a href="#没有问题" class="headerlink" title="没有问题"></a>没有问题</h3><p>json 的 key 大写或者小写开头，其实都没有问题。输出参数为了省去写 <code>`json`</code> 的麻烦，就默认大写开头，所以输入参数也大写开头了。这是一种工程上的对称，并没有什么问题。</p><p>想起之前有一次，我把 REST 接口设计为，输入参数用驼峰命名 <code>myName</code>，输出参数用下划线分割 <code>my_name</code>。这样做的原因，是参数输入的时候，Java 的 Entity 能够把 POST Body 里驼峰命名的变量自动识别到对象上。返回参数时，程序直接把从数据库查出来的数据返回出去，是下划线形式的（不符合开发规范是真的）。这样做可以达到代码上的最简洁，但确实输入输出不对称不合适。</p><h3 id="一件事"><a href="#一件事" class="headerlink" title="一件事"></a>一件事</h3><p>如果只是这么点事，就不值得写什么了。昨天测试说我什么地方该怎么样做的时候，我想到另一件事，在之前的公司里发生的事。</p><p>URL 的输入参数有两种形式，一种是 <code>.com/?a=1&amp;b=2</code>，另一种是 <code>.com/:a/:b</code>。当时的项目里全是第二种形式，也就是路由形式的参数。</p><p>全部是第二种形式，有时候特别长，比如 <code>.com/:a/:b/:c/:d/:e</code>。参数很多时候是查询条件，如果中间的某个参数不需要作为条件，也就是不需要传参数，但是这种路由形式的参数又不能跳过中间的一段，就用了一种很奇葩的方式变通：<code>all</code>。用 <code>all</code> 来代替不需要传参的情况，<code>.com/:a/:b/all/:d/:e</code>。程序里面的判断也是各种离谱。</p><p>REST 接口本身是一种 Web 服务，但是如果缺少 Web 开发的基础，就容易做的有一些欠缺。</p><p>我当时怀疑开发那个项目的人技术水平有问题，也就是我当时名义上的小组长。好吧，也许是一段不怎么开心的往事。</p><p>顺便解释一下，我也不是有事没事就会对别人有意见。我当时所在的公司，有一种绩效的制度，每个季度开始前都需要写绩效计划，大概是接下来一段时间要做什么之类，一般是组长制定一个大方向上的目标，然后组员分配分别完成一些节点。我因为质疑他的水平，担心他制定的目标比较低，限制我的发挥，就借题发挥试探一下。对别人有意见对我自己没有任何好处，我也是出于一种恐惧，担心自己接下来会置于难以发挥的处境。</p><p>我当时并没有想离职，所以还是在极力想办法改善自己周围的环境和情况，给自己争取一个自己可以适应的状况。记得当时有其他同事离职的时候，（以前好像说过？好像说过，不记得了，再说一遍），我开玩笑说，工作中最开心的时候，可能就是提离职的时候和收到 offer 的时候了。同事说，最开心的时候是年底发奖金的时候……也是开玩笑。后来接着说，如果不是到没有办法的地步，不会有人愿意离职的。</p><p>我知道参数形式这种问题是小问题，但是我坚持认为，在当时的接口设计上，应该用参数形式的参数而不是路由形式的参数。参数形式的参数明明更好用，为什么不用？说说你的理由，我已经拿出了话题，还把话头递给了你，你说一说啊，你的理由，除了 “以前的人就是这么写的” 之外，你有没有其他的在技术方面的思考？能不能够在技术方面碾压我，以小见大，体现一下自己的技术能力？</p><p>我的基本观点是，他缺少 Web 开发的经验，不是认为路由形式的参数好用，而是完全不知道有参数形式的参数存在。我分析有两种可能，一种是他自己有实力，但是不轻易和我说，另一种就是自己没有实力。所以啊，我从一个很小的问题，制造了话题，给他说话的机会，甚至之后用比较强硬的态度在 leader 面前，表达了我对他能力的质疑。我心想，我都这么挑事了，要真有实力，总该表现出来了吧。</p><p>唉再之后就是一些收场环节了。</p><h3 id="设身处地"><a href="#设身处地" class="headerlink" title="设身处地"></a>设身处地</h3><p>我当时也想过，如果我是他，我会怎么办？</p><p>如果以后有小伙子那样对我，我能处理地比他更好吗？</p><p>如果有人质疑我的技术实力，或者揪着我的失误不放，借题发挥，我该怎么办？</p><p>我也知道，我好像破坏了一种和谐的宁静。</p><h3 id="然后呢"><a href="#然后呢" class="headerlink" title="然后呢"></a>然后呢</h3><p>现在的我，已经没有兴趣在类似那样的小问题上较真了，怎么样是对的，什么样是错的，有什么所谓呢。</p><p>不过过去的经历好像也是必要的。如果不是过去认真过，可能现在也还是会好奇：如果在一些问题上，我坚持自己的观点，或者非要争个对错，会是什么样的结果呢。</p><p>由于过去的经历，我已经知道是什么样的结果了。</p><p>其实结果不太好，也有点无聊。</p><p>我不太喜欢也并不期望是那样。</p><p>暂时没有然后了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;现在是凌晨快 1 点，睡不着，稍微写写。今天白天（昨天），测试提醒我，REST 接口的输入参数应该以大写字母开头。&lt;/p&gt;
&lt;p&gt;我一开始还紧张了一下，我 out 了？我没有按照该有的规范开发？REST 接口的参数大写开头？（接口的</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>GitBook 好用吗？</title>
    <link href="https://smallyu.net/2021/11/21/GitBook%E5%A5%BD%E7%94%A8%E5%90%97%EF%BC%9F/"/>
    <id>https://smallyu.net/2021/11/21/GitBook%E5%A5%BD%E7%94%A8%E5%90%97%EF%BC%9F/</id>
    <published>2021-11-21T06:21:20.000Z</published>
    <updated>2024-08-16T09:26:39.649Z</updated>
    
    <content type="html"><![CDATA[<p>10 月 15 日，我写下<a href="https://smallyu.net/micro-blog/#2021-84">一句话</a>：</p><blockquote><p>用 cloudflare cloud 的 DNS，把子域名 gub 从原来 CNAME 到 gitbook 改为指向到 github，到现在已经超过 72 小时，开启 DNS proxy 的情况下依然跳转到 gitbook，看样子是一个 302 forward。</p><p>不是 cacheing 的问题，已经很多次打开 dev mode 并且 purge 所有内容了。猜测 cloudflare cloud proxy 服务对于 forward 记录的更新非常慢，甚至有 bug。现在经过的时长一定超过 TTL 了。</p></blockquote><p>一个月过去了，问题无意间得到了解决。想展开详细描述一下我遇到的问题。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>这里会涉及到两个概念，DNS（Domain Name System）和 CDN（Content Delivery Network）。如果你不太接触 Web service 领域，可以先了解一下它们的联系和区别。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一开始的时候，我计划写一本开源书，选择 GitBook 作为写作平台。GitBook 名声在外，又有 GitbookIO&#x2F;gitbook 那样广为人知的开源渲染工具，是开源书的不二选择。经过短暂的试用后，在平台的使用上没有感觉到异常。我创建了 Workspace，然后在 GitHub 上新建仓库，把仓库关联到 GitBook 上，一切都很顺利。我简单测试了一下 GitBook 和 GitHub 自动同步的能力，有可能会出现一点点冲突，但还是容易解决的。</p><p>我在 GitBook 上绑定了自定义的域名。<code>smallyu.net</code> 这个域名托管在 Cloudflare 上，子域名 <code>gub.smallyu.net</code> 也是在 Cloudflare 上设置 DNS 记录。全世界都知道，Cloudflare 会提供免费的 CDN 服务，只要在 DNS 记录上打开 Proxy 的橙色按钮开关就可以了：</p><img src="1.png"><p>当时在解析到 GitBook 的时候，开关是打开的。之后没几天，正好遇到了 GitBook 改版大升级，写作界面完全改变了。改版后一两天，我想要更新一些页面的内容，发现改版后的 GitBook 操作流程反直觉、bug 满天飞，每次修改都相当于 Git的 Pull Request，而且每次点编辑按钮，都会新增一个 Pull Request 的条目。当同时存在多个 Pull Request 记录时，页面状态会完全不可控，这个是 1、那个是 2、另一个是 3，还不能增量合并，因为你无法区分两个 PR 之间，一些内容是没修改过还是被删除了。重点在于，PR 没有删除选项，稍微有点强迫症都受不了。网速不好的时候，多刷新两下编辑页面，草稿箱就会多出好几个 PR 的条目，还不知道哪个是刚刚修改的。包括一些其他使用体验上的小问题，当时我还吐槽说：</p><blockquote><p>现在 gitbook 的在线编辑难用过头了，不能删除 commit，不能新建文档，光标会自动跳转……他们是怎么对用户负责的。</p></blockquote><p>后来决定放弃 GitBook，换成了 docsify，页面部署在 GitHub Pages 上，<code>sub.smallyu.net</code> 域名的解析也换到了 GitHub 上。更改 DNS 的解析记录后，发现解析没有生效（Cloudflare 上的 CDN Proxy 开着），访问 <a href="https://gub.smallyu.net/">https://gub.smallyu.net</a> 总是跳转到原来的 GitBook 页面上。</p><p>一开始怀疑是 DNS TTL 的问题，因为在 Proxied 的状态下，TTL 的值只能是 Auto。毕竟 Cloudflare 的 CDN 节点多，我的域名访问量又低，可能 DNS 记录更新比较慢。幸幸苦苦等了 3 天，这个时间足够长了，发现解析依然不生效，因为域名还是跳转到了旧的页面。</p><p><code>dig</code> 域名的记录，是这样的结果：</p><pre><code>gub.smallyu.net.300INA104.21.81.212gub.smallyu.net.300INA172.67.146.253</code></pre><p>此时域名是查不到 CNAME 记录的。对比之后，发现这就是 Cloudflare CDN 的 IP。域名已经解析到了 CDN 上，问题是 CDN 没有返回预期的新页面的内容。</p><p>然后偶然发现，把 CDN Proxy 关了，域名解析正常了，A 记录是 GitHub 的，CNAME 也是 GitHub 的，页面是新的。</p><p>是什么问题呢？Cloudflare 的 CDN 没有刷新内容。</p><p>Cloudflare 有一个 Caching 的配置，也提供了 Purge 的能力：</p><img src="2.png"><p>在点过很多次 Purge Everything 的按钮后，CDN 内容仍然没有刷新，即使打开其他人都说有效的开发者模式，也是徒劳：</p><img src="3.png"><p>包括自定义页面规则，不走任何缓存，也无济于事：</p><img src="4.png"><p>甚至为了让内容更新生效，我在 GitBook 上删除了原有的 Workspace，还注销了账号。仍然没有用。</p><p>之后就不了了之了，只要不开 Proxy，域名解析就是能用的。不过，我当时认为可能是 CDN 的 bug，也许 GitBook 用了 302 forward 之类的记录，CDN 不能正确刷新这种类型的记录。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>最近，在访问 <a href="https://gub.smallyu.net/">https://gub.smallyu.net</a> 的时候页面稍微卡顿了一下，想起这个页面是没有走 CDN 的，想到了 Cloudflare 上的这条不正常的 DNS 记录。顺手 Google 了一下相关问题，没想到这次找到了有用的信息。之前遇到问题的时候也在网上搜过，搜出来的全是更新缓存之类，这次却找到了不一样的内容。</p><p>Cloudflare 有一些 partners，这些 partners 有着控制 Cloudflare DNS 的权力，Cloudflare 的域名在解析到 GitBook 上后，CDN 的 DNS 就受 GitBook 控制了，在 Cloudflare 上的配置优先级低于 GitBook 上的配置。</p><p>相关问题的链接：</p><ul><li><a href="https://community.cloudflare.com/t/dns-subdomain-no-longer-works-nor-redirects-to-anything/240984/7">DNS subdomain no longer works nor redirects to anything</a></li><li><a href="https://community.cloudflare.com/t/subdomain-cname-does-not-update/280696/2">Subdomain CNAME does not update</a></li></ul><p>我发邮件给 GitBook Support：</p><img src="11.png"><p>没想到 GitBook Supoort 一天之内就回复并解决了问题：</p><img src="12.png"><p>经过测试，现在一些正常，确实是那样的原因。</p><h3 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h3><p>谁能想到，Cloudflare 如此广泛使用的服务提供商，会把域名在 CDN 上的解析权限交给 partners。</p><p>谁能想到，GitBook 的产品即使用户删除了 Workspace 注销了账户，在系统内的域名解析记录都不会被删除。</p><p>这件事情可以带来的启发是，我们应该从普通的用户思维转变为开发者思维。也许在某种观念的影响下，因为所谓 “官网”、“权威” 的概念，当使用一些平台的时候，我们习惯于首先质疑自己的使用方法和操作错误，却很少质疑平台的问题。即使明确是平台的问题，也不会优先试图联系平台方解决问题。从这个点其实可以发散出很多内容，以后有机会再展开。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>最后现在用 Rust 团队开发的 mdbook 了。GitBook 稍微有点过时、处于不怎么维护的状态。docsify 也有问题，docsify 更适合项目文档，除了样式不那么凸显文字外，页面和页面之前是没有关联的，没有上一页下一页的跳转链接，不太像是一本书。虽然 mdbook 的样式没有很时尚，但是功能齐全完整、编译速度能感受到的快，好用就行。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;10 月 15 日，我写下&lt;a href=&quot;https://smallyu.net/micro-blog/#2021-84&quot;&gt;一句话&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用 cloudflare cloud 的 DNS，把子域名 gub 从原来 CNAME</summary>
        
      
    
    
    
    
    <category term="工具" scheme="https://smallyu.net/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>我不太喜欢的一个人</title>
    <link href="https://smallyu.net/2021/11/12/%E6%88%91%E4%B8%8D%E5%A4%AA%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%BA/"/>
    <id>https://smallyu.net/2021/11/12/%E6%88%91%E4%B8%8D%E5%A4%AA%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%BA/</id>
    <published>2021-11-11T16:11:46.000Z</published>
    <updated>2024-08-03T19:07:10.105Z</updated>
    
    <content type="html"><![CDATA[<p>其实我不太了解那个人，只有非常少数的一点印象。</p><p>我实习的时候，正赶上政策压制，公司裁员，同一批的实习生走了一半，包括和我同部门另一个组的小伙伴。应该是当时的部门 leader 把简历给了其他部门，我就转到后来做区块链的部门了。</p><p>我到部门第一个见到的就是那个人，也是 leader。从对话内容看应该是看过我留在简历上的博客地址。之后我的工作就全部由小组长分配了，一开始做做网页，到后来做一些其他事情。</p><p>我毕业转正正式工作后不久，那个 leader 就离职了，去了一家初创公司当合伙人，那家公司目前在做开源的联盟链。也因此我不太看好那条开源联盟链的技术，甚至一开始感觉能在那个项目上看到一点点，我上家公司区块链产品的影子。也可能是联盟链都是那种样子。</p><p>在他离职的欢送仪式上，我记得他说过一些话，我不太喜欢那些话。</p><p><strong>“有些人下班到点就走，不加班，怎么提高自己？”</strong></p><p>好像还说他虽然走得早，但是回家也仍然在工作什么的。时间太久，记不清具体内容了，大概是那样的意思。当然不是冲我说，是对所有人说的，不是针对谁。</p><p>虽然我当时还年轻，加得动班，但是我完全不认同那样的混蛋逻辑。后来公司有段时间还要求 996，我完全能做到去得最早走得最晚，就差公司没床了。况且我上班的时候也挺认真的，主要是简单，做网页什么的老本行了。而且，你怎么知道下班时间只有你在做有用的事情？</p><p><strong>“如果我创业不行了，希望大家能给我留个位置。”</strong></p><p>这话我是理解不了，走都走了，还想着后路。不过不幸的事实，“大家” 倒的比他的创业事业还快，不知道是不是因为他走了。</p><p><strong>“你们都不行！”</strong></p><p>饭局上，有人说，“你创业，把我们也带过去吧？” 然后他就说了这样的话。终于在离开的时候把心里话说出来了，哈哈。</p><p>后来就没什么了，总之感觉自己看到了一个经典的油腻大叔的形象。记得我喝了两杯白酒就开始头晕了。</p><p>再后来见面是一次部门团建，把他一起叫上了。他和部门 leader 比较熟。一起团建的还有另一个部门的 leader。</p><p>同样是在吃饭的时候，另一个部门的 leader 提到了落俗老套的问题，没什么人搭茬。然后话题就到了他创业的公司那边有没有女的，有女的给我们介绍一下之类。</p><p><strong>“有女的。（停顿一下）女博士！”</strong></p><p>这是和我价值观几乎相悖的一种言论。言外之意就是，博士嘛！你们呢？</p><p>在一个匿名的社区上，可以查到有人对他们公司的评价是，既有国企的腐朽文化，又有互联网公司加班、on-call 的优良传统。</p><p>有一次他们的产品发大版本直播，简直像是在谈笑风生，气氛松松垮垮，着装和环境都很 low。</p><p>在他离职创业的同年，他们公司开始做现在的项目，也可能稍后几个月的时间。反正到现在没多少时候，他们也没多少人，版本倒是发的老勤快了。当时还看到他发朋友圈说要打造国内最牛的区块链平台。</p><p>看看他们在其他直播会议上的演讲 PPT，最亮眼的就是列了一大堆指导单位和成员单位的一页。</p><p>之前偶尔有猎头联系我，说那个公司在招人。</p><p>由于这样一些特殊的原因，我可能永远也不会去或者说去不了人家那种高大上的有女博士的公司了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;其实我不太了解那个人，只有非常少数的一点印象。&lt;/p&gt;
&lt;p&gt;我实习的时候，正赶上政策压制，公司裁员，同一批的实习生走了一半，包括和我同部门另一个组的小伙伴。应该是当时的部门 leader</summary>
        
      
    
    
    
    
    <category term="观点" scheme="https://smallyu.net/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>一种区块链节点存储扩容的方式</title>
    <link href="https://smallyu.net/2021/11/10/%E4%B8%80%E7%A7%8D%E5%8C%BA%E5%9D%97%E9%93%BE%E8%8A%82%E7%82%B9%E5%AD%98%E5%82%A8%E6%89%A9%E5%AE%B9%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://smallyu.net/2021/11/10/%E4%B8%80%E7%A7%8D%E5%8C%BA%E5%9D%97%E9%93%BE%E8%8A%82%E7%82%B9%E5%AD%98%E5%82%A8%E6%89%A9%E5%AE%B9%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2021-11-10T14:25:28.000Z</published>
    <updated>2024-08-18T05:04:15.939Z</updated>
    
    <content type="html"><![CDATA[<p>区块链是天然支持水平扩容的系统，节点扩展能力首屈一指。</p><img src="1.png" width="50%"><p>但区块链的垂直扩展能力还是一个经常被讨论的课题。单个节点的硬盘容量总是有限，如果节点拥有全部的数据，对单机性能要求会比较高；如果节点没有全量数据，就不能认为是 P2P 网络的节点之一。</p><p>最直接的办法就是用分布式数据库，数据库本身就支持扩容，区块链节点的存储模块就也算是支持扩容了。（如果区块链在立场上和数据库没有冲突的话。）</p><p>这里描述一种简单的实现思路的设想。</p><p>节点的垂直扩展，是想用多个节点合力代替原有的一个节点的位置，整体形式上一个集群提供了和单个节点一样的输入输出。</p><img src="2.png" width="80%"><p>节点完全可以将块数据分散储存在不同的子节点上，比如按照数据库分库分表的经典思路，对块号取模，或者随机分发也行。</p><img src="3.png" width="50%"><p>节点可以区分为索引节点和存储节点，索引节点只记录块号和子节点的对应关系，子节点集群就作为索引节点的储存模块。索引节点同时负责发送和接收块等操作。除了网络延迟带来的存取速度的降低，似乎没有大碍。</p><p>对于节点类型的问题，是必须要有不只一种类型的节点吗？有没有办法实现只要一份源代码、只有一种二进制程序、只用一种类型的节点，就能实现所有的功能？当然，不是说把三种类型的节点打包到一起就行了。由于功能侧重点的不同，尤其是节点 “身份” 的不同，可能节点不得不区分类型。一个节点对外提供能力和一个集群合作对外提供能力，集群内的节点和单个节点应该是一样的地位吗？</p><p>将块数据分散开后，对于 “世界状态” 一类的数据，可以全部储存在索引节点上。</p><img src="4.png" width="50%"><p>如果状态数据也想扩容，同样可以只在索引节点上保留索引数据，然后将状态数据也分散到储存节点上。</p><img src="5.png" width="50%"><p>这样的方案也许过于简单了，万一行之有效呢。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;区块链是天然支持水平扩容的系统，节点扩展能力首屈一指。&lt;/p&gt;
&lt;img src=&quot;1.png&quot;</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>一种基于“自我中心主义”的共识机制</title>
    <link href="https://smallyu.net/2021/10/29/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E2%80%9C%E8%87%AA%E6%88%91%E4%B8%AD%E5%BF%83%E4%B8%BB%E4%B9%89%E2%80%9D%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    <id>https://smallyu.net/2021/10/29/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E2%80%9C%E8%87%AA%E6%88%91%E4%B8%AD%E5%BF%83%E4%B8%BB%E4%B9%89%E2%80%9D%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-29T14:28:52.000Z</published>
    <updated>2024-08-03T19:07:09.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>“自我中心主义” 的含义是，对于每个人来说，世界的大小取决于他能够接触到多大的世界，世界很大，和我无关，世界很小，全和我有关。一个人认识的人、了解的事、接收到的信息，无论是否命中注定，一定是有限的，你不可能认识世界上所有的人，知道世界上所有的事。才学渊博、见多识广，又怎样呢。</p><p>在区块链中，共识机制是用来保证数据一致性的关键手段，也给区块链带来了最核心的去中心化的特点。共识机制是强一致性的，或者是在拥有一定容错能力的情况下，达到大多数一致的效果。有没有一种可能，存在一种共识机制，不以数据一致为首要目标呢？</p><p>世界本就是复杂的，试图将所有节点同步到仅仅一种数据状态，其实是违反直觉的。而且，无论是不需要授权的大范围共识，还是基于身份授权的小范围共识，最终实现数据一致的方法，都是 “多点变单点”，也就是同一时间只有一个节点在处理数据，其他节点可能是在共识后接受满足条件的数据，也可能在确认数据前投票是否同意对数据的操作，总之都需要有一个 “英雄” 一样的节点，在关键的变更数据的时刻，做一些事情。</p><p>有的英雄实力强大，先斩后奏，改过数据后过来跟你说，“我改了数据”，你一开始不满意，但是接触后发现英雄确实厉害，能做出你没有解决的难题，于是你就认可了英雄的行动。</p><p>还有的英雄被公众授予权力，行动之前作为代表被选举出来，行动的时候会万分小心，挨个问民众，“改动这里的数据，你同意吗？” 如果大多数人同意，英雄就会行动。</p><p>当然，每个人都有平等地享有做英雄的机会，虽然有的人天生神力，有的人八面玲珑，但机会总还是有的，题放在那里，你做不出来，怪谁？每个人就可以被选举，别人不选你，怪谁？</p><p>所以，为什么我们不能做自己的英雄？为什么我们要屈就于别人的光环之下？每个人都是自己的英雄，在我们的世界里，在大小受限于个人接触范围的世界里。一种共识机制，节点的边界受限于其触及的网络规模。</p><h3 id="网络概况"><a href="#网络概况" class="headerlink" title="网络概况"></a>网络概况</h3><p>在非结构化的点对点网络中，路由表是必不可少的组成部分，节点能够接触到的网络大小，就取决于路由表中存着多少 “联系方式”。共识对数据的处理，就以路由表中的节点为依据，路由表中有 10 个节点，就争取和这 10 个节点达成一致，路由表中有 10,000 个节点，就和 10,000 个节点达成一致。也没有必要使用分布式路由表，就普通的数组就可以。在这种情况下，网络中的节点会是这种样子：</p><img src="21.png" width="40%"><p>以当前节点为中心，连接到的节点数量可多可少，有的很远，有的很近。弱水三千，只取一瓢。在路由发现的问题上，节点也是需要种子地址的，比如节点启动的时候先解析种子地址的记录：</p><pre><code>lookup(&quot;seek.domain&quot;)     -&gt; 127.0.0.1    -&gt; 127.0.0.2</code></pre><p>然后依次请求解析出来的节点地址，去得到他们路由表中的内容，将其添加到自己的路由表。这其实是常规做法，不过这样有可能引起的后果是，节点会瞬间获取到整个网络的路由信息。这并非不好，只是感觉有点快了，我们认识一个人是需要时间的，和人交谈也是需要时间的，你无法同时和三个人交谈，或者无法同时听三个人说话。即使拿到了很多人的联系方式，也没办法 “多线程” 联系每个人。我们处理信息的 “带宽” 有限，节点也一样。我们甚至可以对网络发现的速度稍微做一点限制，比如串行处理路由表新增记录的动作，先与节点建立连接然后再添加信息。</p><p>让路由发现慢一点，似乎听起来不太正常，难道是想让网络处于不同步的状态吗？很多共识的瓶颈就在网络带宽上，就在协议交互的复杂上。如果降低节点间的交流成本，共识的容错能力也会随之降低。网络可能会被划分为不同的区域，可能形成大大小小的圈子。</p><img src="22.png" width="50%"><p>对于共识算法来说，脑裂是要尽可能避免的问题，但其实网络分割是再正常不过的事情，是自然存在的情况。我们人类的思想是分裂的，有可能是对立的，但是经过一些事件后又可能达成一致。所以在一个网络中出现割裂是完全允许的情形，形成的小规模网络可能是互联互通开放的，也可能是保守封闭与外界隔离的。重点是要有一种机制能够 “修正” 这种分裂，也就是在某种条件下，割裂的两个网络可以相互合并。</p><h3 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h3><h4 id="主动"><a href="#主动" class="headerlink" title="主动"></a>主动</h4><p>这里保留区块链创世块的概念，所有节点的第一个块内容是相同的。新加入网络的节点，会从创世块开始启动，此时其他节点的块高度已经有很多了。比如当前节点的块高度是 2，想要从网络中同步第 3 个块高度的内容，节点的路由表中有其他节点的地址，其他节点块高度均等于 3。当前节点会发起一个对块高度 3 的请求，依次到其他节点。</p><img src="1.png" width="50%"><p>请求过后，发现有 2 个节点块高度为 3 的块一样，块的内容一样、块哈希一样、前块哈希也一样，那当前节点就把这个多数节点都存在的块作为第 3 个块。</p><img src="2.png" width="50%"><p>如果请求的时候发现有的节点的块高度已经大于 3 了，那么是不是应该块高度最高的优先呢？如果考虑时间尺度的话，就会觉得事物发展是需要遵次序的，你不能跳过 3 岁直接过起 4 岁的人生，区块链的数据也应该有先后次序。况且，当前节点需要的块高度是 3，请求的块高度是 3，管你有没有其他高度的块？你的块高度再高，我就要 3 的，你说你多高有什么用？</p><p>那么如果请求过所有节点，发现每个节点的块都不一样呢？该信谁？</p><img src="3.png" width="50%"><p>总得挑一个吧。如果不能确定哪个节点或者哪个内容可信的话，就随机选吧。最好是选择最后一个请求的节点，因为错过的节点就已经错过了，此时最后一个节点是距离你最近的节点，并且在此之前你并不能判断，是否存在块内容相同的节点。所以在放弃之前的节点后，最后一个节点就是你不可以放手的选择。</p><p>对于主动请求块数据的情况，很关键的地方是，请求一定是按照路由表顺序依次进行的，在得到第 1 个节点的响应之前，绝不向第 2 个节点发起请求，做人不能太三心二意了。如果有节点就刻意加速、同时请求多组数据呢？其实也无伤大雅，毕竟只是同步数据，有的人喜欢快点，有的人喜欢慢点，有的人喜欢快生活，有的人享受慢生活。</p><h4 id="被动"><a href="#被动" class="headerlink" title="被动"></a>被动</h4><p>除了主动请求某一高度的块数据，节点也会收到其他节点的广播消息，比如当前节点的块高度是 2，收到了来自其他节点的内容分别是 3、4、4 的块。</p><img src="4.png" width="50%"><p>按大多数一致的原则，是不是应该选择内容是 4 的块放在自己的第 3 个块高度上？但是这样存在一个问题是，你无法预测自己会收到多少个块，没办法计算块内容的总量和占比。所以对于被动接收的块，可以以第一个收到的块内容为准。</p><p>人生的出场顺序很重要，如果正好需要的块高度是 3，接收到广播的块高度也是 3，那就它吧，遇到哪个算哪个。实在不行后面遇到更合适的再换。如果有节点很激进，为了自己的块能够被大范围接受，把同一个块标记为从 1 到很大块高度广播出去，就为了碰运气，让正好缺块的节点接收，那也就随他吧。因为节点在主动同步块的时候，是按照高度获取内容的，这种激进一点的做法并不能带来很好的收益。</p><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>网络中的数据由谁产生？为了解决这个问题，可以先定义为，每个节点都可以产生数据。一种极端的情况是，每个人都只相信自己的数据，各玩各的，整个网络就变成单机版了。所以节点也需要将自己产生的数据散播出去，发送给其他节点。对于其他节点来说，就是 “被动同步数据” 的情况了。</p><h4 id="有节点需要"><a href="#有节点需要" class="headerlink" title="有节点需要"></a>有节点需要</h4><p>主动广播块数据分两种情况，一种是有节点正好需要块，你正好发送给他了。</p><img src="5.png" width="50%"><p>当前节点接收到内容的请求，新增了块高度为 4 的块，这时会直接把块持久化到主链上。接着开始对块高度为 4 的块进行广播，广播按照路由表依次进行，在广播结束之前，当前节点不会打包下一个块。广播开始后，有节点块高度为 3，说明你是第一个发送给他块高度 4 的节点，它一定会接收你的块，同时给你一个响应消息。在收到响应后你就可以知道，当前网络至少有一个节点接收了你的块，你可以继续处理下一个块了。当然，在路由表遍历结束之前，节点即使收到响应消息也不会停止这一轮广播，这是理所当然的，希望有更多节点可以接收块内容。</p><p>如果对方节点在收到块后，发现块内容是 5，前块哈希是 3，并不对应它自己的前块哈希 4，对方依然会接收这个块，并且依次替换自己之前的块，直到哈希一致。</p><img src="51.png" width="50%"><img src="52.png" width="50%"><p>这种机制有可能带来的风险是，接收到一个块，然后把整条链都替换掉了，这是非常严重的不能接受的开销。但确实存在这样的可能，你遇到了一个坏人，这个坏人乘虚而入，他的思想颠覆了你的人生观，让你误入歧途，六亲不认。倒是你需要反思一下，你的路由表里为什么会有这样的坏人。而且这样的坏人多吗？如果一个恶意节点用一个块替换了你的整条链，但是接下来会有很大概率有好人来把你的整条链置换到大多数一致的情况。</p><p>这里暴露出了一点问题，接收到第一个块就认可，是不是太草率了？如果是坏人怎么办？为了增加节点作恶的难度，在接收到块内容为 5 发现前块哈希对不上的时候，应该不止向第一条链请求块内容，而是走完整的 “主动同步数据” 的逻辑，根据块高度把路由表里的所有节点都请求一遍。如果块内容为 5 的块，前块哈希和大多数节点不一致，就直接把 5 抛弃掉。如果一致，就说明它不是有害内容。</p><h4 id="没有节点需要"><a href="#没有节点需要" class="headerlink" title="没有节点需要"></a>没有节点需要</h4><p>节点新增块后，可能遇到没有节点需要当前块高度的情况，</p><img src="6.png" width="50%"><p>其他节点的块高度都大于等于广播出去的块。这种时候，当前节点就有必要做一点点妥协，为了让别人接收自己，为了让其他节点接收自己的块数据，只好先从其他节点同步数据，和其他节点保持一致。</p><img src="7.png" width="50%"><p>在块高度为 4 的块上，当前节点广播了一圈发现没有节点愿意接收这个块，那当前节点就把最后一个访问的节点的，当前块高度的块，请求过来。为什么是最后一个请求的节点？这里也可以走一遍完整的 “主动同步数据” 的流程，但为了提高效率，减少网络交互，可以先随意接收一个块内容，再做后续的判断。选择最后一个节点，是因为离得近。在错过了万丈红尘纷纷扰扰之后，恍然回首，发现最后一个节点是你此时最亲近的伙伴。</p><img src="8.png" width="50%"><img src="9.png" width="50%"><p>收到最后一个节点的块内容是 7 的块后，当前节点继续广播块内容为 5 的块。</p><p>如果不幸遇到了其他节点的块高度都远高于自己的情况，那说明自己确实落后了，先把其他节点的内容都同步过来再说。想要创新，想要新增内容，至少要先到达某一种顶端，</p><img src="10.png" width="50%"><p>不一定是整个网络的顶端，至少是某种圈子的顶端。</p><h3 id="交换数据"><a href="#交换数据" class="headerlink" title="交换数据"></a>交换数据</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>在目前的机制下，网络可能是混乱、不同步的。虽然对数据同步的速度预设是慢的，但如果有的节点就喜欢快呢，用快的计算、大的网络带宽，就是要达到整个网络的最前沿。</p><img src="33.png" width="50%"><p>也就是大多数节点慢，少数节点快的情况。每个节点都是按照块高度平行更新内容的，也都是按照块高度广播内容的，在一定程度上会缓解这种问题。你想快就快，和我们没有关系，我们慢的自成一派，我们遵循大多数一致的原则，不是谁块高度高就听谁的。你想内卷就尽力去卷，我们不跟你玩。</p><img src="32.png" width="50%"><p>另一种是一半节点慢，一半节点快的情况，也没有什么好担心的，最坏就是形成两个网络，无关痛痒。</p><img src="31.png" width="50%"><p>至于少数节点慢，多数节点快，属于最正常的情况了。</p><h4 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h4><p>在一半节点慢，一个节点快的情况下，很容易造成这样数据对立的情况，即使块高度一致，也是两种数据。</p><img src="34.png" width="50%"><img src="35.png" width="50%"><p>这个时候就不得不有一方妥协了。如果两个网络想要融合，就必须有一方做出一些牺牲。在块高度一致的情况下，假设路由表互通，产生新的块数据后，其实就是 “主动广播数据” 的过程，当前节点先产生一个块：</p><img src="36.png" width="50%"><p>例如最后一个节点在收到块后，发现前块哈希和自己的对不上：</p><img src="37.png" width="50%"><p>就去其他节点请求上一个块高度的内容：</p><img src="38.png" width="50%"><img src="39.png" width="50%"><p>发现上上个块的哈希对不上：</p><img src="40.png" width="50%"><p>继续请求其他节点对应块高度的内容；</p><img src="41.png" width="50%"><img src="42.png" width="50%"><p>依次类推，直到整条链完全相同。</p><p>被替换掉的块内容可以放到一个缓存队列，作为新块的内容，继续向外广播，减少节点内容的丢失。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是一种没有经过实践考验的、也无法简单用公式来建模的共识机制的设想，共识以自身立场为出发点，关心自己如何应对网络中其他节点的不同行为，而不是从整个网络的角度 “上帝式” 地设计交互协议。这样的机制会给网络带来不确定性，但也会带来很多可能性。我们只能考虑节点基本的行为规则，就像我们学习生活规则一样，我们很难预测整个网络的走向，就像我们无法预测世界会向什么趋势发展。这种共识机制并不是而且也许不能解决特定的问题，比如建立电子现金系统或者提供图灵完备的运行平台，它关注在更基础一点的层面，提供一种实现数据一致性的方法和思路。</p><p>计算机通过网络组成的虚拟世界，一定也很精彩。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;“自我中心主义”</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="共识机制" scheme="https://smallyu.net/tags/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>你是……</title>
    <link href="https://smallyu.net/2021/10/02/%E4%BD%A0%E6%98%AF%E2%80%A6%E2%80%A6/"/>
    <id>https://smallyu.net/2021/10/02/%E4%BD%A0%E6%98%AF%E2%80%A6%E2%80%A6/</id>
    <published>2021-10-02T09:03:56.000Z</published>
    <updated>2025-06-16T00:24:42.594Z</updated>
    
    <content type="html"><![CDATA[<p>你是内战时期的军阀，伪装成屠杀了全村并抢劫了公主的强盗，押着公主到交流情报的酒馆，寻找生活在黑暗里的情报头子摩尔斯帮忙，想要找到军火的藏匿地图。你遇到了幼时有救命之恩的记者，遇到了追求公主至今的特务。他们笑里藏刀，想要抢走你的地位和朋友。最终你输了，死在血泊里，值得欣慰的是，她过的幸福。</p><p>你是年轻有钱的渣男，女友背叛你和兄弟约会，你背叛女友和同学约会，同学喜欢你的钱，女友也喜欢你的钱。最后你需要选择，新欢还是旧爱。无论哪种选择，都是凄惨的结局。</p><p>你是来自美国的富商，受邀参加一场神秘的宴会。宴会主人曾在十几年前犯下杀人罪行，宴会当天遭到复仇惨死密室。你作为警官调查这起案件，发现凶手精通易容术，来自美国的富商不是富商本人，发现外表纯洁的美女主播暗藏杀机，隐忍多年配合凶手完成报仇。</p><p>你是秦国公子扶苏，荆轲来进贡献上地图，胡亥受小人控制想要篡位，你想保住秦国的千秋大业。你的盟友毫不怀疑胡亥伪装的面目，输的理所当然。</p><p>你是身负血海深仇的日本警察。在警局办公系统数字化的过程中，很多罪犯利用关系伪造了自己的死亡。世界上没有人知道他们的存在，因为他们没有“身份”。你暗中搜查并一个接一个杀掉“身份干净”的人，他们才是真正的罪犯，因为司法机制的不健全，那帮愚蠢的警察总是无动于衷。你的妻子死于未成年罪犯之手，你怀孕的妻子一尸两命，被罪犯一刀一刀刺进肚子失血而死。你眼睁睁看着未成年的犯罪被释放。这个肮脏的司法系统，这个无能的侦查体系。你亲自动手，替上天惩罚早不该活在世界上的人。</p><p>你是龙族公子，你的爷爷是众神族长，由于其他族落的叛乱惨遭杀害。真的是叛乱吗？不是！你想起了前世收养你的爷爷，为了包庇你的军事起义，用脚印引导追捕你的军队走向错误的道路。你成为了雄霸一方势力的首领，才得知你的爷爷舍命为你争取的这个机会。你想起了前世的青梅竹马，由于地位悬殊，神妖殊途，你们的结合引发天谴降临。结婚当日，一半族人为你们的婚礼献祭。你想起了今世，原来族长为了避免悲剧发生，为了保护各族的孩子，走火入魔迷失了心智。三生石，三生路。</p><p>你是一味追求大学旧爱的男生，她受到你父母的干预无声息消失，你念念不忘。</p><p>你是一只妖怪，在怪谈中寻找自己的故事。</p><p>你是反叛军的首领。机器人占领星球，你带领强大的势力奋起反抗。后来发现你不是真正的你，你只是被覆盖了意识的克隆人，你的梦里出现了奇怪的画面，有雪山、有草地、有风、有散落满地的红色眼睛，你唯一的亲人其实是在苦苦寻找你的姐姐。</p><p>你是电话诈骗团伙的成员，负责选择合适的语音风格针对不同的目标进行下手。你是公交车祸里的受害者，伙同其他受害者一起，用诈骗的方式让当初事故的始作俑者受到惩罚。</p><p>你是小镇的猎魔人，配合小镇唯一的警官一起处理小镇上忽然疯掉的居民。原来你们都生存在计算机的世界里，主网服务器已经停机，你们是仅存的拥有完整建模的主机，病毒很快就会侵入这里。你的好兄弟警官勇敢地牺牲在和病毒的搏斗中。你面临选择，是毁掉这里让一切瞬间消失，还是带着渺茫的希望伙同伙伴们和机器战斗下去？</p><p>你是王朝的君主，鸟类神族的公主弃你而去，你征战多年，遇到一个很像公主的女孩，你隐约把她看成了梦中人的样子。多年后，你发现手上的伤口中残留着公主的神识，她没有忘记你，她一直在关心你，但是她不能背叛自己的种族。一边是自己深深想念的深明大义的公主，一边是陪伴自己多年的可爱的女孩。从前车马慢，一生只够爱一人。</p><p>你是班里的大哥。一场突如其来的灾难把你们压在倒塌的房屋废墟之下。古木低吟，你们得以重生在另一个世界。新的世界中，校园是黑色的，操场上的老奶奶面目苍白、肚子里的肠子还在对外淌血。教室里有很多带着面具的红头娃娃，睁眼看着你。树林里白色衣服的女人来回飘荡，手上是阴森的长指甲。你们齐心协力战胜恐怖的幽魂，世界重归于美好，正好是校庆日。生活回到正轨了吗？校庆日当天，你自杀身亡在舞台之上。地震了，只有你意识清醒，你为了让弟弟妹妹们勇敢起来面对今后的生活，许愿让古木将你们带到更加可怕的生活中，让他们一次又一次重复面对不堪的世界。</p><p>你是山神的孩子。那一年闹山鬼，你的父亲消失在对抗山鬼的战斗中。长大后，每个孩子都很忙，约定的每年的忌日，也没有人再关心。他只想看你们一眼，今年他买了可以延迟拍照的相机，终于可以把他自己拍进去了。人呢？没有人回来？那年森林火灾，你们的消防员父亲死在火灾之中，他一个人将你们 7 个孩子抚养长大。你们儿时晚上看到的油鬼，是他脸上绑着绷带面目全非不忍吓到你们的脸。他一直在默默关注和保护你们。</p><p>你是经常光顾青楼的公子。你和招牌艺妓青梅竹马、私定终身，却无疾而终。</p><p>你是有钱的大学生，有个人为了钱接近你，装作你的好朋友。他亲手杀了你喜欢的女生，拜月教献祭，是她死亡的表象。混杂着地下交易的地下组织，她终究没有逃脱那里。</p><p>你是星期一。从星期一到星期日，一人一天。你们是一个人，又不是一个人，你们的性格不同。你们被坏人关到地下室，一个好朋友救了你们。从被救的那天开始，你却察觉到异常，你真的是你吗？你希望七个人永远在一起，可其他人逐渐有了新朋友，只有你孤单一人。你们许下的生日愿望，都被躲藏在黑暗中的神秘人用奇怪的方式完成了。有人想要母亲的怀抱，神秘人就把母亲的尸体藏在沙发里，每次躺到沙发上，都可以感受到母亲的温暖。有人想要重见小时的朋友一面，神秘人就杀掉一个体型相仿的孩子，把照片贴在尸体脸上。对了，这个神秘人，儿时父亲和母亲吵架，他害怕自己被抛弃，在父亲自杀后，亲手用刀子割开了父亲的肚子，钻了进去。这个神秘人，就是把你从地下室解救出来的好朋友。</p><p>你是台湾原住民。荷兰军队进驻台湾，想要占领中国大陆。你一面作为明朝的卧底，在荷兰军官中深受赏识，一面想要团结台湾原住民们团结奋战，建立自己的军事政权。她是你唯一想念的人，你曾经落船漂流岛孤岛上，和一个自以为是的野蛮人共同生活十二年，从零开始种植作物、建造房子。他现在是荷兰军队的高级将领了。你不忍和他兵刃相见，可又必须将荷兰人赶出这片土地。没想到，决战当天，清朝军队、西班牙军队、飞翔的荷兰人号，都来了。</p><p>你是一个依靠作弊拥有傲人成绩的学生，你是一个商场得意却患有抑郁症的商人，你是一个在马戏团工作的小丑，你是一个商场失意的货车司机。你的父亲也许不理解你，高考当天你离家出走，逃离你熟悉的城市。第二天，你的父亲满脸疲倦，敲开你的房门。走！抑郁症也是病，咱们慢慢治！你以为会迎来一阵毒打，但收到一个充满愧疚的拥抱。</p><p>你是北欧之神奥丁诅咒的产物，你的祖先曾刺伤奥丁的一只眼睛。其他人看到你是白色的乌鸦，失心人看到你是正常的男孩。每当有白色乌鸦从蛋壳中诞生，当天会凭空多出不存在的第十三个小时，一切事物都停滞了，来自地狱的怪物会在此刻出现，肆意杀害方圆一公里的人类，夺走他们代表过去和未来的心脏和眼睛。被怪物杀害的人类会进入眼中世界，等待下次代表预言的第十三个小时出现，他们可以趁机再次回到人类世界，夺舍还处于存活状态人类的身体。你的姐姐，你唯一想念的人，唯一对你好的人，唯一想放你走的人。你咬断自己的一根手指，和怪物做交易，让他不要杀害你的姐姐。可是由于万一挑一的能够记住梦境内容的人出现，害你姐姐穿上了女仆的衣服，被怪物误杀。在这个世界上，你唯一挂念的人也离你而去。你本就是邪恶的产物，你的存在只会带来灾难。下一个诅咒之子，又是谁呢。</p><p>你是罪演师的候选人。你曾经是全国最优秀的刑侦警官，一同全来的还有你曾最欣赏的部下。神探仪的出现让刑侦警察显得可有可无，公安系统大规模减员，随之兴起的是配合神探仪定位真正凶手的职业罪演师。当年最优秀的罪演师团队六边形集体身亡，数次愚弄大众的逃脱者到底身在何方。</p><p>你是重点大学的毕业生，你是表妹的哥哥，今天替父母参加她的家长会。你的父母重男轻女，对自幼遭遇家庭变故的表妹并不上心。你的女朋友送妹妹一双皮鞋，不知道妹妹有多高兴。可是有一天你发现妹妹弄丢了他的皮鞋，穿着一双破破烂烂的鞋子回家。妹妹怕你生气，专程到你的房间里道歉。你对一切并没有什么感觉，直到收到学校妹妹身亡的消息。妹妹和其他同学一起，尸体被发现在悬崖的下面。你和其他家长一起分析妹妹和其他同学的日记，这么可爱的妹妹，这么可爱的同学们，全部遭遇混蛋老师的猥亵。更加可恶的是，你们没有任何证据指认凶手。你们只有用一生去弥补，自己对罪犯的无能为力。</p><p>你是……</p><p>你不想玩一场剧本杀，体验一次光怪陆离的奇异人生吗？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;你是内战时期的军阀，伪装成屠杀了全村并抢劫了公主的强盗，押着公主到交流情报的酒馆，寻找生活在黑暗里的情报头子摩尔斯帮忙，想要找到军火的藏匿地图。你遇到了幼时有救命之恩的记者，遇到了追求公主至今的特务。他们笑里藏刀，想要抢走你的地位和朋友。最终你输了，死在血泊里，值得欣慰的是</summary>
        
      
    
    
    
    
    <category term="剧本杀" scheme="https://smallyu.net/tags/%E5%89%A7%E6%9C%AC%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>『Ground-Up Blockchain』前言</title>
    <link href="https://smallyu.net/2021/10/02/Ground-Up-Blockchain-%E5%89%8D%E8%A8%80/"/>
    <id>https://smallyu.net/2021/10/02/Ground-Up-Blockchain-%E5%89%8D%E8%A8%80/</id>
    <published>2021-10-02T06:03:03.000Z</published>
    <updated>2024-08-03T19:07:09.967Z</updated>
    
    <content type="html"><![CDATA[<p>以前有过一个设想，假如一个普通程序员，愿意花费 5 年的时间专心学习和研究某一个技术框架，比如 <a href="https://spring.io/projects/spring-boot">Spring Boot</a>，5 年的时间足够了解这个框架的多数细节了，那么他在 5 年之后，可以凭借对 Spring Boot 足够深入的了解，写一本《Spring Boot 从入门到精通》之类的书没有问题吧。写出一本书可以带来什么？至少可以增加一些被认可的依据。“写书“的难度大吗？看看现在中文的技术类书籍，哪个不是电子垃圾？然而事实上，大多数 5 年以上工作经验的程序员都做不到“写书“这件事。即使写的难看，毕竟也是有，聊胜于无啊！为什么没有人写？</p><p>有多少书写着写着就变成了技术手册？大而全没有重点，有用的没用的全写进去。也许是本着对观众负责的态度，“我写的内容不一定有见地，至少全啊！“这样的逻辑类似于，消费者在买东西的时候，“这个功能我可以不用，但不能没有！“</p><p>我也想制造一些电子垃圾了，就像各种无聊的技术博客文章的集合。现在是 2021 年的国庆节假期，正好有时间可以思考一下这件事情。</p><p>书的内容会和 Blog 冲突吗？如果有有意思、值得写的东西，应该优先发到 Blog 上。好像也是，不过 Blog 上的内容更多是描述个人经历、表达态度和观点，一直都无法专注尤其是低质量的技术内容。Blog 的内容往往需要字斟句酌，可能最终看到的只有 100 个字，但实际上也许想了 1000 个字，思考好几天，然后去掉不合适的措辞、精简内容、明确清晰观点，剩下了少数简练但有用的内容。</p><p>书的内容会更随意一点，为了节省时间，也尽量避免对内容的反复修正。总得有一些新的事情做，这些事情总需要一个开始，你不能等所有材料都准备好了才下锅。如果以后有一天，我有足够写出有价值书的能力，可能就不想写了。</p><p>书名借鉴了 <em>Ground-up Computer Science</em>，我暂时没有更好的主意了。内容会聚焦在 Blockchain 上，这个应该没什么问题，这个方向的水很深，有足够的内容可以写。也不需要太多担心机会成本的问题，其他领域并没有更好的选择，</p><p>在用语上，可能会直接用一些简单的单词。因为经常出现的情况是，在阅读其他资料的时候看到了某个词并且留下了印象，然后就直接拿来用了，不希望刻意在头脑里翻译一下。比如，这本书的内容没有 magic，就是一些普通的技术大杂烩。</p><p>这件事情的周期可能会有点长，预计 1 ~ 2 年左右。希望在 2023 年年底之前，这本书的内容可以初步让自己满意，可以归档 0.9 版本。差的 0.1 用来勘误。</p><p>书里具体的内容以思路为主，我们从小就知道“画一条线 10000 美元“的故事，画一条线价值 1 美元，知道线画在哪儿 9999 美元。故事也许不是真的，但故事广为流传，侧面说明故事中的逻辑至少有道理。把代码写出来，远不如知道为什么要写，解决了什么问题，有没有更好的解决办法。</p><p>书的目录结构可能杂乱无章，因为不太希望按照结构化知识的方式组织内容，一方面不好操作，有些东西不好分类，另一方面，结构化组织内容的实际效果不一定好，反而会由于一味最求全面而忽略思路和细节。世界上没有“最全“的一个状态。内容可以是主题式、时间线式或者随心所欲的。</p><p>按照同样的逻辑，也很容易有 <em>Ground-Up Golang</em>、<em>Ground-Up Programming</em> 之类。Talk is cheap, just do it first.</p><p>预览地址：<a href="https://gub.smallyu.net/">https://gub.smallyu.net</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;以前有过一个设想，假如一个普通程序员，愿意花费 5 年的时间专心学习和研究某一个技术框架，比如 &lt;a href=&quot;https://spring.io/projects/spring-boot&quot;&gt;Spring Boot&lt;/a&gt;，5</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>联盟链比公有链差在哪儿</title>
    <link href="https://smallyu.net/2021/09/29/%E8%81%94%E7%9B%9F%E9%93%BE%E6%AF%94%E5%85%AC%E6%9C%89%E9%93%BE%E5%B7%AE%E5%9C%A8%E5%93%AA%E5%84%BF/"/>
    <id>https://smallyu.net/2021/09/29/%E8%81%94%E7%9B%9F%E9%93%BE%E6%AF%94%E5%85%AC%E6%9C%89%E9%93%BE%E5%B7%AE%E5%9C%A8%E5%93%AA%E5%84%BF/</id>
    <published>2021-09-29T06:27:43.000Z</published>
    <updated>2024-08-03T19:07:10.128Z</updated>
    
    <content type="html"><![CDATA[<p>中文语境下的 “公有链” 和 “联盟链” 并没有明确标准的定义。2018 年，美国国家标准与技术研究院（NIST, National Institute of Standards and Technology）在 <em><a href="http://vpb.smallyu.net/[Tech]%20blockchain/Blockchain%20Technology%20Overview%20-%20NIST.IR.8202.pdf">Blockchain Technology Overview</a></em> 中将区块链分为 Permissionless blockchain 和 Permissioned blockchain，但那样的分类方式并不严格对应公有链和联盟链。也许公有链和联盟链的区别在于节点网络规模的大小，也许区别在于区块链面向的范围是公共互联网还是私有局域网。无论是怎样的定义，我们至少可以大概区分出公有链和联盟链。</p><p>公有链和联盟链的好坏，不单纯在于技术或者某些评价指标的比较，也许会有人下意识地认为，公有链面对比联盟链更复杂的网络环境和用户体量，但其实技术上的差距总是有办法弥补，联盟链也有少数好于公有链的技术特性。</p><p>有一个段子《<a href="https://baike.baidu.com/item/%E7%9A%87%E5%B8%9D%E7%9A%84%E9%87%91%E9%8B%A4%E9%A0%AD/23725819">皇帝的金锄头</a>》：</p><blockquote><p>古代有两个老农民畅想皇帝的奢华生活，一个说：“我想皇帝肯定天天吃白面馍吃到饱！” 另一个说：“不止不止，我想皇帝肯定下地都用的金锄头！”</p></blockquote><p>联盟链就是在用区块链做传统行业的业务，甚至可以说是打着区块链的幌子到处骗钱。联盟链的问题就在于，格局小了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;中文语境下的 “公有链” 和 “联盟链” 并没有明确标准的定义。2018 年，美国国家标准与技术研究院（NIST, National Institute of Standards and Technology）在 &lt;em&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="公有链" scheme="https://smallyu.net/tags/%E5%85%AC%E6%9C%89%E9%93%BE/"/>
    
    <category term="联盟链" scheme="https://smallyu.net/tags/%E8%81%94%E7%9B%9F%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>享受你的生活</title>
    <link href="https://smallyu.net/2021/09/28/%E4%BA%AB%E5%8F%97%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    <id>https://smallyu.net/2021/09/28/%E4%BA%AB%E5%8F%97%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB/</id>
    <published>2021-09-28T10:39:30.000Z</published>
    <updated>2024-08-03T19:07:10.029Z</updated>
    
    <content type="html"><![CDATA[<p>我本可以有很多开心起来的理由，但总是因为一些不必要的目标让自己感到困扰。</p><p>我没有任何理由因为工作不相关的人和事情，放弃自己感兴趣的职业和技术方向。</p><p>我不想再花费时间关心自己不需要关心的问题，我有很多感兴趣的事情还没有做。</p><p>我为什么不优先关注自己的事情？</p><br><blockquote><p>Maybe today is not an “improve yourself” day. Maybe it can be an “accept yourself and get through” day instead.</p></blockquote><br><img src="life.jpeg">]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我本可以有很多开心起来的理由，但总是因为一些不必要的目标让自己感到困扰。&lt;/p&gt;
&lt;p&gt;我没有任何理由因为工作不相关的人和事情，放弃自己感兴趣的职业和技术方向。&lt;/p&gt;
&lt;p&gt;我不想再花费时间关心自己不需要关心的问题，我有很多感兴趣的事情还没有做。&lt;/p&gt;
&lt;p&gt;我为什么不</summary>
        
      
    
    
    
    
    <category term="生活" scheme="https://smallyu.net/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>在 Dijkstra 算法中保存路径</title>
    <link href="https://smallyu.net/2021/09/18/%E5%9C%A8Dijkstra%E7%AE%97%E6%B3%95%E4%B8%AD%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84/"/>
    <id>https://smallyu.net/2021/09/18/%E5%9C%A8Dijkstra%E7%AE%97%E6%B3%95%E4%B8%AD%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84/</id>
    <published>2021-09-18T11:00:45.000Z</published>
    <updated>2025-05-11T16:12:37.403Z</updated>
    
    <content type="html"><![CDATA[<p>区块链的 Layer 2 中有一种 State Channels 的扩容方案，其中会需要搜索距离最近的路由节点。</p><h3 id="Dijkstra-算法思路"><a href="#Dijkstra-算法思路" class="headerlink" title="Dijkstra 算法思路"></a>Dijkstra 算法思路</h3><p>Dijkstra 算法能够解决 single-source 的最短路径问题，算法本身只输出一个点到其他点的最短距离。比如在这样一个图中，起点是 A，想知道到 D 点的最短距离是多少：</p><img src="g1.png" width="50%" /><p>Dijkstra 算法实质是动态规划的贪心算法的结合，要寻找最短路径，就去遍历所有的点，每到一个点更新最短距离的记录，直到走过所有的点，就可以确信拿到了可靠的最短距离的记录。初始化的状态集合为：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>0</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>此时位于 A 点，未出发的状态，到自身的距离为 0，到其余点的距离未知。</p><p>从 A 点出发后，发现 A 点可以到达 B 点和 C 点，距离分别为 4 和 2，那么就更新状态集合为：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>0</td><td>-</td><td>-</td><td>-</td></tr><tr><td></td><td>4</td><td>[2]</td><td>-</td></tr></tbody></table><p>中括号的含义是在当前这一轮中距离最短的点，哪个距离最短，下一步就到哪个点。到 C 点的距离比到 B 点的距离短，所以下一轮到 C 点：</p><img src="g2.png" width="50%" /><p>到 C 点以后，发现 C 点可以到达 A、B、D 三个点，这个时候意识到，其实 A 点已经走过了，不会再往回走的。于是需要另一个集合记录走到过哪些点，以避免下一步重复。定义 <code>prev = []</code>，因为 A 和 C 已经走过了，就把这两个点放到集合里， <code>prev = [A, C]</code>。</p><p>在这一步的时候，到达 B 点的距离从 4 变成了 3，<code>A -&gt; C -&gt; B</code> 的距离小于 <code>A -&gt; B</code> 的距离，更新状态集合，同时因为已经能够到 D 点了，更新到 D 点的距离：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>0</td><td>-</td><td>-</td><td>-</td></tr><tr><td></td><td>4</td><td>[2]</td><td>-</td></tr><tr><td></td><td>[3]</td><td></td><td>5</td></tr></tbody></table><p>这一轮中，到达 B 点的距离小于到达 D 点的距离，中括号选中 3，并且下一步到 B 点：</p><img src="g3.png" width="50%" /><p>此时 <code>prev = [A, C, B]</code>，状态集合更新为：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>0</td><td>-</td><td>-</td><td>-</td></tr><tr><td></td><td>4</td><td>[2]</td><td>-</td></tr><tr><td></td><td>[3]</td><td></td><td>5</td></tr><tr><td></td><td></td><td></td><td>[5]</td></tr></tbody></table><p>中括号只剩一个选择，只有 D 点没去过了：</p><img src="g4.png" width="50%" /><p><code>prev = [A, C, B, D]</code>，所有点遍历结束，最终结果为：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>0</td><td>3</td><td>2</td><td>5</td></tr></tbody></table><p>现在就可以知道从 A 点到 D 点的最短距离为 5.</p><h3 id="最短路径跟踪"><a href="#最短路径跟踪" class="headerlink" title="最短路径跟踪"></a>最短路径跟踪</h3><p>算法结束后，可以得到从 A 点到其他点的最短距离数据。可是如果不只想要距离值，还想要具体路径，比如从 A 点到 D 点的最短路径，该怎么处理？</p><h4 id="正向贪心算法"><a href="#正向贪心算法" class="headerlink" title="正向贪心算法"></a>正向贪心算法</h4><p>可以判断出，从 A 到 D 的最短路径是 <code>A -&gt; C -&gt; D</code>，而上面的 <code>prev</code> 集合为 <code>A, C, B, D</code>。因为从 C 直接到 D 比 <code>C -&gt; B -&gt; D</code> 的距离要短，所以在路径中抛弃了 B 点。</p><p>按照这样的现象进行对比，是不是只要在 <code>prev</code> 的基础上，在合适时候抛弃某些点，就可以得到正确路径了？比如上面从 B 到 D，存在 4 种情况：</p><ul><li>B 可以到达 D</li><li>B 不可以到达 D</li><li>通过 B 到达 D 是状态集合中到达 D 距离最短的方案</li><li>通过 B 到达 D 不是状态集合中到达 D 距离最短的方案</li></ul><p>这 4 中情况中，只有 <code>B 可以到达 D</code> 并且 <code>通过 B 到达 D 是状态集合中到达 D 距离最短的方案</code> 的时候，才会保留 B 这个点到路径中。否则就应该去掉 B 点。</p><p>中括号每选择到一个点，就把点放到路径中，如果不满足上面的条件，就从路径中去掉这个点，也就是不放到路径里面。这样的话，即使有其他捣乱的点存在，程序也可以应对，比如：</p><img src="g5.png" width="50%" /><p>在选中 B 点后，发现 B 点不满足条件，此时路径由 <code>path = [A, C, B]</code> 回退到了 <code>path = [A, C]</code>。如果下一轮最小的点选中了 E，<code>path = [A, C, E]</code>，但是 E 点不满足条件，<code>path = [A, C]</code>。直到最小的点选中目标点 D，整个程序结束。</p><p>或者这样的，也可以处理，E 点不会被放到路径中：</p><img src="g6.png" width="50%" /><p>那么这样的思路存在问题吗？当然有问题，这样的程序是不能处理这种情况的：</p><img src="g7.png" width="50%" /><p>假如最短路径是 <code>[A, E, C, D]</code>，E 点是不满足上面被放进路径的条件的，E 点无法直接到达 D 点，但是又必须被包含在路径里。去掉 <code>可以直接到达 D 点</code> 的限制？那上上图的 E 点也会被放到路径里。</p><p>也就是说，需不需要能够直接到达目标点，取决于对于最终的路径，被选中的点是不是倒数第二个点。这样的条件在一个未知的图中是无法判断的，谁能知道一个点是最终路径的倒数第几个点？</p><p>正向的贪心算法试图每一次都把距离最小并且在最终路径上的点记录下来，但其实很难做到，因为根本无法判断一个点是不是在最终的路径上。</p><h4 id="反向贪心算法"><a href="#反向贪心算法" class="headerlink" title="反向贪心算法"></a>反向贪心算法</h4><p>当 D 点被中括号选中，作为本轮距离最小的点，就已经能够确定从 A 点到 D 点最短距离了。那么只要知道这一步是从哪个点过来的，来源的点就一定是最短路径的倒数第二个点。依次类推，只要层层回推到出发的点，整条路径就出来了。</p><img src="g4.png" width="50%" /><p>假如在到达 D 点后，能够知道是从 C 点而不是 B 点过来，在 C 点的时候，能够知道是从 A 点而不是 B 点过来，整个路径就很清晰了。</p><p>问题是怎么在 D 点的时候，知道是从 C 点而不是 B 点过来的？选中最小距离点的顺序可是 <code>[A, C, B, D]</code>，按照最小点的顺序显然是不行的。</p><p>这看起来不是一件难事，在 DFS 或者树的遍历中，经常会前后进入多个路径然后在适当的时候返回以修正路径。换个角度看，其实在 DFS 中维护最短距离，也可以达到目的。<code>维护了距离状态的 DFS</code> &#x3D;&#x3D; <code>Dijkstra algorithm</code> 吗？显然不是。</p><p><strong>递归 vs 尾递归</strong></p><p>Dijkstra 适合写成循环的形式：</p><pre><code class="go">for &#123;&#125;</code></pre><p>更适合写成尾递归的形式：</p><pre><code class="go">func recursion() &#123;        recursion()&#125;</code></pre><p>总之，程序会是单向的循环。适合写成递归的形式吗？</p><pre><code class="go">func recursion() &#123;    for &#123;        recursion()    &#125;&#125;</code></pre><p>当遇到分支情况的时候，用 for 循环 “同时” 进入多个路径，寻找最合适的那个。比如到 C 点的时候，for 循环前后进入 <code>C -&gt; B -&gt; D</code> 和 <code>C -&gt; D</code> 的路径，每次循环将只保留一条路径，找到最合适的直接终止递归就可以。</p><p>这样的写法存在问题吗？问题在于，怎么确定在哪个节点进行分叉。在 C 点分叉？为什么是 C 点？为什么不是 B 点？如果是 B 点，路径上就会多出 B 点。为什么不是 A 点？如果是 A 点，到了 C 点的时候需不需要继续分叉？是每一个点都需要分叉吗？想象一下那会造成多么大的冗余……为什么树可以同时遍历？因为树的节点不会交叉。</p><h4 id="第二个动态规划"><a href="#第二个动态规划" class="headerlink" title="第二个动态规划"></a>第二个动态规划</h4><p>第一个动态规划是指算法本身距离数据的维护。第二个动态规划可以维护一个路径数据的状态：</p><pre><code class="js">pathList = &#123;    A: [],    B: [],    C: [],    D: []&#125;</code></pre><p>路径状态保存从源点到达每个节点在当前阶段的最短路径，在一开始的时候，因为 A 点已经可以到达 B 和 C：</p><img src="g1.png" width="50%" /><pre><code class="js">pathList = &#123;    A: [A],    B: [A, B],    C: [A, C],    D: []&#125;</code></pre><p>选择并到达 C 点，这个时候因为 C 点可以到达 B 点并且 <code>A -&gt; C -&gt; B</code> 的距离小于 <code>A -&gt; B</code>，所以更新路径状态数据为 <code>pathList[C].push(B)</code>。D 点也可以到达了，更新路径状态。（更新路径状态数据发生在进入下一个点之前，甚至发生在选择下一个节点之前。可以想一想为什么这样做。）</p><img src="g2.png" width="50%" /><pre><code class="js">pathList = &#123;    A: [A],    B: [A, C, B],    C: [A, C],    D: [A, C, D]&#125;</code></pre><p>这一轮在距离的状态数据上，会把 B 点选中为最小距离的节点，判断到达 D 的路径 <code>A -&gt; C -&gt; B -&gt; D</code> 大于目前已有的距离记录 <code>A -&gt; C -&gt; D</code>，所以不更新路径状态。（判断距离是否大于已有距离是根据距离的状态数据，也就是表格的数据。）</p><img src="g3.png" width="50%" /><p>最终进入目标 D 结束，路径状态不更新。</p><img src="g4.png" width="50%" /><p>得到路径 <code>A -&gt; C -&gt; D</code>。</p><p>路径的状态数据可以为了节省空间，只维护到达目标点的路径吗？不可以，因为更新下一个点的路径需要依赖当前点的路径，路径的状态必须是全量的。</p><h3 id="非最短路径跟踪"><a href="#非最短路径跟踪" class="headerlink" title="非最短路径跟踪"></a>非最短路径跟踪</h3><p>Dijkstra 算法包含了贪心算法的思维，每一步选出的都是距离最短的点。如果需要保存不是最短路径的路径，Dijkstra 算法也许可以做到，但是就已经不需要 Dijkstra 算法了。DFS&#x2F;BFS 更合适一点。</p><p><br><br></p><h3 id="补充（2025-05-11）"><a href="#补充（2025-05-11）" class="headerlink" title="补充（2025.05.11）"></a>补充（2025.05.11）</h3><p>这个 Dijkstra 相关的工作，是当时在一个 State Channels 的项目 <a href="https://github.com/saveio-backup/pylons">pylons</a> 上，用来在多个通道之间寻找最短路径用的，原本是 <a href="https://github.com/saveio-backup/pylons/blob/master/route/dfs.go">DFS</a>，后来我加了一个 <a href="https://github.com/saveio-backup/pylons/blob/master/route/dijkstra.go">Dijkstra</a>，带有黑名单的功能，以及把手续费作为路径距离的计算依据。</p><p>现在把 route 部分的代码单独拆分出一个仓库 <a href="https://github.com/smallyunet/dijkstra-demo/">smallyunet&#x2F;dijkstra-demo</a> 留作纪念。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;区块链的 Layer 2 中有一种 State Channels 的扩容方案，其中会需要搜索距离最近的路由节点。&lt;/p&gt;
&lt;h3 id=&quot;Dijkstra-算法思路&quot;&gt;&lt;a href=&quot;#Dijkstra-算法思路&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="算法" scheme="https://smallyu.net/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>之前公司存在的问题</title>
    <link href="https://smallyu.net/2021/08/31/%E4%B9%8B%E5%89%8D%E5%85%AC%E5%8F%B8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://smallyu.net/2021/08/31/%E4%B9%8B%E5%89%8D%E5%85%AC%E5%8F%B8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-08-31T10:58:39.000Z</published>
    <updated>2024-08-03T19:07:10.028Z</updated>
    
    <content type="html"><![CDATA[<p>我之前任职的公司是传统类型的电信服务类企业，话费支付起家。区块链部门是创新业务部门，内部孵化项目和产品，属于成本部门，公司给钱，但也有一些收入预算。部门收入的来源主要是：</p><ul><li>政府补贴</li><li>招投标项目</li><li>熟人介绍项目</li></ul><p>都是交付形式的项目，招投标项目是按照指定要求开发软件然后全权交付出去，熟人介绍项目是把内部开发的区块链产品交付出去，都要提供开发联调和售后支持。如果没有项目中标、没有熟人介绍，就没有收入了，存在一定收入压力。</p><p>这种营利方式属于相对好理解的模式。很早以前我还没有了解部门收入来源的时候，就无意间和同事说，“现在已经不是靠卖软件挣钱的时代了”，暗指部门领导的挣钱思路有问题。同事问，那靠什么？我随口说，“卖服务啊”。我当时并没有关注相关问题，只是闲聊而已。</p><p>想到这个话题是因为，今天问到 HR 公司盈利模式的问题，“我们又不是像卖煎饼一样，卖一个挣一个的钱。为什么互联网公司的工资高？靠的不是直接营利的收入，是投资人砸钱，花投资人的钱。互联网公司的钱都不是真实的钱，很多互联网公司，为什么财报亏损但还是很多投资人愿意投资？他们都是先占有市场和用户，然后上市，最后由股民掏钱了。我们也是有 IPO 的计划……”</p><p>当然，对这些内容的真实性和准确性存疑。但能肯定的，和之前公司的销售模式完全不同。</p><p>HR 和我提到说，有什么问题可以随时问，我们的企业文化就是 “坦诚沟通”。我说，可能直接问只会得到一些「道貌岸然」的回答，有些事需要不断「试探」才能知道真相。我想到，我这样的行为方式，可能和之前的经历有关。</p><p>如果你提出一个现实的具体的问题，一个人在回答的时候说了很多，扯得很远，某银行的金融方式什么，某大学的教授说了什么话，某体制内机构的高官是什么样的经历，公司某高层怎么要求，公司某员工有什么样的行为，名人名言、历史典故，等等。说了一圈，你发现他并没有正面回答你的问题，好像回答了，又好像没有。偶尔一两次你会觉得，这个人水平很高，接触的都是一些高级的人，说出来的都是大道理方法论。</p><p>时间长了以后，你发现，每一次具体的实际的问题，他都会用方法论来回答，顾左而言他，就是不正面回答你。甚至很多次说出来的都是相同的事例不同角度的道理，从具体问题总结出方法论是一种高级的技能，但如果一味讲究方法论，也会是一种灾难。所有问题一说出来啥都懂啥都明白，怎么回事别人是怎么做的我们应该怎么做，但就是解决不了现实的问题。后来你也许会觉得，可能他不是不想回答，是他也不知道问题的答案。有人说，其实他也很迷茫。</p><p>在具体的工作内容上，他唯一的要求就是 “客户认可”，也就是能赚钱的、最好有直接收益的。你可以把产品相关的技术方向全部列出来，但是发现在所有的技术方向上，没有一个是所谓 “客户认可” 的，甚至全国有吗？是什么？客户怎么会因为你使用了某一种技术而买账呢。你明知道项目存在各种各样的问题，知道该怎么改善那些问题，但是在 “客户认可” 的判断依据下，这些问题没有一个是需要解决的，没有一个产品的技术方向是可以深入的。</p><p>“客户认可” 绝对是再正确不过的判断标准，公司做什么事情一定是为了营利，付出的成本要体现在收入上无可厚非。但是，但就是感觉这玩意儿很难啊。公司本身是那样的营利模式，但是在那种营利模式下，国内挣钱的都没有几家。</p><p>尤其是看到国内某开源项目如火如荼势如破竹，部门的产品寻找突破口更加困难。在近几年都没有显著创新的情况下，没有技术储备、没有发展路线、没有商业资源，甚至工程质量都一言难尽，当你说产品的竞争力不足，又会听到说 “其实我们公司不是专门做这个的”，公司的高层几度放弃部门和产品，这些都预示着部门在走向灭亡。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我之前任职的公司是传统类型的电信服务类企业，话费支付起家。区块链部门是创新业务部门，内部孵化项目和产品，属于成本部门，公司给钱，但也有一些收入预算。部门收入的来源主要是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;政府补贴&lt;/li&gt;
&lt;li&gt;招投标项目&lt;/li&gt;
&lt;li&gt;熟人介绍项目&lt;/l</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="问题" scheme="https://smallyu.net/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>最近</title>
    <link href="https://smallyu.net/2021/08/22/%E6%9C%80%E8%BF%91/"/>
    <id>https://smallyu.net/2021/08/22/%E6%9C%80%E8%BF%91/</id>
    <published>2021-08-22T10:54:00.000Z</published>
    <updated>2024-08-03T19:07:10.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理想"><a href="#理想" class="headerlink" title="理想"></a>理想</h3><p>一开始设想了一些标题《来，我们谈一谈梦想》、《我们谈一谈理想》、《理想修正案》做大标题，现在连小标题都不敢轻易用了。</p><p>会想到 “梦想” 这个话题，是因为我已经不敢用 “梦想” 这样的词汇。不记得两年前为什么会频繁用 “梦想” 这个词，也不敢回头看当时写了些什么。不同时间说话的遣词造句都会不一样，比如上一篇的内容前后历时一两个月，会不断修改之前的用语和内容，到后面就变了很多样子。现在也许会说 “理想”，不会说“梦想”，可能我已经不再做梦，不知道从什么时候开始。这是一种进步，也是一种退步。</p><p>前段时间换了工作，入职第一天和 HR 一起吃饭，谈到他们之前招人的时候，都会问有没有看过某项目源码之类，还问我有没有看过，我说没有。我当时说，我不是很担心（自己）。在后来接触到项目之后，我可以确信确实不用担心，我自认为是没有问题的，我需要考虑更多的是让别人相信我没有问题。怎么让别人相信自己呢，比如用幻灯片做技术分享。具体的内容分三个层次：</p><ol><li>写自己看到了项目的哪些东西，让别人知道一下，自己了解到那些了</li><li>了解对比同类项目，分析功能和实现上的差异</li><li>了解需要解决的问题是什么，目前有哪些做法，项目是怎么做的，其他项目是怎么做的，有没有更好的解决方法</li></ol><p>这三个层次是递进的，需要的时间也是递进的。你分享的内容在那个层次，也许会让别人把你定位到哪个层次上，可是越往后面越需要时间，技术分享其实没有一个 “准备好了” 的时间点，总有更大更难的问题摆在那里，摆在你面前，摆在人类的面前。技术分享是为数不多可选的形式，但不一定是最好的主意。</p><p>就在思考这些个问题的时候，我意识到一个危险的信号。我竟然在担心自己能不能够胜任工作，能不能够通过试用期，能不能够得到别人的认可。以前从未担心这些问题（光顾着 judge 别人了？&#x2F;捂脸）。这些问题可以关心，但不应该担心才对。</p><p>也是前几天花了一些钱，突然就感觉没钱了，钱真是好东西。喜欢和追求钱没什么不对的，钱是货币符号，是等价交换物，你花费时间和生命换取金钱，消耗劳动力获得生产资料换取金钱，金钱是大多数社会资源的代表，这没什么不好。</p><p>我需要反思的是，为什么我在找工作的时候，包括前几个月和去年，都不止一次对不止一个人说，我不在乎钱（工资）。当时确实是那么想的，我简历上的期望薪资就是当时的工资，甚至比当时的工资还要低一点。现在分析原因的话，一方面，在衣食住行得到基本满足的情况下，暂时没有花钱的地方，没有太多欲望。另一方面，我当时是相信自己技术实力的，我相信只要实力到位，工资该涨就会涨，我一开始就只希望得到和自己能力相称的报酬。</p><p>我似乎忘了自己一开始的目的，忘了为什么来北京，为什么换工作，如果我只是在担心自己能不能保住市场平均水平薪资的工作，只是在追求稳定安逸的资金来源，那不是我该有的眼界和胸怀，我自己首先会看不起我自己。</p><p>在 Hacker News 的推荐列表上出现过一篇文章 *<a href="http://www.paulgraham.com/todo.html">The Top of My Todo List</a>*，作者是 Hacker News 创始人之一，在他的 TODO list 里，第一条就是 “Don’t ignore your dream”，现在我也需要这样提醒自己。文章中还提到另一篇文章 *<a href="https://bronnieware.com/regrets-of-the-dying/">The Top Five Regrets of the Dying</a>*，两篇文章同时出现了意思相近的话，一个是 “不要工作太多”，另一个是 “不要工作太努力”，我没有明白其中的含义。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>前段时间的面试也反映出很多问题，我目前没有什么能够证明自己的经历，以至于我都开始怀疑自己。用阿里的话说，就是你做了哪些有难度的事情，为什么难，你是怎么做的，有没有更好的做法，等等。如果我遇到那样的问题，我会无话可说，因为我遇到最大的难题，就是没有遇到困难。也因此我需要寻找更好的出路，如果有什么能拿得出手的经历，我也不会想走。</p><p>能拿得出手的经历实质是在为工程能力做背书，我之前不是很在乎和看重工程能力，毕竟有手就行，但工程能力实际上又是我赖以生存的重要手段，我不得不关心和提高它，因为公司可以相对简单直观地判断你的工程能力，很多公司更愿意为你的工程能力买账。码农嘛。（问：有偏离 “梦想” 的原意吗？）</p><p>前几天看到一个新闻，一开始是在 YouTube 的推荐里看到了这样的标题《<a href="https://www.youtube.com/watch?v=yLmcxQfHtiM">世界上最安全的加密货币，被黑客窃取6亿美元</a>》，没有点进去看，心想应该是人类行为，被诈骗什么的，标题唬人只是噱头。后来在不同的渠道都看到了类似的新闻，比如（现找的）《<a href="https://new.qq.com/omn/20210813/20210813A09TMN00.html">被盗6.1亿美金，抽丝剥茧还原黑客攻击Poly Network 与O3 Swap现场</a>》，或者 *<a href="https://www.zdnet.com/article/poly-network-hackers-potentially-stole-610-million-is-bitcoin-still-safe/">Poly Network hackers potentially stole $610 million: Is Bitcoin still safe?</a>*，据说是去中心化金融历史上最严重的安全事件。</p><p>看到消息后各种不明白，Poly Network 那么有钱？也许只是一种营销行为？但是很多媒体都在说这事了？更多疑问和细节就不追究了。重要的是我忽然明白，我需要了解和掌握的绝不只是手上工作中接触到的项目，我需要了解的，是整个 DeFi (Decentralized Finance) 和 NFT (Non-fungible Token) 的生态和市场环境，那个圈子各种复杂……而且区块链的变化和演进相对互联网要快很多，在这样的时代的洪流中……</p><p>公有链才是真正的区块链，联盟链只是套了区块链的形式炒概念，是具有中国特色的区块链，是在用新的技术解决旧的问题。不过我也还没搞明白公有链的现状，暂时没有什么结论。很多时候一些公链项目都在强调全球生态，为什么是全球生态呢，因为国内没有生态。</p><p>反思之前，我为什么会有信心认为自己对联盟链有一定了解了？真的有足够了解到已经看不到未来的程度了吗？应该是有三个方面的原因：</p><ul><li>之前接触的项目，虽然在技术上算不上顶尖，至少在国内能排个名吧</li><li>我当时对比了网上和能听说到的各种联盟链，在技术上真就那么回事</li><li>当时认真了解了国内厂商广泛参与的某标准测试的规则，通过不算难</li></ul><p>如果局限在那个圈子里面，只会安于现状固步自封自欺欺人。</p><h3 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h3><p>在曾经的某个时候，我对一个人说，“我应该成为一个哲学家”。当然，没有收到任何回复。</p><p>为什么是哲学家？因为哲学家在思考的问题，人人都在思考，时刻都有人思考，没有人知道答案。为什么是苏格拉底？因为从传说来看，苏格拉底是一个粗俗的人，仅仅凭借一种执着的精神。为什么要了解耶稣？因为苏格拉底或者哲学家，一定程度上有宗教的意味，有一帮信徒，在传递某种思想。</p><p>不过，如果你去了解哲学史，会看到各种流派，各种历史人物，对几乎所有的问题，提出了几乎所有可能的观点。哲学的问题，是已经被定义好的问题。哲学的思想，是已经被穷举的思想。退一步说，哲学到底是什么？有人知道吗？哲学是什么本身不就是一个哲学问题吗？或许我们每个人都应该建立一个小目标：重新定义哲学。</p><p>有很多我们从小就熟知的哲学家，很容易被忽略。我们眼里的苏格拉底、柏拉图、亚里士多德、伊壁鸠鲁，可能就相当于西方人眼中的孔子、老子、墨子、荀子，甚至包括王阳明之类。美国在计算机技术上领先世界，可是由于历史短暂，并没有太过知名的哲学家，像德国还有叔本华、尼采之类大名鼎鼎的人物。在这个问题上，我一度充满疑惑。在技术领域上，前沿资料一定是看美国的。但其他领域，可靠的信息源是什么、在哪里？</p><h3 id="“新生代农民工”"><a href="#“新生代农民工”" class="headerlink" title="“新生代农民工”"></a>“新生代农民工”</h3><p>前几天，人社部（中华人民共和国人力资源和社会保障部）发布对新生代农民工的 <a href="http://www.mohrss.gov.cn/SYrlzyhshbzb/jiuye/gzdt/202108/t20210816_420736.html">监测报告</a>，这好像是第一次明确使用 “新生代农民工” 的称呼。这是一个正常的统计报告，发布报告的部门是 “农民工工作司”，他们就是这样的工作，即使有问题也可能是很多人觉得，把之前一些模糊不清的群体，现在明确划分到了这个部门做统计？问题他们做统计的依据是户口类型，他们一定没错。</p><p>看到报告，我第一时间想到，早在很多年前的某人语录，就吐槽国中国的户籍制度。他说的是另一个方面的问题，说我出生在中国，作为中国公民，从中国的一片土地到中国的另一片土地上，居然 TMD 只能暂住？不办证还驱逐？好在这样的现象已经改正了。</p><p>有人分析说，现在这个时候国家发布这样的信息，意思是让新生代农民工们认清楚自己的定位，安心回老家生孩子过小日子，别想那些乱七八糟的东西，只盯着光鲜亮丽看。现在不想生孩子的群体特性，一是高学历，二是在一线城市工作。学历越高、越是在一线城市工作，就越会接触到贫富悬殊的状况。他们不想生孩子，一是贫富差距大，二是阶级固化。在一线城市没有竞争力，就不敢生孩子。不敢生孩子，国家劳动力就不够。人口不增长，光是人口数据都不好编了。今年发布的一系列政策，互联网大厂减少加班、不允许孩子补课，都是在减少压力鼓励生育。</p><p>央视曾经有过论调，“认命可以，躺平不行”。有人说，自己读了研究生读了博士，结果读成了农民工。还有人说，天天自嘲码农，现在被官方叫一声怎么就破防了？我觉得，这个报告，最可怕的不是给人区分类型贴上了一个 “农民工” 的标签，而是默认了出生决定论。你是农民，本该务农，现在不从事农业工作进城打工了，我们得好好关注一下你，看看你什么情况。</p><p>不过这样真能提高生育率吗？如果你知道你的孩子生下来就是农民工，孩子就要说了，“生而为农民工，我很抱歉”。但是为什么要抱歉呢？如果有人刻意强调什么是重要的，那说明主流意识形态已经是和强调的观点相悖了，才需要强调。</p><h3 id="听说"><a href="#听说" class="headerlink" title="听说"></a>听说</h3><p>有一首歌《<a href="https://www.youtube.com/watch?v=clYdjZKrsbU">听说</a>》，演唱者是华子。大学的时候听到觉得感人，在宿舍里单曲循环。室友听到说，这么难听的歌你老听它干啥。听过几次之后，我也觉得难听了，曲实在是很差劲。</p><p>最近经过一些事情，无意间想起这首歌。这首歌确实难听，因为曲根本不重要，华子不是一个合格的歌手。他是诗人。越是对生活有体会，越是能够理解《听说》的含义。我甚至尝试模仿听说的文体写点什么，当然只是即兴的，没有任何推敲，先想起来写，后想起来这首歌。</p><p>不过，《听说》在思路上存在一个很大的问题。它只是把一些现象说了出来，这种现象还是结果形式的现象，没有说引发现象的原因是什么，人们面对的问题是什么，解决方案是什么。相比之下，白居易的《卖炭翁》就有很明显的指向。</p><p>也可能是言论尺度的问题？可以出现在古诗里的内容，不能出现在当代诗歌里？（还真有可能</p><h3 id="塔利班"><a href="#塔利班" class="headerlink" title="塔利班"></a>塔利班</h3><p>前几天有个刷屏的新闻，塔利班夺取阿富汗政权。有人大胆地开玩笑说，塔利班就是曾经的我们。还有个海外华人的自媒体说，他早在 8 月 1 日就发布预言，塔利班已经取得中国和美国的支持，将会夺取政权，然后 8 月 16 日，塔利班真的行动了，之类。</p><p>具体情况也不是一时半会儿能搞明白，我们需要明白的是，历史时刻在发生。经常有人说，在面对历史的大变革大是大非的时候，能清楚时事的往往不是哲学家，而是历史学家。历史不可能倒退，但历史总在不断重演。</p><p>在关注到一些海外平台的政治不正确的言论后，我唯一了解到的信息，就是真的有坏人，他们可能训练有素、身居要位、执掌权政，不是因为他们想坏，而是因为他们都是人。</p><p>同一个国家在不同的历史时期，即使同一个决策者都会做出不同的决定，即使是同一个执政党，内部关系也错综复杂，一些幼稚的言论经常会把问题简单化，比如阿里女员工在食堂拉横幅，很多人直接归责于阿里的制度，把阿里作为一个统一的整体看待，包括很多人把百度作为统一的整体，百度干了什么什么坏事之类。“新生代农民工” 也是同样，它只是某部门某些人发布的言论，沧海一粟而已。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>好难呀。不知道为什么，这次写这些东西感觉磕磕绊绊，经常语句不通用词不当。以前写东西都是带着情绪有感而发一气呵成，现在真的不一样了，不知道发生了什么。</p><p>以前写什么还会通读几遍修修改改，我不想改了，我累了。我要出去遛弯了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;理想&quot;&gt;&lt;a href=&quot;#理想&quot; class=&quot;headerlink&quot; title=&quot;理想&quot;&gt;&lt;/a&gt;理想&lt;/h3&gt;&lt;p&gt;一开始设想了一些标题《来，我们谈一谈梦想》、《我们谈一谈理想》、《理想修正案》做大标题，现在连小标题都不敢轻易用了。&lt;/p&gt;
&lt;p&gt;会想到</summary>
        
      
    
    
    
    
    <category term="梦想" scheme="https://smallyu.net/tags/%E6%A2%A6%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>工作两年的体会</title>
    <link href="https://smallyu.net/2021/07/23/%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/"/>
    <id>https://smallyu.net/2021/07/23/%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E7%9A%84%E4%BD%93%E4%BC%9A/</id>
    <published>2021-07-23T10:03:03.000Z</published>
    <updated>2024-08-03T19:07:10.104Z</updated>
    
    <content type="html"><![CDATA[<p>如果你看到了这些内容，那么我已经离开上一家公司，开始了新一个阶段的职业生涯。</p><h3 id="最后的稻草"><a href="#最后的稻草" class="headerlink" title="最后的稻草"></a>最后的稻草</h3><p>在一次技术分享会议上，我意识到我的技术理念和上级、和公司、甚至有可能和整个行业不同。这无关对错，没有冲突没有矛盾，仅仅只是 —— 不同。</p><p>我希望技术用来解决技术问题，更关注技术的发展趋势和形态，我并非不会让技术变得具体，只是不认为 “具体” 意味着深度，尤其是把 “具体” 和人类的心理（信任模型）联系起来。具体的技术可以解决特定的问题，有价值，可是格局小了，我不会满足于那样的程度。</p><p>比如，我认为,计算机和计算机之间的路由器，就是负责转发网络消息、保证消息准确无误到达目标计算机的，不应该牵扯到消息的具体内容。如果是转账消息，路由器还应该冻结转出方的资金保证交易事务的顺利完成？这太扯淡了。</p><p>当然不仅仅是这样的原因，只是因此突然产生了出去看看的想法。想法的产生只需要一瞬间，在上级纠正我的观点时，我绝对承认上级在技术问题上，尤其是在业界，理解上的正确性。只是突然觉得，这一切都太无聊了。那个圈，我跳不出去。</p><p>即使没有实现理想的实力，也不妨碍继续拥有理想。</p><p>一直只知道远处的山上有恶龙，现在发现，山脚下有怪物挡住了上山的路，山脚下的怪物，名字叫权威。</p><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>去年上半年也产生过离开的想法，原因是，当时完全在从事没有技术含量的 CRUD 项目，我不能就那样下去。其实今年的原因也类似。</p><p>后来没有离开的原因，不是工作经验或者技能情况。当面试官问我一些很无聊的问题时，我突然觉得，我没有兴趣再继续找工作。换个地点上班并不能解决我的问题，不应该把技术能力的提升期望于任职的公司。甚至，我其实自己都没想清楚，对新工作的诉求是什么。外加当时大环境影响，面试不方便，以及当时的上级后来给了我不少发挥的空间，就安静呆着了。</p><p>去年下半年，降薪，项目失败，部门人心动荡，离职率高。有同事问我，为什么不跳槽？我倒一直不那么看重薪水，尤其当时在 “忙” 一些别的事情，自己的事情，没有心思关注工作的问题。包括今年也是，不是想不想，是没有去想，个人问题太多了，顾不上想。</p><p>现在是一个好的时机吗？好不好不知道，至少闲下来了。你也许能想象到，一开始看原生的英文视频和电视剧，感觉多么痛苦，听也听不懂，看也看不懂。有一段时间对美剧丧失兴趣，完全不想看，因为 TM 看不懂啊。</p><p>在个人能力的问题上，有一个简单的逻辑。如果我的能力拿得出手，我将找到更好的工作机会。如果我的能力拿不出手，那我必须得走，无论成本多高，即使挣不到钱、交不起房租、在这座城市生存不下去，一定要走。如果只有现在的公司认可我，我就会苟活在这里吗？在现在的公司算是 “被” 核心，但是一两家公司对我认可与否，并不能说明什么。我从来没有期望拿到比自己能力更多的报酬。</p><p>这两年来，我没有闲着。虽然没有把时间用在刷题或背基础知识上，但确实没闲着。速度和加速度，我选择了提高加速度。斧子和木头，我选择了打造更好的斧子。我花费时间，让自己成为一个更好的人类，而不是成为一个更好的码农。</p><p>在工作时间没有明确工作安排的时候，我在摸鱼吗？是的。但那种鱼摸起来，异常痛苦。我需要时刻思考，接下来做什么？我能做哪些工作相关的有价值的事情？每天早上醒来、每天晚上下班，想的都是，今天干什么？明天干什么？明明我已经尽力了，可什么事情都做不了。在工作上，我问心无愧（基本上）。不是故意偷懒，是实在想不到可以做的事情，何况连上级都没有。我才是真正想做些事情的人。</p><p>关于面试，我不希望刻意准备什么。必要的回顾和梳理经历是必要的，但不应该关注面试题。技术能力不可能一时半会儿提高，那种能短时间学会的东西，在哪儿学不一样呢，无论身处现在的公司还是未来的公司。我需要的，也许是一个试用期。如果能力不够份，我会自觉知趣地主动离开（当然，我知道现实社会不是那样运作）。我希望可以压力缓和的完成这次跳槽，如果在找工作过程中突然启动某个主题的学习计划，手忙脚乱不说，可能连找工作的兴趣都没了。</p><p>突然回想起在大学的时候，每次考试的前一天晚上，教室封楼，所有人都在宿舍里专心急迫地看书复习，校园里、操场上空无一人。只有我在外面溜达、在宿舍睡觉。需要会的已经在脑子，不会的临时看也没什么意思。</p><p>如果这次找工作遇到了比较大的阻力，那么我将会用亲身经历验证一个浅显的道理：两三年的工作经验远没有两三年的学历证书重要。我自认为学校里充满各种形式化的事情，各种魔幻的心理状态，无法教给我真正有用的知识。</p><p>（事实上，面试机会还是不少的，把握不住，是我自己的原因了。）</p><h3 id="一些事"><a href="#一些事" class="headerlink" title="一些事"></a>一些事</h3><p>以前没有在博客里提起，因为这些事情对我没有 “成长” 上的意义。虽然有接近 1 年的时间都牵扯在这一系列事情和情绪里面，但确实没有意义，不值一提。现在回忆一下作为记录，防止以后忘得太彻底。</p><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>部门分两个小组，应用层小组和底层小组，简称 A 组和 B 组。我当时从属于 A 组。其实部门并没有多么明确的权限划分，我也没有搞山头的意思。</p><p>去年下半年，一个项目需要我（A组组员）和 B 组的组长合作，共同完成一件事情。从我当时的立场看，我只是个写代码的，出于在 A 组的工作经历以及对 A 组组长一定程度上的信任，心想好歹也是 B 组的组长，我又不太懂那个项目，他说什么我照做就是了。</p><p>实际的合作过程中却被难受了一把。他的思维逻辑没有足够条理，一会儿测场景一，一会二测场景二，一会儿又要测场景一。然后突然产生个想法，说那就测一下验证一下，场景一和场景二都测。完全想到哪儿做到哪儿。我们测的是分布式系统，有 4 ~ 6 台机器，每台机器上 2 ~ 3 个程序，切换场景需要所有的程序改配置、重启、清日志、记录机器状态、记录结果、分析结果等，还是在远程桌面、网络延迟到能让人爆炸的情况下。其实这个还能忍受，当时也没有多想什么，只是觉得这样的工作有点枯燥繁琐，有点抵触。</p><p>重点在于他不信任我。我事后复盘了一下，他在整个过程中、对我指手画脚的这些工作中，得出的结论，全是我早就已经知道的结论。他连带我消耗的那些时间，完全没有对事情起到推进作用。我事前就和他说过，结论是怎样怎样，然后他说，“那这个得跑一下”，“看看结果” 之类。我当时对自己没有足够的信心，毕竟他的 title 在那儿，而且我也期望他可以得到什么不一样的、更有用的结论，就听他的了。结果呢，他让我做的事情，只是把我的结论又验证了一遍。我开始对他的能力产生质疑。</p><p>后来又隔了几天，他让我重新验证一遍之前最好的一次结果。我在一些操作后，说直接写结论是多少吧。他坚持让我再操作一遍，把过程和结果拿给他。我就生气了，问 “这次测试的目的是什么？是为了把结果给你看一眼吗？” 我心想，我工作的内容就是给你打下手？我工作的价值就是给你看结果，让你相信我？在这件事情上，我们是合作的关系，还是从属关系？我凭什么做这样的事情？是你高估了自己，还是低估了我？你要真有能力也行，问题是你没有。</p><p>然后我的解决方法是，我对他说，以后再有事情，找我的领导（组长或部门负责人），让我的领导来协调，而不是直接命令我。意思就是让我的组长帮忙挡一下，拦掉一些没意义的事情。我从立场上并不能直接拒绝他，说这事我不干。如果我的领导一致认为一件事情是有意义的，从工作的角度，我肯定没有理由拒绝领导安排的工作内容。另外，如果我的领导一致认为我的工作内容就应该是给他打下手，那我当场辞职。</p><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>经过第一阶段的事情后，我偶尔还瞎想，要是有一天领导要求或安排，我转到他们那个小组了，肯定得搞得天翻地覆，因为我并不信任他（B 组组长）的能力，我不会放心地把工作内容交给他。</p><p>然后神奇的事情发生了。B 组组长离职，B 组的某个组员成为组长，我转岗成为 B 组组员.</p><p>这 NM 搞笑呢？别说 B 组组员升的组长，就是原组长在的时候我也不服啊？甚至原组长的上一任组长、部门技术负责人（已离职），我也是一开始就怼的。</p><p>我确实没服。一个人突然来当我组长、当我领导，有权力安排我接下来要做的工作，这样的人，我不得先试试他的水平吗？我不可能轻易把将来的工作时间，任由没能力的领导瞎指挥瞎浪费啊。</p><p>然后我就用比较生硬的方式搞了点事情。^_^</p><p>事实上，各种迹象都表明，他（现任 B 组组长，即将离职）能力确实不行。不是说技术能力，是指当组长的能力。一般来说，一个内心和实力都强大的人，无论面对别人怎样的质疑，都应该是岿然不动、稳如泰山的。结果他那儿直接就歇菜了，没有反驳，甚至还有点认可和顺从我说的话、我的行为。自己都承认自己不行，那我干嘛听你的？</p><p>最后是部门负责人出面协调解决。当我说出我的判断时，部门负责人说，你不应该反抗他，而是帮助他，一起完成该做的事情……（侧面默认了我的观点，至少面对我是这样的说辞）</p><p>事后，部门负责人还找我谈话，大概意思是，你最近没有搞事情吧？你不要再说他了，再说他就要想走了，我怕他走……</p><h4 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h4><p>或许你会觉得，第一阶段和第二阶段都是我的问题，是我让他们的工作遇到了阻力。要是换个听话一点、服从性强的人，就完全不会发生那样的事情。</p><p>换个角度想，也许是他们太弱了，连我都压不住。我不可能主动降低自己的标准，假装服从他们的安排。</p><p>我到目前还是相信，无论身份、地位、背景、履历，过去多么辉煌、现在多么有钱、关系网络多么庞大、人际来往多么高端，技术就是技术，逻辑就是逻辑。不会因为一个人是部门负责人、首席架构师、行业知名人士，他说的话、他的技术观点就是绝对正确的。</p><p>这是一个能压得住我的人。</p><p>所以我换工作了。 :P</p><h3 id="一些坏话"><a href="#一些坏话" class="headerlink" title="一些坏话"></a>一些坏话</h3><p>我喜欢《海贼王》的故事。</p><p>如果你在一艘几乎停摆的船上。连船长都不知道，船往什么方向开，要到什么地方去。你还敢坐吗？</p><h3 id="感谢公司"><a href="#感谢公司" class="headerlink" title="感谢公司"></a>感谢公司</h3><p>必须要说明的是，上面提到的事情是从非常片面的视角、带有强烈主观个人情绪的描述。公司员工关系和睦、领导管理有方，基本不存在让人不愉快的事情。我只不过是把某条线单独拿出来说了，公司带给我的正面记忆远比写出来的事情多，我的成长离不开每一个遇到过的人。</p><p>感谢公司出现在我生命中的这两年半的时间。</p><h3 id="感谢上级"><a href="#感谢上级" class="headerlink" title="感谢上级"></a>感谢上级</h3><p>在交接工作的时间里，我一度担心会被领导卡离职流程，甚至想好了各种对策来应对各种有可能发生的情况。这种担心的主要的来源，不是上级，也不是我的交接对象，而是另一个和我的工作无关也和我的交接无关的人。</p><p>他的逻辑基本上是，在我离职后，某些事情（不是我的本职工作，友情支持）他们自己处理起来会有困难，所以期望我在离职前就做好一些一步到位的事情。我推测他的动机有两种可能：一种是他认为自己技术能力不足，无法顺利完成某些事情；另一种可能是，他认为这些本该由他自己处理的事情，比较繁琐复杂，他也懒得做，就借机推卸事情，让我做。</p><p>无论是哪一种可能，都应该和我的离职流程无关才对，但也就是稍有点担心，他会以此去影响领导在离职流程上的判断之类，因为在新的组织架构和工作安排上，他是比较重要的承担工作的人，在领导那里可能会有比较高的权重，算是我小人之心了。我相信领导还是拎得清的，事实上也确实没有出现不合理的情况。</p><p>比起这种具体的小事，我倒是更在意，其实我现在离职得稍微有点早，还没有做一些什么事情，就走了。主要也不敢继续留在这里，这次换工作，更像是在逃生。我不敢牺牲以后的可能性，在这里做不知道结局的事情。</p><p>对以前和现在的上级心怀愧疚中心怀感激。</p><h3 id="新的工作"><a href="#新的工作" class="headerlink" title="新的工作"></a>新的工作</h3><p>在新的工作上，我认为会离 “自由” 更近一步。</p><p>这里的自由也许包含多种含义，但我明面上肯定只会承认技术意义上的自由。可以接触真正的互联网，是无法用社会资源衡量的精神财富。</p><h3 id="祝好"><a href="#祝好" class="headerlink" title="祝好"></a>祝好</h3><p>将军不下马，各自奔前程。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;如果你看到了这些内容，那么我已经离开上一家公司，开始了新一个阶段的职业生涯。&lt;/p&gt;
&lt;h3 id=&quot;最后的稻草&quot;&gt;&lt;a href=&quot;#最后的稻草&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="梦想" scheme="https://smallyu.net/tags/%E6%A2%A6%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>剧本杀的剧本为什么需要区分类型</title>
    <link href="https://smallyu.net/2021/07/20/%E5%89%A7%E6%9C%AC%E6%9D%80%E7%9A%84%E5%89%A7%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B/"/>
    <id>https://smallyu.net/2021/07/20/%E5%89%A7%E6%9C%AC%E6%9D%80%E7%9A%84%E5%89%A7%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-07-20T00:43:43.000Z</published>
    <updated>2025-06-16T00:24:19.068Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，我写下这样一句话：</p><blockquote><p>给剧本打标签、分类其实是非常错误、愚昧的做法，尤其会让习惯于 “循规蹈矩” 的玩家有先入为主的映象，认为什么什么标签的本就应该怎么怎么玩。</p></blockquote><p>当时玩了一个情感本《春昼短》，游戏结束时，一个玩家吐槽（不是针对我）说，情感本不是这么玩的，重要的是代入人物体会情感，而不是全程都在分析凶杀案的凶手是谁，不应该把重点放在推理上。</p><p>我有感而发，一方面，是 DM（Dungeon Mater，主持人）说，现在是推凶环节，要找出凶手，然后所有人都在找凶手了。有什么问题？另一方面，情感本就不能关注推理和凶杀案了？剧本本身的故事情节薄弱无趣，根本不能引人注意让人感动，也不值一提啊。</p><p>过了很长时间后的最近，我满怀期待去玩一个备受好评的情感本《古木吟》，却由于其他人全程在关注凶杀案，最后感觉留有遗憾，明明是很好的剧情和故事，却没能把剧本发挥出来，体验到该有的效果。曾经讨厌别人吐槽的我，现在像那人一样（在心里）吐槽别人。</p><p>我开始反思，给剧本区分类型、打标签、划分不同玩法的做法，对吗？</p><p>答案是，对。</p><p>一般来说，剧本作者的水平高不到哪儿去，你不可能指望一个普通的剧本作者，推理部分逻辑缜密，故事部分感人至深，机制部分欢乐有趣，这不合理。</p><p>就算平时看刑侦推理电视剧、机制游戏真人秀，花那么多钱、请那么多明星、牵扯那么多资本，好看的有多少？何况是能够 “欺骗” 观众，让观众误以为真相是某一种，然后留下线索和悬念，最后有精彩反转的剧情，即使在美剧里也屈指可数。</p><p>仅仅是能达到好玩程度的剧本，就需要至少影视剧编剧水平的作者了。那样的作家又哪有功夫写剧本杀剧本，剧本杀的成本才多少。剧本杀的剧本，能有一两个亮点其实就不容易了。</p><p>所以为什么需要给剧本打类型标签？因为受限于剧本作者的水平，一种类型的剧本还真就只有一种玩法。用硬核本的玩法玩情感本，实际上牛头不对马嘴。</p><p>为什么会有 “一种剧本不应该只有一种玩法” 的错觉？因为很多剧本内容同质化严重，不管什么类型的本都会有凶杀案的桥段。好在这样的状况已经在逐渐改善，比如今年的一个热门剧本《来电》，没有凶杀案但是机制有趣、游戏欢快，最后的反转立意深刻，无论算不算最高水准的剧本，至少在好玩的同时还避开了传统落俗的套路，这是不小的进步。</p><p>那么，作为玩家，是不是应该在游戏前查看剧本的背景资料，了解这是一个什么类型的剧本，知道应该用什么样的玩法，明白重点关注哪些环节？</p><p>当然不是！</p><p>这分明是 DM 的责任。DM 自己首先应该对剧本了然于胸，然后在游戏开场前说明注意事项，让玩家知道侧重点，甚至针对不同水平的玩家在不同的游戏阶段进行单独的指导。DM 不能默认所有玩家都是老手，更不能默认所有玩家都知道某个剧本该怎么玩。</p><p>事实上，DM 的控场能力对玩家的游戏体验至关重要。</p><p>事实上，DM 的水平十有九差，剧本杀的体验十有九差。</p><p>我参与过的为数不多的体验比较好的游戏场次里，要么 DM 专业、全程在线，要么玩家之中有能自发站出来控场的老玩家。体验不好的场次里，几乎全是 DM 的问题，稍差一点的不参与不引导流程，更差一点的直接误导玩家，给不重要的环节留比较多的时间。还有的 DM 催着玩家加快节奏结束游戏、完成自己的工作任务，丝毫不顾玩家的感受。</p><p>不好的体验也算是一种经历了。我本来就在尝试不同的剧本杀店。</p><p>回到剧本类型的问题，道理是相似的，如果一部电影在宣传的时候说，这是集爱情古装玄幻动作剧情伦理喜剧历史为一体的青春偶像片，不看都知道是烂片。</p><p>如果有一种编程语言，声称同时支持 FP 和 OOP，同时支持 actors 和 pipeline，同时支持 try…catch 和 union type，既是 static typing 又是 dynamic typing 还支持 type inference，适用于熟悉不同编程语言风格的人，那这种编程语言……是 JavaScript 吧？ :P</p><p>如果一个人说他既会前端开发又会后端开发，会 APP 开发还会嵌入式开发，懂区块链原理还懂神经网络原理，对大数据处理和数据平台的建设都有深入研究，那这样的人……岁数肯定不小了……</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前段时间，我写下这样一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给剧本打标签、分类其实是非常错误、愚昧的做法，尤其会让习惯于 “循规蹈矩”</summary>
        
      
    
    
    
    
    <category term="剧本杀" scheme="https://smallyu.net/tags/%E5%89%A7%E6%9C%AC%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>“我”是……（系列）</title>
    <link href="https://smallyu.net/2021/06/24/%E2%80%9C%E6%88%91%E2%80%9D%E6%98%AF%E2%80%A6%E2%80%A6%EF%BC%88%E7%B3%BB%E5%88%97%EF%BC%89/"/>
    <id>https://smallyu.net/2021/06/24/%E2%80%9C%E6%88%91%E2%80%9D%E6%98%AF%E2%80%A6%E2%80%A6%EF%BC%88%E7%B3%BB%E5%88%97%EF%BC%89/</id>
    <published>2021-06-24T14:23:19.000Z</published>
    <updated>2024-08-03T19:07:09.974Z</updated>
    
    <content type="html"><![CDATA[<p>“我”是一个有洁癖的人。</p><p>住在别墅的富商们都有洁癖，他们的柜子上摆满金银珠宝，他们认真擦拭灰尘、小心翼翼摆放，把一切整理的井井有条错落有致一尘不染。</p><p>我看到琼楼玉宇里的达官显贵们都是那么做的。</p><p>虽然我面前只有一个垃圾桶，堆满了肮脏的废弃的物品，但是我看到它们不整齐，我要把它们变得干净整洁，因为我有洁癖。</p><p>当我看到有人往垃圾桶里随意丢弃垃圾，不屑一顾置之不理，我会大声抱怨甚至斥责他们，虽然他们毫无悔改之心。</p><p>为什么他们不懂得干净和整洁，为什么不能像我一样，不能像达官显贵们一样，做一个严于律己有洁癖爱干净整洁的人，</p><p>我有洁癖，我比那些不懂干净整洁的人高贵，我比他们都高级。（狗头）</p><div style="text-align: right;">（2021年03月11日）</div><br><hr><p>“我”是一个设计者。</p><p>我定义了一种新的加法运算，在这种运算规则下，1+1&#x3D;3，2+2&#x3D;5。</p><p>我出了一些题目，比如 3+3&#x3D;?、4+4&#x3D;?，如果有人能回答出题目，就说明他们已经掌握了我创造的“知识”。</p><p>有的人热衷于学习我创造的知识，奉我为神灵，乐此不疲，以此为荣，甚至看不起没有掌握这些知识的人。</p><p>有的人还会为了我争吵，面红耳赤，在讨论是我创造的知识好，还是另一个设计者创造的知识好。</p><p>有的人会觉得掌握了我创造的知识，就比掌握了另一个设计者创造的知识的人高级。</p><p>我喜欢这些有趣的人，虽然在我眼里，他们都是虫子。（狗头）</p><div style="text-align: right;">（2021年03月23日）</div><br><hr><p>“我” 是一个建筑师，能够进行普通建筑物设计图纸的绘制。</p><p>有一次工头喊我帮忙，工地缺人手，需要把砖头从一个地方搬到另一个地方。我去了。</p><p>搬砖的工人不明白，为什么搬同样的砖，从同样的一个地方搬到同样的另一个地方，给我的报酬比给他们的多。</p><div style="text-align: right;">（2021年04月22日）</div><br><hr><p>“我” 是奥特曼。</p><p>人类总是 “好心” 地劝告我，怪兽特别厉害，怪兽特别强大，怪兽摧毁了很多人类的房屋和土地，怪兽给很多人类战士带来了死亡和恐惧，要我小心怪兽的攻击，要我对怪兽有 “敬畏之心” ，不要小看了怪兽。</p><p>我懒得解释我的手一举起来就可以发射激光。</p><div style="text-align: right;">（2021年04月22日）</div><br><hr><p>“我” 是一个船长。</p><p>我命令我的船员去一个小岛上寻找宝藏。一定有的，宝藏就在那里。</p><p>如果你非要问我，我为什么肯定那个小岛上有宝藏，因为别的船都到那里去找，而且找的很热闹，大张旗鼓。</p><p>即使有去探索过小岛的船员说，那里没有什么。</p><p>即使有去过更大的岛的船员说，那里没有什么。</p><p>一定有的，宝藏就在那里。</p><p>如果你非要问我，我为什么肯定那个小岛上有宝藏，因为别的船都到那里去找，而且找的很热闹，大张旗鼓。</p><div style="text-align: right;">（2021年04月29日）</div><br><hr><p>“我” 是一个游戏的资深玩家。</p><p>我经常说这个游戏如何好玩，为什么好玩，为什么值得玩，多有前景。</p><p>我们经常讨论这个游戏的玩法，阵营，策略，升级，成就，装备，公会，任务，操作，等等。</p><p>一个新手玩家说，这个游戏不好玩。</p><p>一个新手玩家说，这个游戏虽然好玩，但没有另一个游戏好玩，没有另一个游戏有价值，没有另一个游戏有前景，没有另一个游戏有意义。</p><p>我怎么可能抛下在这个游戏上的积累，去玩另一个我没玩过的游戏。</p><p>我甚至不会承认，新手玩家说的是对的。</p><p>即使新手玩家真是对的。</p><div style="text-align: right;">（2021年05月07日）</div><br><hr><p>“我” 是一个地主。</p><p>秋天到了，家里需要雇佣工人去田地里收割麦子，长工短工都有。</p><p>经常看见工人们相互探讨收割麦子的手法、步法、心法，相互比较谁割麦子速度快、质量高，谁经验多、能够快速收割掉各式各样没长齐的麦子。</p><p>越是手艺好、会说话、忠心的工人，我自然越是喜欢。他们也会为此洋洋得意，因为得到了比其他工人更多的认可和报酬。</p><p>手艺好的工人是有优越感的，他们可以到任意一家地主家里去收割麦子，因为他们有精湛的收割麦子的技术，大多数地主没理由拒绝这样的工人。这可不是一般工人能享有的待遇，他们已经算是高级的工人了。</p><p>高级的工人有时还是给普通工人讲解割麦子的技巧，传授收麦子的心得。地主招收新的工人时，也会让高级工人代为把关，用一些刁钻的技术问题判断，想来的工人到底能不能达到地主家的要求。</p><div style="text-align: right;">（2021年05月26日）</div><br>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;“我”是一个有洁癖的人。&lt;/p&gt;
&lt;p&gt;住在别墅的富商们都有洁癖，他们的柜子上摆满金银珠宝，他们认真擦拭灰尘、小心翼翼摆放，把一切整理的井井有条错落有致一尘不染。&lt;/p&gt;
&lt;p&gt;我看到琼楼玉宇里的达官显贵们都是那么做的。&lt;/p&gt;
&lt;p&gt;虽然我面前只有一个垃圾桶，堆满了肮脏的</summary>
        
      
    
    
    
    
    <category term="观点" scheme="https://smallyu.net/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>我没有在博客上骂人</title>
    <link href="https://smallyu.net/2021/04/23/%E6%88%91%E6%B2%A1%E6%9C%89%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%8A%E9%AA%82%E4%BA%BA/"/>
    <id>https://smallyu.net/2021/04/23/%E6%88%91%E6%B2%A1%E6%9C%89%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%8A%E9%AA%82%E4%BA%BA/</id>
    <published>2021-04-23T01:54:03.000Z</published>
    <updated>2024-08-03T19:07:10.107Z</updated>
    
    <content type="html"><![CDATA[<p>我过去没有、将来也不会在博客上骂人。</p><p>对于博客的存在，我的态度一直是不主动、不拒绝。我当然不会在意有人从我的 Github 主页看到了博客链接，或者从其他网站账号看到博客网址的字样，但是也不太可能主动跟人说，“这是我的博客，你过来看一眼吧”。</p><p>博客就像是把自己写的一本书放到了公共图书馆的书架上，我不会刻意引导别人到第几排的书架第几个格子去找一本什么样子的书看看吧，但如果有人无意间看到了，自然也随意。如果看到的人正好发现，书里的内容和自己的行径有点相似，难道会认为这本书是为了嘲讽自己而写吗？即使指名道姓，也不会有人那么 “自恋” 吧。</p><p>对于现实生活中认识的人，博客里面的内容有比较大的可能提及相关的人或者事，稍微有点担心尤其是当事人会理解出 “听者有意” 的含义。对于网络世界中不认识的人，smallyu 只是沧海一粟，不值一提，班门弄斧，怕人笑话。而且，如果真有很多人看的话，我会有包袱和压力，不敢轻易写 “没有含量” 的内容，那样的感觉太糟糕太压抑了。</p><p>记得很久之前有一次，把博客链接填写在一个小型的博客导航网站上，那种按点赞和点击排权重的全是博客的导航网站，当时好像收到了（起码在某个时间段）排名第二的点赞数量。我第一次意识到，博客里的内容可能会有人认可，也是第一次感受到到 “被看到” 的压力。后来就没有再主动把博客链接发到什么地方了，我不会做类似 “在论坛日经贴下面留言博客链接” 的事情。</p><p>博客具体的内容，肯定不会专门为了针对某一个人写什么，更多的情况是希望描述某一类人，这些人可能会具有一些共同的特征，然后将某人某事作为典型举例。</p><p>如果有人非要认为，这就是在写谁谁谁或者什么什么事，你就是对谁有意见有看法，在表述一些不满或者不敢直接说的想法等等。有一个相关的逻辑：</p><ul><li>问：为什么毛当年可以从一个北大的图书管理员，成为国家主席？</li><li>答：只是一个将会成为国家主席的人，在成为主席之前，当了几天图书管理员而已。</li></ul><p>与之类比，</p><ul><li>问：你一个过往经历不堪的人，凭什么觉得将来有可能会做一些什么事情？</li><li>答：只是一个有可能将来会做一些事情的人，有一段比较寻常的过往而已。</li></ul><p>博客的立场不会是 “谁的朋友” 或者 “某公司的员工”，而是 “认识过拥有某些特征的人的人” 或者 “有过在某公司任职经历的人”。</p><p>所以，如果真的有人感觉“被针对”了，天地良心，我根本没有把那些人放在眼里。&#x2F;doge</p><p>在关于人生的问题上，我比较好奇也有点盲目地崇拜耶稣、苏格拉底这样的人，同时也对西方神学和古希腊哲学充满兴趣。只是目前没有足够空闲的时间，也没有找到合适的门道去深入了解相关内容。</p><p>至于为什么会突然提到这个话题，其实也只是作为预防，包括以前存在的和以后有可能出现的内容。随着时间的推移、生活中往来的增多、网络中内容的增长，这个博客有可能会被越来越多次 “不经意” 地看到。还是同样的态度，我不会刻意掩饰什么，也不会主动宣扬什么。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我过去没有、将来也不会在博客上骂人。&lt;/p&gt;
&lt;p&gt;对于博客的存在，我的态度一直是不主动、不拒绝。我当然不会在意有人从我的 Github</summary>
        
      
    
    
    
    
    <category term="生活" scheme="https://smallyu.net/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>为什么数字货币使用区块链是政治问题</title>
    <link href="https://smallyu.net/2021/04/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E6%94%BF%E6%B2%BB%E9%97%AE%E9%A2%98/"/>
    <id>https://smallyu.net/2021/04/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E6%94%BF%E6%B2%BB%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-18T15:33:54.000Z</published>
    <updated>2024-08-03T19:07:10.026Z</updated>
    
    <content type="html"><![CDATA[<p>本来不想再专门提区块链。由于工作相关，接触相关话题比较频繁。</p><p>最近，一个高级别的技术管理吐槽我 “数字货币不可能用区块链” 完全是外行的观点，即使只是把四大行的大额交易记录到区块链上，也是很好的一件事情，而且可以用分层交易的技术架构，顺势解决小额支付在区块链上性能受限的问题……</p><p>我的逻辑很简单。</p><p>假如区块链在世界上从来没有出现过，没有存在过。在这种情况下，如果“上面”要求各大银行的交易数据必须同步一致可追溯。下面的人能做到吗？</p><p>不但能做到，而且可以做得很好。</p><p>区块链能解决的问题，不用区块链也能解决。这几乎是众所周知的事情。这也是为什么有人说 “区块链没有新技术” 的原因。</p><p>当然，这里的 “数字货币” 特指中国的数字货币，“区块链” 指——在讨论区块链怎么用之前，是不是应该先把 “区块链是什么” 搞清楚？奇怪的是，似乎没有人关心这个问题。</p><p>在这个方面上，和区块链形成对比的是人工智能。人工智能能做的事情，如果技术跟不上，就确实做不到。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;本来不想再专门提区块链。由于工作相关，接触相关话题比较频繁。&lt;/p&gt;
&lt;p&gt;最近，一个高级别的技术管理吐槽我 “数字货币不可能用区块链”</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>嘿，好久不见</title>
    <link href="https://smallyu.net/2021/04/11/%E5%98%BF%EF%BC%8C%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/"/>
    <id>https://smallyu.net/2021/04/11/%E5%98%BF%EF%BC%8C%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/</id>
    <published>2021-04-10T17:31:14.000Z</published>
    <updated>2024-08-03T19:07:10.041Z</updated>
    
    <content type="html"><![CDATA[<p>电影《小丑》里有一句似有非有的台词，我也想说这句话，“我记不清曾经发生过什么……”</p><p>也许只有像海子那样有奇特经历的人，才能写出“面朝大海，春暖花开”这样充满美好的诗句。不过这种梦想看似简单，那可是海景房……</p><p>想到几个关于外语学习的讨论：</p><ol><li><p>某网友在回答我的提问“50岁还能学会日语吗？”时提到，学习一种外语，至少要上千个小时。</p></li><li><p>一个视频里的女性作者说，她刚到美国的时候，完全听不懂英语，然后就每天看那种谈话节目。三年后的突然有一天，她发现自己可以听懂了。后来她说学英语要看视频节目尤其是谈话节目，不要指望阅读材料更不要查单词，英语单词那么多查能会几个……</p></li><li><p>罗永浩在讲话中提到，他用一年多的时间，像坐牢一样地学习英语，成为了新东方的 GRE 教师。他后来培训学校的一个老师，用了大概六个月的时候成为 GRE 入门课的教师。</p></li><li><p>一个演讲视频里提到，演讲者在很多国家进行英语的教育，有一次她遇到一个听众用英语提问题，那位听众的英语水平一听就是 low level 的，但奇怪的是，和这位听众交流起来，甚至这位听众和其他人用英语交流，对话都非常流畅，虽然确实只是用了 low level 的英语。</p></li></ol><p>我比较在意上千小时这个数字。</p><ol><li>假如一天看 1 个小时的视频，1000 小时就需要接近 3 年的时间。</li><li>假如一天学习 8 个小时，学习 1 年大概是 3000 个小时。当然，一天 8 小时不是一般人能坚持的。</li><li>假如一天学习 6 个小时，学习 6 个月大概是 1000 个小时。</li></ol><p>数字是巧合的，光看数字可能无法断定什么，但基本上能够认为，技能的掌握情况和付出的学习时长有非线性但很强的关联关系。</p><p>虽然我以前不认可“工作经验”这种评价方式（比如中国古代的官僚制度里，满几年才有机会升迁之类），但一种技能确实需要足够的时间才有可能熟练掌握。更折磨人的地方在于，技能的掌握不是断崖式的，不会说昨天还不会，到了某个时间点，今天突然就会了。现实世界根本不存在这种类型的惊喜。</p><p>更常见的情况是，昨天一句话里面听懂了 1 个词，十天后一句话里面听懂了 2 个词，直到一百天后一句话里面可以听懂 10 个词了，但一句话总共有 20 个词，听懂 10 个词根本于事无补。两百天后能听懂 20 个词就可以了吗？语句千变万化，语气、语调、语速……更准确一点的比喻，就像一张图片从分辨率很低开始逐渐清晰，在完全清楚之前无法准确地识别内容但又可以稍微获取到一些信息，而且这张图片分辨率变高的位置和速度是不均匀的。</p><p>《神探夏洛克》里的夏洛克·福尔摩斯有个人设，就是关于探案所需要的知识技能无所不知无所不会，看一眼鞋底上沾的泥土就能知道一个人在最近三天的行程，知晓各种枪械的型号、子弹的直径以及各种场合对枪械的使用习惯。会把犯人尸体的人头搁在家里的冰箱研究人类死亡后唾液凝固的过程。就是这样的探案鬼才，却不知道一些常人知道的常识，比如月亮是绕着地球转的，地球是围着太阳转的。</p><p>猜到我想说什么了吗？也许而且一定是的，并不需要全知全会。无论是知识还是技能。如果非要说一种技能掌握到什么程度最合适，只能说，当下的情况就是一切刚刚好。这种观点正好和胡适的“怕什么真理无穷”不谋而合 :P</p><p>顺便提一下，我对“知识”和“技能”的分类方法是，知识是可以短时间内知晓并理解的规则，而技能则是很多很多个知识组合起来形成的可以解决一类问题的方式。知识可以用 3 分钟的时间掌握，而技能需要 3 + 3 + 3 + …… 如果用有没有掌握某几个知识来判断一个人的技能情况，是以偏概全的。</p><p>生硬地切换一下话题。最近发现一种有趣的桌游叫剧本杀，虽然经常不尽人意但总还会留有兴趣。戏剧演员有两大表演体系，布莱希特体系和斯坦尼斯拉夫斯基体系，也就是体验派和表演派，在游戏里，我倾向于体验……当然，对这种游戏有个感触：我会玩的是游戏，不会玩的是人心。游戏有好有坏，剧本有好有坏，玩家有好有坏，体验有好有坏，心情有好有坏……</p><p>太阳底下没有新鲜事，但是太阳总会照常升起。</p><p>我也想有一间房子，面朝大海，春暖花开。</p><p>明天你好。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;电影《小丑》里有一句似有非有的台词，我也想说这句话，“我记不清曾经发生过什么……”&lt;/p&gt;
&lt;p&gt;也许只有像海子那样有奇特经历的人，才能写出“面朝大海，春暖花开”这样充满美好的诗句。不过这种梦想看似简单，那可是海景房……&lt;/p&gt;
&lt;p&gt;想到几个关于外语学习的讨论：&lt;/p&gt;
</summary>
        
      
    
    
    
    
    <category term="生活" scheme="https://smallyu.net/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>博客主题共享计划（草稿）</title>
    <link href="https://smallyu.net/2021/02/11/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E5%85%B1%E4%BA%AB%E8%AE%A1%E5%88%92/"/>
    <id>https://smallyu.net/2021/02/11/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E5%85%B1%E4%BA%AB%E8%AE%A1%E5%88%92/</id>
    <published>2021-02-11T06:48:31.000Z</published>
    <updated>2024-08-03T19:07:10.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>两个月前写下了这篇草稿，直到今天（04.10）想起来，觉得还是发出来。当初不发的原因之一是，我没能真正把项目维护起来。想把一个软件做到人人喜欢、人人适用其实是一件很有难度的事情，而且博客主题这样的东西受限于各种环境依赖的版本，还是不折腾了。借用《妖猫传》里的一句话，“事是假的，情是真的”。祝好。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>现在用的博客主题，模仿自王垠的博客 <a href="http://www.yinwang.org/">当然我在扯淡</a>。几年前，我把模仿的博客主题开源在 Github 上（<a href="https://github.com/smallyunet/hexo-theme-yinwang">smallyunet&#x2F;hexo-theme-yinwang</a>）。虽然我经常更新和优化自己博客的主题，但是开源的仓库已经很久没有更新了。</p><p>一方面，不确定模仿主题算不算侵权。另一方面，我一直心怀芥蒂的是，我并没有想要依靠这样的项目来“赚星星”，我甚至不希望这样的项目出现在我的 GitHub 主页上，于是不得不开始自定义主页的项目面板。总的来说，因为这个东西不是我的，就像《夏洛特烦恼》中的夏洛，穿越回 1997 年后依靠周杰伦的作品火遍西虹市，可他终究发现那些东西不是他的。他只是做了一个很漂亮的梦。</p><p>现在，我想继续维护这个将博客主题开源的项目。</p><p>捂着不让人用、让人用着不舒服，这显然都不对，愚昧不会阻止真理的传播，好用的东西也应该被更好的利用。我甚至希望，这个主题样式可以成为一种标志，标志受到王垠鼓舞的人们，标志拥有正直和善良品质的人们，标志拥有真知灼见的人们。</p><p>这不是宗教情绪，我们不盲目信任和崇拜某人，我们崇尚 <a href="http://www.yinwang.org/blog-cn/2017/11/01/power-of-reasoning">理性的力量</a>（by yinwang）。我们不拉帮结派，不宣扬、不强制别人使用或者不使用什么，不强制别人相信或者不相信什么。我们以某人为“偶像”，自诩为某人的“粉丝”，不是因为我们归属于某种团体的莫名其妙的优越感，而是因为我们从他那里学到了很多可贵而难以言喻的东西。当我们在说“喜欢某人”的时候，其实想表达的不是某人有多么厉害，而是在说，“我们从他那里学到了一些东西，因为会的这些东西，所以我们也很厉害”。</p><p>很意外今天突然想到了这样一件事情，有点意外，有点惊喜，有点害怕和担心。今天刚好是农历大年三十，新年快乐。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="计划" scheme="https://smallyu.net/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>区块链：下一代数字身份认证体系的基石</title>
    <link href="https://smallyu.net/2020/12/08/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB%E7%9A%84%E5%9F%BA%E7%9F%B3/"/>
    <id>https://smallyu.net/2020/12/08/%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E5%AD%97%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB%E7%9A%84%E5%9F%BA%E7%9F%B3/</id>
    <published>2020-12-08T12:02:38.000Z</published>
    <updated>2024-08-03T19:07:10.040Z</updated>
    
    <content type="html"><![CDATA[<p>如何在互联网的世界中，证明“我是我”？在 A 网站认证过了身份信息，到了 B 网站又需要认证一次？手持身份证拍照上传、人工审核，流程太繁琐？多个账户密码记不清、容易混，管理起来困难？自主主权的数字身份（Self-soverieign identity, SSI）正是可以解决这些问题的理念。</p><p>SSI 是数字身份运动中的观念，指只有用户自己拥有全部的、完整的数字身份信息，没有其他管理者和组织参与的数字身份体系。在 SSI 的理念中，用户拥有属于自己的去中心化的惟一身份标识（Decentralized identifiers, DIDs），用户可以完全控制自己的身份信息，可以在任何时候使用、更新或者彻底删除信息。用户可以创建并管理自己的可验证证明（Verifiable Credentials），自主决定在什么时候使用和分享自己的证明信息，而不需要请求其他中心化的机构、通过机构授权来使用自己的个人数据。</p><p>使用 SSI 的系统，所有的密钥信息都可以通过数字身份钱包进行管理，使用一个账号就可以登录所有的网站。在钱包终端中，用户可以随时向权威机构申请签发证明，包括身份证、驾驶证、居住证等各种形式的证件，都将以数字证明的形式储存在手机或电脑上。数字证明拥有机器可读、机器可验证的特性，不但可以放心地展示给第三方应用，第三方应用还可以在没有人工干预的情况下，直接验证证明的有效性，不需要签发机构的参与。</p><p>得益于区块链技术的不断发展，SSI 理念的实现逐渐成为可能。区块链系统本身就是点对点网络，天然拥有去中心化的特性，结合独特的数据结构设计和密码学技术的应用，加上共识算法在多节点数据同步方面的优秀能力，区块链不但能够保护数据的隐私安全，而且数据一旦写入系统便任何人无法篡改，为数据提供了极高可信度的储存环境。在 SSI 系统的建设中，将区块链作为可验证数据的数据中心（Verifiable data registry）无疑是最好的选择。</p><p>SSI 目前已经有诸多先例。2017 年，Sovrin 基金会发布了世界上首个公开的用于自主主权的数字身份的分布式账本网络，整个系统运行在开放标准以及公开源码的 Sovrin 协议之上，由 Linux 基金会的 Hyperledge Indy 项目维护。Sovrin 在 2018 年公布的白皮书中自问自答，“为什么网络世界中没有像物理世界一样可以用来证明身份的证书？直到区块链技术的出现，我们解决了这个问题！”结合 W3C 的 DIDs，Sovrin 提出了完整的数字身份和证明的解决方案。Sovrin 的主意一直都很明确，就是一定要构建和使用公开的、任何人都可以访问的、像比特币和以太坊一样的区块链网络。</p><p>eSSIF-Lab（European Self-Sovereign Identity Lab）是另一个案例。欧洲区块链联盟提出的 EBSI（The European Blockchain Services Infrastructure）是一个横跨欧洲的分布式节点网络，提供跨境的公共服务，有 28 个成员国签署了相关声明。eSSIF-Lab 项目是 EBSI 的一部分，由欧盟委员会资助，旨在促进 SSI 成为下一代开放、可信、安全的数字身份解决方案。欧盟曾在 2014 年 7 月 23 日建立了针对欧盟共同市场电子交易的电子身份识别和可信服务的法规 eIDAS（electronic IDentification, Authentication and trust Services），2019 年 5 月，eIDAS 宣布支持基于 W3C 相关规范的自主主权的数字身份。</p><p>微软在相关领域也表现活跃，2018 年 10 月，微软发布《去中心化的身份》白皮书，介绍了基于区块链的去中心化数字身份系统建设的技术方案，包括 DIDs 规范、去中心化的数据系统、DID 用户终端、DID 通用解析器、DID 身份中心、DID 认证系统、去中心化的客户端和服务等核心模块，详细说明了各模块组件以及各种角色在系统中的交互流程，为 SSI 系统的建设提供了非常好的模板。目前，微软已经提供公开的服务平台，可以体验相关的产品和能力。</p><p>此外，构建在以太坊和 IPFS 网络上的 uPort、使用自研区块链和支持第三方 DApp 的 Blockstack、能够适配比特币网络的 ShoCard 等都是优秀的案例。国内的厂商和机构也在进行相关的工作，如蚂蚁链提供的分布式身份服务 DIS（Decentralized Identity Service）、腾讯云的数字身份标识解决方案、微众银行的基于区块链的分布式多中心的技术解决方案 WeIdentity 等，都利用了区块链去中心化、数据高度可信的技术特点，构建了可靠的数字身份标识和认证体系。</p><p>区块链是一项极具潜力的先进技术，具有非常广阔的发展前景和应用空间，无论是国家政策的支持还是实际案例的应用，都体现出区块链未来的无数种可能。我们也在积极探索和推进区块链相关的技术发展和场景落地，将区块链与同态加密、联邦学习、多方计算、零知识证明等前沿技术结合起来，使用最优秀的技术能力，促进下一个互联网时代的到来。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;如何在互联网的世界中，证明“我是我”？在 A 网站认证过了身份信息，到了 B 网站又需要认证一次？手持身份证拍照上传、人工审核，流程太繁琐？多个账户密码记不清、容易混，管理起来困难？自主主权的数字身份（Self-soverieign identity,</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>网页技术能实现3D建模吗？</title>
    <link href="https://smallyu.net/2020/09/20/%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF%E8%83%BD%E5%AE%9E%E7%8E%B03D%E5%BB%BA%E6%A8%A1%E5%90%97%EF%BC%9F/"/>
    <id>https://smallyu.net/2020/09/20/%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF%E8%83%BD%E5%AE%9E%E7%8E%B03D%E5%BB%BA%E6%A8%A1%E5%90%97%EF%BC%9F/</id>
    <published>2020-09-20T14:58:39.000Z</published>
    <updated>2024-08-03T19:07:10.126Z</updated>
    
    <content type="html"><![CDATA[<p>网页技术（HTML5、CSS3、JavaScript）能实现效果炫酷的 3D 建模甚至是 3D 动画效果吗？我暂时认为是不可以的。比如期望这样的页面效果：</p><img src="preview.png" class="no-shadow" width="100%"><p>d3.js 是不用考虑的，它仅仅是一个数据可视化的工具，和 3D 建模是两个领域。</p><p>three.js 似乎是目前比较流行的 3D 建模库。假如 three.js 可以做到的话，应该怎么做呢？首先的想法是画这样一个正方体出来：</p><img src="cube_target.png" class="no-shadow" width="20%"><p>3d 建模里的立方体相当于编程世界的 hello world，很容易就能出来：</p><img src="cube_1.png" class="no-shadow" width="20%"><p>给场景加上灯光，正方体就不是黑漆漆的了。然后给正方体加上颜色，改一下场景的背景色，再把灯光调到正方体的上面，正方体就能像样子一点了：</p><img src="cube_2.png" class="no-shadow" width="20%"><p>目标正方体的边缘是发光的，而且是渐变色。怎么给正方体加一个边缘线呢，正方体本身是没有这种属性的，只能用线性材料（three.js 里的 LineBasicMaterial，正方体用的是 MeshPhongMaterial）再画一个正方体出来，套在实体正方体上：</p><img src="cube_3.png" class="no-shadow" width="20%"><p>怎么让线性的正方体发光呢？线性材料（LineBasicMaterial）是不能使用渐变色的，只有着色器材料（ShaderMaterial）可以使用渐变色。着色器材料可以实现多彩的效果，比如这样（来自 <a href="https://stackoverflow.com/questions/52614371/apply-color-gradient-to-material-on-mesh-three-js">StackOverflow</a>），：</p><img src="line_1.png" class="no-shadow" width="20%"><p>但是到这里遇到问题了。在 three.js 里，渲染一个物体需要两个参数，一个是 geometry（几何体），一个是 material（材料），线性材料和着色器材料都是材料的种类。(TorusKnotGeometry 是上图用到的几何形状)</p><pre><code>线条正方体 = EdgesGeometry + LineBasicMaterial渐变曲线条 = TorusKnotGeometry + ShaderMaterial</code></pre><p>现在想要线性材料和着色器材料（LineBasicMaterial 和 ShaderMaterial）组合是不合逻辑的，我没有找到实现发光的正方体边缘效果的方法。把着色器用在正方体的效果是这样的（颜色从 0x215ec9 到 0x000000）：</p><img src="cube_4.png" class="no-shadow" width="20%"><p>所以然后呢？我意识到即使实现了一个好看的正方体，离渲染出整张图还差的太多。比如这样的文字效果怎么做？</p><img src="part_1.png" class="no-shadow" width="30%"><p>three.js 的 Texture 本身效果是不错的，可是怎么把文字安安稳稳的放到正方体上，还带透明的黑色背景框？再比如这五彩斑斓的线条，以及准确的箭头指向：</p><img src="part_2.png" class="no-shadow" width="15%"><p>还有整个图上十多种元素的位置布局、动画效果。</p><p>我相信 three.js （WebGL）在技术能力上是可以实现这样效果的，甚至官方的 example 里网页游戏都有，不过假如要实现一个网页游戏，一定会用到图像素材，素材从哪儿来呢？还是得回到 PS、AI 之类的工具上，如果用上了那样的生产力工具，就没有必要用 js 来写布局和动画了。单纯的网页技术似乎很难完全解决 3D 建模的问题。H5 动画也是类似的情况。</p><p>单纯写代码来 3D 建模的另一个问题是不直观，代码是违反直觉和视觉的，写个网页、APP界面似乎还可以（二维的）。如果可以在一个画布上直接放置正方体和线条，然后鼠标拖动改变位置、调整颜色，以及添加各种其他元素，像玩游戏（比如我的世界）一样操作简便，不就比写代码好多了吗……那不就是 Adobe Animate 吗？</p><p>可惜 Adobe Animate 没有 Linux 版本，而且 Linux 下的替代品 Blender 有点性能问题。</p><img src="blender.png" class="no-shadow" width="100%"><p>回到一开始期望的效果图上，图片出自一个大屏 UI 的 <a href="https://www.zcool.com.cn/work/ZMjg2NTA1Njg=.html">设计演示</a>，其实原效果不是三维的，作者使用的工具是 PS、AI。那么在仅需要二维效果的前提下，网页技术能实现吗？如果要用代码实现各种图形，就依然还是三维建模的问题。最简单的方式是拿个背景图，把文字贴到上面。背景图从哪儿来呢？</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;网页技术（HTML5、CSS3、JavaScript）能实现效果炫酷的 3D 建模甚至是 3D 动画效果吗？我暂时认为是不可以的。比如期望这样的页面效果：&lt;/p&gt;
&lt;img src=&quot;preview.png&quot; class=&quot;no-shadow&quot;</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>“做正确的事情，然后等着被解雇”</title>
    <link href="https://smallyu.net/2020/08/22/%E2%80%9C%E5%81%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%8C%E7%84%B6%E5%90%8E%E7%AD%89%E7%9D%80%E8%A2%AB%E8%A7%A3%E9%9B%87%E2%80%9D/"/>
    <id>https://smallyu.net/2020/08/22/%E2%80%9C%E5%81%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%8C%E7%84%B6%E5%90%8E%E7%AD%89%E7%9D%80%E8%A2%AB%E8%A7%A3%E9%9B%87%E2%80%9D/</id>
    <published>2020-08-22T08:17:53.000Z</published>
    <updated>2024-08-03T19:07:09.974Z</updated>
    
    <content type="html"><![CDATA[<p>“做正确的事情，然后等着被解雇”，这句话出自 Google 工程师 Tan Chade-Meng 的博客文章《<a href="http://chademeng.com/me/do-the-right-thing-wait-to-get-fired/">DO THE RIGHT THING, WAIT TO GET FIRED</a>》，一本关于程序员协作的书《<a href="https://book.douban.com/subject/11154471/">Team Geek: A Software Developer’s Guide to Working Well with Others</a>》引用了博客中的内容（P126），然后书里的内容又被 CoolShell 的文章《<a href="https://coolshell.cn/articles/17972.html">我看绩效考核</a>》引用。我在 CoolShell 的文章里第一次看到了这段话。看到之后，念念不忘，现在一定要把它复制过来：</p><blockquote><p>New Google employees (we call “Nooglers”) often ask me what makes me effective at what I do.  I tell them only half-jokingly that it’s very simple: I do the Right Thing for Google and the world, and then I sit back and wait to get fired.  If I don’t get fired, I’ve done the Right Thing for everyone.  If I do get fired, this is the wrong employer to work for in the first place.  So, either way, I win.  That is my career strategy.</p></blockquote><p>得多么强大的自信和力量，才能说出这样的话啊！尽管原作者也说，这是半开玩笑的说法，尽管作者已经有了一些影响力，做过了一些“正确”的事情——没有身份和地位确实很难说出这样的话，但这句话背后的精神会一直鼓励和激励着我们——你知道我说的是谁，经久不衰，生生不息。也有不少文章展开讨论这句话的含义，比如《<a href="https://brendansterne.com/2013/07/11/do-the-right-thing-wait-to-get-fired/">Do the right thing, Wait to get fired</a>》。</p><p>当然，这句话不能反过来说，不是说等着被解雇，就意味着在做正确的事了。这句话也不适用于喜欢混吃等死的人，毕竟努力不一定有结果，但不努力一定很舒服 :-P 我得认真想一下什么是“正确的事”，以及如何做一些“有价值的事”。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;“做正确的事情，然后等着被解雇”，这句话出自 Google 工程师 Tan Chade-Meng 的博客文章《&lt;a href=&quot;http://chademeng.com/me/do-the-right-thing-wait-to-get-fired/&quot;&gt;DO THE</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>给区块链一个定义</title>
    <link href="https://smallyu.net/2020/08/09/%E7%BB%99%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%80%E4%B8%AA%E5%AE%9A%E4%B9%89/"/>
    <id>https://smallyu.net/2020/08/09/%E7%BB%99%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%80%E4%B8%AA%E5%AE%9A%E4%B9%89/</id>
    <published>2020-08-09T08:06:45.000Z</published>
    <updated>2024-08-03T19:07:10.126Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，区块链似乎都没有一个明确的定义，伴随区块链出现的词语经常是去中心化、溯源、不可篡改、以信用为基础、下一代价值互联网之类，这些都是区块链的特性，不是区块链的组成，这些词都在说区块链有什么，没有说区块链为什么会有那些，以及为什么要有那些。</p><p>感觉上很多东西都没有明确的定义，比如，计算机是什么？都知道是那么一个东西，可以打游戏上网，稍微专业点的会说是基于冯诺依曼体系结构的、有 5 个组成部分的什么什么机器。其实计算机可以认为是“做计算的机器”，就这么简单。冰箱是什么？“一个放东西的柜子，有一些冷冻的功能”，就可以了。设计模式是什么？一种软件程序设计的范式。微服务是什么？一种软件架构的模式。所以区块链是什么？奇怪的是，区块链（blockchain）这个词不知从何而起，从来没有人明确提出这个概念，比特币白皮书里也只是提到 “chain of block”。</p><p>我以前对区块链有过一些不成熟的认识，虽然好像也没什么错，但不够清晰，尤其是没搞清楚一个问题，区块链是什么？现在来看，区块链的定义应该是：</p><blockquote><p>区块链是一种数据协同软件，或者说，区块链是一种用来同步数据的软件。</p></blockquote><p>数据协同软件决定用什么样的数据结构通过什么样的通信机制同步哪些数据。区块链不是数据库，区块链不负责储存数据，储存数据的事情会交给真正的数据库来做，区块链并不关心数据是怎么存在磁盘上的，不关心储存结构是否合理，利用率高不高，处理速度快不快。区块链关心数据以什么样的方式同步到其他的机器上，如何及时同步，以及其他机器同步过来的数据有没有问题。可以说，区块链是对数据协同软件的一种实现。</p><p>因为是数据协同软件，所以区块链多节点、去中心化，这显而易见。</p><p>溯源是指交易可溯源，只要数据之间有关联关系就可以，这是数据模型决定的，比如 UTXO。</p><p>链式的数据结构，是为了方便数据协同软件校验数据的完整性，类似用 md5 判断文件是否完整。这种数据结构并不是必要的，数据的全量对比也可以实现目的，只是效率非常低下。所以采用加密算法做摘要然后放到下一部分数据里的做法，相当于保证了一大块数据是完整的，仅此而已。</p><p>至于不可篡改，其实是数据协同软件带来的特性。区块链的不可篡改，并不是数据不能修改，而是改了之后其他节点不认可。这是不一样的，数据不能更改是技术问题，比如不提供更新数据的接口，用户就没有修改数据的渠道，通过技术手段可以控制。改了之后其他节点不接受，是一种机制，这种机制问题已经脱离技术领域。</p><p>区块链目前的发展受技术限制吗？计算机的计算理论包含两个主要部分，可计算性理论和复杂度理论。可计算性理论判断一个问题能不能用算法解决，复杂度理论意在提高算法的效率。和区块链有关系吗？退一步说，区块链需要计算吗？不需要，没有关系，不受限制。有个有趣的脑洞问题，如果把全世界的人都拉到一个微信群里，会发生什么？起码屏幕上的消息肯定刷不过来了。如果全世界的数据共用一条区块链，会发生什么？所以区块链最终还是机制的问题，不是技术问题。</p><p>比特币和区块链是两个概念，比特币是一种使用了区块链做数据同步的交易系统，比特币首先是一个交易系统，其次才需要的数据同步。这也是我以前犯的概念上的错误，把区块链等同于比特币了。很多对区块链概念比较模糊的人，提到区块链也都会往比特币之类的数字货币上想。记得去年参加过一个分享会，主讲人是某知名交易所总监，分享标题是区块链和国家政策什么的，整个会议下来，讲的却全是比特币的趣闻轶事。</p><p>区块链是比特币的组成部分。比特币的作者看到了比特币的价值，把软件和白皮书发布出来了。为什么比特币的作者没有把区块链的概念抽离出来，发个通用软件和说明书？是水平不够没有意识到区块链潜在的巨大价值吗？不是。区块链的提出，是因为人们看到了比特币的价值，想要复制比特币的成功，所以把比特币的技术组成提取出来，叫做区块链。可惜比特币是一个设计巧妙的系统，单独把某些技术特点拿出来难以产生预期的价值，这也是区块链的现状。这是现代版技术圈的东施效颦。</p><p>智能合约（Smart Contract）早在 1997 年由一位金融、法律从业者提出，“智能”是指和纸质合同相比，智能合约达到某一条件时就会自动执行某些操作，确实比纸质合同智能了一点，尤其在那个年代，数字化还没有普及，描述这是一种智能并不为过。而且，作者明确说，智能合约没有用到人工智能。</p><p>智能合约抽象一下，达到某一条件自动执行一些动作，不就类似编程语言的条件语句吗，事实上现在的智能合约大多是用图灵完备的编程语言实现的。用编程语言来描述合约的致命问题在于，编程语言的表达能力比自然语言弱太多了，如果试图用编程语言来重写保险说明书里的所有条文，“发生什么，就赔偿多少……”，这种改写的成本太高了，而且很多时候法律条文需要专业律师、法官解释和判断，现实世界的逻辑远比程序逻辑复杂，编程语言是搞不定的。</p><p>一种数据同步软件不应该被推崇，区块链被神化、妖魔化了。也因此，不能说区块链没有价值，因为区块链是且只是一种工具软件。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;一直以来，区块链似乎都没有一个明确的定义，伴随区块链出现的词语经常是去中心化、溯源、不可篡改、以信用为基础、下一代价值互联网之类，这些都是区块链的特性，不是区块链的组成，这些词都在说区块链有什么，没有说区块链为什么会有那些，以及为什么要有那些。&lt;/p&gt;
&lt;p&gt;感觉上很多东西</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>构造函数为什么没有返回值？</title>
    <link href="https://smallyu.net/2020/05/16/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F/"/>
    <id>https://smallyu.net/2020/05/16/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F/</id>
    <published>2020-05-16T04:19:44.000Z</published>
    <updated>2024-08-03T19:07:10.111Z</updated>
    
    <content type="html"><![CDATA[<p>刚才同学问了我一个问题，C++里new一个类的成员函数是什么意思？</p><p>……我心想，new成员函数？还有这种操作？</p><p>后来我问，这个成员函数，名字是不是和类名一样？</p><p>他说一样，就是构造函数。</p><p>……那不就是new一个对象吗？</p><p>然后他问了一个深刻的问题，为什么构造函数没有返回值？</p><p>我说new的是类，new后面指的是类名，不是成员函数。</p><p>可是类没有参数啊？</p><p>构造函数有参数。</p><p>但是构造函数没有返回值啊？</p><p>啊？</p><img src="face.jpeg" width="30%" /><p>这是一段简单的代码：</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;class Test&#123;    public:        Test(int num);&#125;;// 构造函数，有参数没有返回值Test::Test(int num)&#123;    cout &lt;&lt; num &lt;&lt; endl;&#125;int main()&#123;    // 对象赋值给了变量    Test* test = new Test(1);    return 0;&#125;</code></pre><p>其实不看代码也能想到这个场景。new一个对象的时候，new后面的变量，指的的类名，还是方法名？</p><p>如果指的是类名，类本身没有参数，也没有返回值，而且new这个关键字在代码的行为上也会特殊于其他语句。另外，类会有一个默认的无参构造方法，如果new的是类，要默认的构造方法干嘛？</p><p>如果指的是函数名，构造函数没有返回值，像上面的代码里明显就把<code>new Test(1)</code>赋值给了<code>Test* test</code>。</p><p>构造函数为什么没有返回值？因为构造函数在执行的时候，告诉编译器在内存上开辟多大的空间，初始化了成员变量，确定了this的地址，然后干了这些事情之后，就不允许用户自定义返回值的类型了？因为构造函数的返回值一定且必须是它自己，所以就不需要对用户透明了（编译器为什么要“擅自”做这样的事情？）？</p><p>构造函数为什么没有返回值？我并不知道这个问题的答案，也不大有兴趣知道。但这个问题带给我很大的启发，也带给我很大的震撼，“new成员函数”这种说法真是思路清奇。我们对太多东西习以为常，司空见惯，觉得它应该就是那样，却很少问它为什么是那样，很少认真去思考和认识很多事物。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;刚才同学问了我一个问题，C++里new一个类的成员函数是什么意思？&lt;/p&gt;
&lt;p&gt;……我心想，new成员函数？还有这种操作？&lt;/p&gt;
&lt;p&gt;后来我问，这个成员函数，名字是不是和类名一样？&lt;/p&gt;
&lt;p&gt;他说一样，就是构造函数。&lt;/p&gt;
&lt;p&gt;……那不就是new一个对象吗？&lt;</summary>
        
      
    
    
    
    
    <category term="设计" scheme="https://smallyu.net/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>关于人的能力，经验，和……</title>
    <link href="https://smallyu.net/2020/05/03/%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%8C%E7%BB%8F%E9%AA%8C%EF%BC%8C%E5%92%8C%E2%80%A6%E2%80%A6/"/>
    <id>https://smallyu.net/2020/05/03/%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%8C%E7%BB%8F%E9%AA%8C%EF%BC%8C%E5%92%8C%E2%80%A6%E2%80%A6/</id>
    <published>2020-05-03T13:50:15.000Z</published>
    <updated>2024-08-03T19:07:10.030Z</updated>
    
    <content type="html"><![CDATA[<p>最近好像没什么特别的事情，工作内容比起以前变多了，占据了很多时间，工作之外的空隙时间，似乎没有太多精力去关注学习。</p><p>这个博客上的内容，大概就那么两三种，一种是想到和学习到的技术方面的东西，再一种是工作和生活方面的事情，遇到的或者想到的引起了一些感悟的事情，第三种也许就是流水账、幻想之类，单纯做记录用，写下发生了什么事情。设想中博客的内容频率大概两周到一个月左右，时间太短没什么可说的，时间太长就有点长了。如果连续很长一段时间没什么可写或者不想写，就意味了发生了危险的事情，要么是松懈于动脑子了，要么是心理产生了不正常的问题。所以博客也可以作为自己的照妖镜。</p><p>最近纠结于的一点事情，问题在于很难得出什么结论。</p><p>(1)</p><p>前段时间周末的时候一个读研的同学问了我一点比较基础的操作问题。一个C++的项目，从Github克隆下来，用VS2012打开后编译报错，说找不到文件。我很少接触C++，不过还是尽快了解了一下。项目叫 <a href="https://www.wxishiko.com/wxCharts/">wxCharts</a>，是一个图表的UI库，编译的时候几乎找不到所有的头文件。他的老师告诉他在常规里把外部依赖库加上，他就加啊加还是找不到头文件。</p><p>我说把找不到的文件随便挑一个，在磁盘里搜一下，搜不到……</p><p>后来我看了一下wxCharts的官网，知道了wxCharts是依赖于 <a href="https://www.wxwidgets.org/">wxWidgets</a> 的。wxWidgets是一个GUI库，wxCharts只是这个GUI库的样式组件。然后我本地测试了一下，编译安装wxWidgets后wxCharts就能编译过了。</p><p>原因找到了，但是他说他已经安装过wxWidgets了。我当时不太确定window下vs的<code>生成</code>和linux的<code>make install</code>是不是一回事，就说有那么几种方案，一是把wxWidgets下面的wx文件夹复制到wxCharts下（wx文件夹是项目默认的依赖文件夹，类似Go项目的src目录），二是把wxCharts的项目源码放到wxWidgets项目里试试能不能编译过，三是重新安装一下wxWidget，一定要全局安装，环境变量里配置一下。</p><p>后来折腾半天总算是能找到头文件了，外部依赖那里配置的路径有问题，用了错误的环境变量作为路径的变量，还重复引用了错误的路径。但是编译还不通过，找不到什么什么文件的，又折腾了一下，就是除了头文件还要引入动态依赖库，而且编译了生产版本的目录位置不一样，后面带d的是debug版本……</p><p>其实整个过程面对的问题很简单，就是找不到项目依赖，如果Java项目必定轻车熟路了（话说其实有工作好几年的同事面对项目依赖这种低级问题有时候还难以搞定的）。这是我一个关系不错的同学，本科时我们天天坐在床上打王者荣耀。他的实力我还是稍微有一些了解，可能学术能力比较强，但计算机方面真是比小白还小白。但要说学术能力多强其实本科成绩还没我好，也就是考研的一年多确实实实在在的努力了。</p><p>稍有感触的一点是，说起来现在他算是一所还不错的211大学的研究生，我的学历依然是双非本科，学历上差了好几个段位。至于能力的话，只能说曾经有一个考研的机会放在我面前，我没有珍惜，直到失去了也没有一丝丝悔意，如果上天给我一个重新来过的机会，我一定会做出和现在相同的决定，如果非要给这个决定加一个期限，我希望是，有生之年。</p><p>(2)</p><p>有一个我以前也提到过的让我感觉充满矛盾的同事，实际的动手能力和对工作的负责程度真是让我感觉理解不了。但是后来遇到几次问题，发现她毕竟还是有丰富开发经验的，经验方面真的难以反驳的超过我。</p><p>当时面对比较简单的一个递归的问题。我之前也确实一直没搞明白，一个对象传到一个函数里面，是值还是引用传递？</p><pre><code class="JavaScript">function a() &#123;    obj = &#123; &quot;a&quot;: 1 &#125;    b(obj)    console.log(obj)&#125;function b(obj) &#123;    // 方式1    obj = 1    // 方式2    obj = &#123; &quot;a&quot;: 2 &#125;    // 方式3    obj.a = 2&#125;</code></pre><p>必须先搞清楚这个问题，才能使用递归解决问题。方式1直接给对象赋值，方式2给了参数一个新的对象，方式3改变了对象的属性。我当时是没有概念的，一心想着是不是能用原型链解决这个问题。我也知道她不太清楚这个问题，但是她疑疑惑惑的提了一句这个和堆栈是不是有关系，然后又很不确定的没再提了。</p><p>我以为没有关系，我以为她是随口说的。我错了。</p><p>对象是引用传递的，这一点没有问题，但对象的属性有没有改变，取决于改变的是对象的栈空间还是堆空间。给对象赋新值，不管是简单值还是复合值，都会将对象的变量指向新的栈地址，所以对象的属性并不会改变。如果直接用方式3的写法，改变的是对象指向的堆里面的内容，原对象的属性就会改变。</p><p>所以其实经验在一定程度上是有用并且难以轻易超越的，经验基本上无法通过捷径获得。</p><p>(3)</p><p>能力通过经验获得，强大的能力可以更快更有效的获取更高级的经验，然后这些经验会使能力更加强大。</p><p>也许能力和经验是相辅相成的，类比所谓的“经验和洞察力”。其实这里的“能力”确实稍微有点“洞察力”的意味。有时候在招聘的时候感觉招聘方一味强调多少多少年经验，好像用工作经验多的人就比用经验少的人占了便宜一样，但是吧，关于能力和经验……</p><p>这两天下了一个编曲的软件，简单尝试一下，感觉编曲这个事情，其实还是很难的，和编程虽然只有一字之差，技能要求却是截然不同而且更高的。现在各种培训班、在线课程，编程已经几乎没有门槛，当“全民编程”的时代来临后，我们改怎么面对这个世界呢。未来的编程也许不会把MVC、ORM什么的渗透到生活中，但一套物联网设备、自动化设备，或者iOS系统快捷指令的未来版本，如何更加适合人类个性化的生活习惯，可能多少也会需要点“编程”的逻辑。</p><p>PS:</p><img src="chortcut.png" width="30%" /><center>iOS 13的快捷指令已经支持基本的语句逻辑</center>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近好像没什么特别的事情，工作内容比起以前变多了，占据了很多时间，工作之外的空隙时间，似乎没有太多精力去关注学习。&lt;/p&gt;
&lt;p&gt;这个博客上的内容，大概就那么两三种，一种是想到和学习到的技术方面的东西，再一种是工作和生活方面的事情，遇到的或者想到的引起了一些感悟的事情，第三</summary>
        
      
    
    
    
    
    <category term="学习" scheme="https://smallyu.net/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>从Erlang开始了解Actor模型</title>
    <link href="https://smallyu.net/2020/03/31/%E4%BB%8EErlang%E5%BC%80%E5%A7%8B%E4%BA%86%E8%A7%A3Actor%E6%A8%A1%E5%9E%8B/"/>
    <id>https://smallyu.net/2020/03/31/%E4%BB%8EErlang%E5%BC%80%E5%A7%8B%E4%BA%86%E8%A7%A3Actor%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-03-31T04:47:59.000Z</published>
    <updated>2024-08-03T19:07:10.029Z</updated>
    
    <content type="html"><![CDATA[<p>Actor Model是一个宽泛的概念，早在上个世纪就被提出来，它将Actor视作一个整体，可以是原子变量，也可以是一个实体，也可以代表一个线程，Actor之间相互通信，每个Actor都有自己的状态，在接收到其他Actor的消息后可以改变自己的状态，或者做一些其他事情。一般提到Actor，会用Erlang、Elixir或Akka来举例，它们都在一定程度上实现了Actor模型。</p><p>前端的MVVM框架React、Vue等都有各自的数据流管理框架，比如Redux和Vuex，这些数据流管理框架中有几个类似的概念，Action、Reducer、State之类，这些概念有时候会让人感到迷惑。现在前端变得越来越复杂，其中有一些东西可能是借鉴后端的，像TypeScript的类型系统。我好奇这些前端框架里的Action和后端的Actor模型在概念上是否有相似的地方。</p><p>其实Action的本质是简单的，甚至代码的原理也是简单的，reducer里面用switch判断不同的操作类型，去调不同的方法。最简化的形式就是一个方法Action改变了全局变量state的值。Redux文档里说它的设计来自Flux架构，Flux架构的来源暂时不得而知，但也不太可能说是受到了Actor模型的启发。</p><pre><code class="JavaScript">let state = nullfunction action(val) &#123;  state = val&#125;</code></pre><p>Erlang是一门古老的编程语言，也是一门典型的受Actor Model启发的编程语言。单纯去理解概念是空泛的，从具体的、特定的语言入手也许能帮助我们探索这些理论。就像学习FP，选择Haskell要好过Java很多倍。Elixir是基于Erlang虚拟机的一门语言，与Erlang的关系类似Scala和Java的关系，也因此Erlang的语法相对简单和干净一点。</p><h3 id="Erlang"><a href="#Erlang" class="headerlink" title="Erlang"></a>Erlang</h3><p>Erlang的代码块以<code>.</code>结尾，代码块可能只有一行，也可以有多行，<code>.</code>的作用类似于<code>&#125;</code>，只是Erlang里没有<code>&#123;</code>。代码块内的语句以<code>,</code>结尾，意味一个语句的结束，相当于一些语言的<code>;</code>。</p><p>Erlang将一个程序文件定义为一个模块，在命令行中使用<code>c(test).</code>可以加载模块。模块名称必须和文件名称一致：</p><pre><code class="Erlang">-module(test).</code></pre><p>文件头部需要定义程序export的函数，这是模块的出口：</p><pre><code class="Erlang">-export([start/0, ping/3, pong/0]).</code></pre><p>这里导出了3个函数，方括号和其他语言一样表示数组，函数名称后面的<code>/0</code>、<code>/3</code>指函数参数的个数。start函数将作为程序的主入口，负责启动整个程序，ping负责发送消息，pong负责接收消息并做出响应。</p><p>Erlang里面有个<code>process</code>的概念，它不是线程，也不是指计算机层面的进程，它就是<code>process</code>，或者也能把它当做线程，但是要明白它和线程不一样。我们将启动两个process，一个负责ping，一个负责pong，模拟消息的传输和交互。可以类比启动了两个线程，一个负责生产，一个负责消费。</p><pre><code class="Erlang">ping(0, Pong_PID, StartTime) -&gt;     Pong_PID ! &#123;finished, StartTime&#125;;</code></pre><p>这是ping函数的第一部分，是ping函数的一个分支，接收3个参数，如果第一个参数是0，就会执行这个函数中的语句。第二个参数<code>Pong_PID</code>指包含pong的process，第三个参数指程序启动的时间，用于记录程序的运行时长。函数体内只有一个语句，<code>!</code>是发送消息的意思，意为将数据<code>&#123;finished, StartTime&#125;</code>发送到id为<code>Pong_PID</code>的process中，其中finished是一个<code>Atom</code>，作为标识发送到pong那里。Atom是Erlang的数据类型之一，相当于……不需要声明的常量。</p><pre><code class="Erlang">ping(N, Pong_PID, StartTime) -&gt;     Pong_PID ! &#123;ping, self()&#125;,    receive        pong -&gt;             io:format(&quot;~w~n&quot;, [N])    end,    ping(N - 1, Pong_PID, StartTime).</code></pre><p>这是ping函数的第二部分，如果函数接收到的第一个参数不等于0，就会执行这个函数内的语句。这一部分函数在接收到请求后，首先会做和分支一同样的事情，就是把数据<code>&#123;ping, self()&#125;</code>发送给pong，区别在于这里的标识为<code>ping</code>而不是<code>finished</code>，pong那里会根据这个标识做不同的操作，至于第二个参数，<code>self()</code>会返回当前process的id，也就是把ping的id传给了pong，用以pong回复消息。pong会选择性的使用第二个参数。</p><p>把数据发送到pong之后，有一个<code>receive ... end</code>的代码段，这个代码段会阻塞当前程序的执行，直到当前process接收到数据。代码段里是一个简单的模式匹配，<code>pong</code>是一个Atom类型的变量，如果接收到pong这样的标识，就会执行<code>-&gt;</code>后面的语句。<code>io:format</code>是一个简单的格式化输出，把N的值打印到屏幕上。</p><p>receive结束之后，马上又调了一下ping自己，递归……直到N为0，也就是说ping和pong的交互会持续N次，<code>io:format</code>那里会把交互次数打印出来。这是ping函数的两个分支，pong函数和ping函数的程序类似：</p><pre><code class="Erlang">pong() -&gt;    receive        &#123;finished, StartTime&#125; -&gt;             io:format(&quot;The End&quot;);            io:format(&quot;~w~n&quot;, [erlang:timestamp()]);            io:format(&quot;~w~n&quot;, [StartTime]);        &#123;ping, Ping_PID&#125; -&gt;            Ping_PID ! pong,            pong()    end.</code></pre><p>pong函数在入参层面没有分支，但是receive里有两种匹配，如果接收到了结束标识finished，会把开始时间和结束时间都打印出来，然后程序结束。如果接收到的标识是ping而不是finished，首先给Ping_PID也就是ping的process一个pong的响应，然后调了一遍自己，相当于先发了一个消息出去，接着自己等待消息的回复，如果没有收到回复，它就一直等着。</p><pre><code class="Erlang">start() -&gt;    Pong_PID = spawn(test, pong, []),    spawn(test, ping, [10, Pong_PID, erlang:timestamp()]).</code></pre><p>最后是start函数，程序的入口函数，spawn了两个process，这两个process分别单独地运行。当传入ping的第一个参数为10，ping和pong的交互将持续10次。</p><h3 id="交互速率"><a href="#交互速率" class="headerlink" title="交互速率"></a>交互速率</h3><p>以前听到过一个所谓的“大牛”讲，我们现在想要提高计算机的速率，瓶颈是什么呢，我们应该往哪个方向努力呢，应该是CPU的利用率，Actor是很快的，为什么快呢，因为一个Actor就是一个整体，一个Actor只在一个内核中运行，连CPU内核之间的交互都省了……这种说法的正确性可能有待验证，不过Actor是否真的快呢，我有点好奇，也因此萌生了测试一下Actor速度的想法。</p><p>必须要说明的是，我也相当清楚，这种测试方法很不靠谱。</p><p>在Erlang程序里启动两个process，两个process之间相互通信，测试不同数量级的通信次数，记录下程序执行所花费的时间。与Erlang作为对比，在Java里启动两个线程，用线程的睡眠和唤醒实现线程间的通信。同样的，在Go语言里用两个协程通信。至于Akka……其实也是Actor的代表。下表是测试之后的结果，次数从1到1亿，时间单位为毫秒。</p><table class="table"><thead><tr><th style="text-align:right">次数</th><th style="text-align:right">Erlang</th><th style="text-align:right">Java</th><th style="text-align:right">Go</th><th style="text-align:right">Akka</th></tr></thead><tbody><tr><td style="text-align:right">1</td><td style="text-align:right">0</td><td style="text-align:right">0</td><td style="text-align:right">0</td><td style="text-align:right">3</td></tr><tr><td style="text-align:right">10</td><td style="text-align:right">0</td><td style="text-align:right">1</td><td style="text-align:right">0</td><td style="text-align:right">7</td></tr><tr><td style="text-align:right">100</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">1</td><td style="text-align:right">17</td></tr><tr><td style="text-align:right">1,000</td><td style="text-align:right">26</td><td style="text-align:right">30</td><td style="text-align:right">4</td><td style="text-align:right">83</td></tr><tr style="background:#ffff0008;"><td style="text-align:right">10,000</td><td style="text-align:right;"><span style="color:#0000ff99;">610</span></td><td style="text-align:right">168</td><td style="text-align:right">42</td><td style="text-align:right"><span style="color:#0000ff99;">225</span></td></tr><tr style="background:#ffff0008;"><td style="text-align:right">100,000</td><td style="text-align:right">2783</td><td style="text-align:right"><span style="color:#0000ff99;">1295</span></td><td style="text-align:right">404</td><td style="text-align:right"><span style="color:#0000ff99;">674</span></td></tr><tr style="background:#ffff0008;"><td style="text-align:right">1,000,000</td><td style="text-align:right">27,085</td><td style="text-align:right">11,300</td><td style="text-align:right"><span style="color:#0000ff99;">4489</span></td><td style="text-align:right;"><span style="color:#0000ff99;">3515</span></td></tr><tr><td style="text-align:right">10,000,000</td><td style="text-align:right">273,912</td><td style="text-align:right">107,673</td><td style="text-align:right">40,335</td><td style="text-align:right">29,368</td></tr><tr><td style="text-align:right">100,000,000</td><td style="text-align:right">2,851,680</td><td style="text-align:right">1,092,879</td><td style="text-align:right">482,196</td><td style="text-align:right">300,228</td></tr></tbody></table><p>本来尝试用Echarts之类渲染一下这些数据，方便对比，后来发现这些数据绘制出来的折线图并不友好。</p><p>总的来看，Erlang的速度是最慢的，这可能和Erlang历史悠久有关，也许是因为没有得到足够的优化，相信Elixir的速度会好一些。相较之下，Java的速度胜过Erlang，Go语言的速度胜过Java，这似乎是意料之中的事情。Java的耗时是Erlang的1&#x2F;3，Go语言的耗时是Java的1&#x2F;2。</p><p>最让人惊讶的在于，Akka的Actor速度竟然比Go语言的协程还要快。在交互1000次之前，Akka的速度比Erlang还要慢，在10K数量级的时候，它的速度超过了Erlang，在100K数量级的时候，速度超过了Java，直到1M数量级的时候，Akka超过了Go语言，并且一直保持领先。这是一个令人难以置信的结果，同样是运行在JVM上，Akka的耗时是Java的1&#x2F;3，可能Java线程间的交互确实带来了很大的开销。</p><p>没有用Elixir做测试是一个遗憾。关于Akka为什快，和Actor模型有没有关系，有多大的关系，还需要进一步探索。</p><p>(The End)</p><h3 id="Akka"><a href="#Akka" class="headerlink" title="Akka"></a>Akka</h3><p>用来做测试的Akka程序是Akka官方的Hello Wrold程序，能看到明显的Actor模型的影子，尤其是<code>!</code>运算符和<code>receive</code>方法。</p><pre><code class="Scala">import akka.actor.typed.ActorRefimport akka.actor.typed.ActorSystemimport akka.actor.typed.Behaviorimport akka.actor.typed.scaladsl.Behaviorsimport GreeterMain.SayHello</code></pre><p>这是导入部分，如果使用VS Code之类的编辑器，这段代码还是很重要的。和Erlang的程序类似，有一个发消息的Greeter和一个接收并回复消息的GreeterBot，另外还有一个主方法。</p><pre><code class="Scala">object Greeter &#123;  final case class Greet(whom: String, replyTo: ActorRef[Greeted])  final case class Greeted(whom: String, from: ActorRef[Greet])  def apply(): Behavior[Greet] =     Behaviors.receive &#123; (context, message) =&gt;      message.replyTo ! Greeted(message.whom, context.self)      Behaviors.same    &#125;&#125;</code></pre><p>这是发消息的Greeter，当Greeter作为函数被调用，会自动执行apply中的代码。apply方法是一个receive，和Erlang的receive一样会阻塞程序直到Actor接收到消息。replyTo是GreeterBot的”pid”，Greeter接收到消息后会回复消息给GreeterBot。</p><pre><code class="Scala">object GreeterBot &#123;  var startTime = System.currentTimeMillis()  def apply(max: Int) = &#123;    bot(0, max)  &#125;  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =    Behaviors.receive &#123; (context, message) =&gt;      val n = greetingCounter + 1      context.log.info(&quot;&#123;&#125;&quot;, n)      if (n &gt;= max) &#123;        context.log.info(&quot;The End | &#123;&#125;&quot;, System.currentTimeMillis() - startTime)        Behaviors.stopped      &#125; else &#123;        message.from ! Greeter.Greet(message.whom, context.self)        bot(n, max)      &#125;    &#125;&#125;</code></pre><p>这是GreeterBot，和Erlang简洁的代码比起来，Scala冗长的类型声明可能显得有些……烦杂。GreeterBot接收到来自Greeter的消息后，判断n是否为max，如果已经执行够次数了，就停止，否则调用自己进行递归。</p><pre><code class="Scala">object GreeterMain &#123;  final case class SayHello(name: String)  def apply(): Behavior[SayHello] =    Behaviors.setup &#123; context =&gt;      val greeter = context.spawn(Greeter(), &quot;greeter&quot;)      Behaviors.receiveMessage &#123; message =&gt;        val replyTo = context.spawn(GreeterBot(max = 10), message.name)        greeter ! Greeter.Greet(message.name, replyTo)        Behaviors.same      &#125;    &#125;&#125;object AkkaQuickstart extends App &#123;  val greeterMain = ActorSystem(GreeterMain(), &quot;AkkaQuickStart&quot;)  greeterMain ! SayHello(&quot;Charles&quot;)&#125;</code></pre><p>最后是主方法，看着可能也有点……长。继承于App的类是能够运行的主类，向Actor系统中注册了GreetMain，同时GreetMain的apply方法被执行了一次。GreetMain里spawn了两个process，和Erlang的程序行为是类似的。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go语言的程序真的要简洁很多，这是程序头部：</p><pre><code class="Go">package mainimport(  &quot;fmt&quot;  &quot;time&quot;)var maxCount = 100000000var startTime = time.Now().UnixNano() / 1e6</code></pre><p>定义了两个变量，一个是程序执行次数，一个是程序开始时间。</p><pre><code class="Go">func main() &#123;  ch := make(chan bool)  exit := make(chan bool)  go func() &#123;    for i := 0; i &lt; maxCount; i++ &#123;      fmt.Println(i)      &lt;- ch      ch &lt;- true    &#125;  &#125;()  go func() &#123;    defer func() &#123;      timeUsed := time.Now().UnixNano() / 1e6 - startTime      fmt.Println(&quot;The End | &quot;, timeUsed)      close(ch)      close(exit)    &#125;()    for i := 0; i &lt; maxCount; i++ &#123;      ch &lt;- true      &lt;- ch    &#125;  &#125;()  &lt;- exit&#125;</code></pre><p>两个协程，从channel中取数据和向channel中写数据交替。Go语言的程序看着清爽太多了，Scala扎眼睛。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java的冗长程度不比Scala轻。</p><pre><code class="Java">public class Test&#123;    public static void main(String[] args) &#123;        Object lock = new Object();        Thread sender = new Sender(lock);        Thread receiver = new Receiver(lock);        sender.start();        receiver.start();    &#125;&#125;</code></pre><p>主方法里启动了两个线程，锁是共享资源。</p><pre><code class="Java">class Message &#123;    static long MAX_COUNT = 100000000;    static String status = new String(&quot;init&quot;);    static long count = 0;    static long startTime = 0;    public static void send() &#123;        System.out.println(count);        status = &quot;sent&quot;;        count++;        if (count == 1) &#123;            startTime = System.currentTimeMillis();        &#125;        if (count &gt;= MAX_COUNT) &#123;            status = &quot;stop&quot;;            long time = System.currentTimeMillis() - startTime;            System.out.println(&quot;The End | &quot; + time);        &#125;    &#125;    public static void receive() &#123;        status = &quot;received&quot;;    &#125;    public static String getStatus() &#123;        return status;    &#125;&#125;</code></pre><p>Message是临界资源，储存消息的内容。消息内容变更时做了一点其他的事情，把需要的日志打印到屏幕上。</p><pre><code class="Java">class Sender extends Thread &#123;    Object lock = null;    public Sender(Object lock) &#123;        this.lock = lock;    &#125;    @Override    public void run() &#123;        while (!Message.getStatus().equals(&quot;stop&quot;)) &#123;            synchronized (lock) &#123;                if (Message.getStatus().equals(&quot;init&quot;)                   || Message.getStatus().equals(&quot;received&quot;)) &#123;                    Message.send();                    lock.notify();                    try &#123;                        lock.wait();                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;class Receiver extends Thread &#123;    Object lock = null;    public Receiver(Object lock) &#123;        this.lock = lock;    &#125;    @Override    public void run() &#123;        while (!Message.getStatus().equals(&quot;stop&quot;)) &#123;            synchronized (lock) &#123;                if (Message.getStatus().equals(&quot;sent&quot;)) &#123;                    Message.receive();                    lock.notify();                    try &#123;                        lock.wait();                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>Sender和Receiver的程序类似，Sender先发送消息，然后wait，等着接收Receiver的消息，Receiver用while不停地判断有没有收到消息，如果有则回复消息，并且唤醒Sender，通知它该处理消息了，叫醒Sender后自己wait，等着Sender的反馈。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Actor</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>一种侧边导航栏的交互方式</title>
    <link href="https://smallyu.net/2020/03/21/%E4%B8%80%E7%A7%8D%E4%BE%A7%E8%BE%B9%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/"/>
    <id>https://smallyu.net/2020/03/21/%E4%B8%80%E7%A7%8D%E4%BE%A7%E8%BE%B9%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-21T09:59:37.000Z</published>
    <updated>2024-08-03T19:07:09.975Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到几个管理系统的演示项目，结合开发过程中不顺手的地方，发现大多数网站的侧边导航栏都是点击展开，点击关闭。</p><img src="classical.gif" width="20%"><p>感觉这样的交互方式稍微有点繁琐：</p><ul><li>在不知道子菜单位置的情况下，需要一个一个点开才能找到需要的页面</li><li>在知道子菜单位置的情况下，也需要点击一下父级菜单，才能看到想要的子菜单</li><li>不一个一个点开，就无法知道子菜单有些什么</li><li>子菜单展开之后，需要一次一次点击父菜单才能收起</li></ul><p>后来就想，能不能把点击事件换成悬浮事件呢？只要鼠标放上去，菜单就会自动展开，不用点一下的操作了。但是单纯的悬浮展开，需要考虑菜单长度不一致的问题，如果下一个菜单的长度比当前菜单短，鼠标离开当前菜单，当前菜单收回，鼠标所在的位置会直接越过下一长度较短的菜单。</p><img src="problem.gif" width="20%"><p>像图片中这样，栏目二的长度是4，栏目三的长度是2，当鼠标从栏目二向下移动，离开栏目二的瞬间栏目二收回内容，鼠标在没有移动的情况下跳过了栏目三，悬浮在栏目四上，这其实是不合理的，会违背用户的预期。栏目二之后是栏目三，这是最正常的逻辑。</p><p>为了应对这一问题，也许可以将交互设计成这样，当鼠标离开栏目二后，栏目二不收回，直到鼠标离开整个导航栏，子菜单才自动折叠。如果子菜单展开时用户点击了某一父菜单，那这个父菜单即使鼠标离开导航栏也不收回。</p><img src="solution.gif" width="20%"><p>下面是一个demo页面，通过iframe嵌入到这里，可以对比两种侧边导航栏的交互方式（移动端没有鼠标悬浮事件）。我偏爱灵活一点的交互，第二种方式单击父菜单也可以展开收起列表，相当于在方式一的基础上加入了鼠标悬浮自动展开的能力。</p><div align="center"><iframe src="/html/sider_bar_demo.html" width="400px" height="580px" frameborder="0" scrolling="yes" style="border: 5px double #e4e4e4;"> </iframe></div><p>相较于鼠标悬浮自动展开不收回的方式，更进阶一点的做法是，当鼠标从上往下移动时，子菜单自动展开但不收回，当鼠标从下往上移动时，子菜单自动展开并且自动收回。因为子菜单要不要自动收回取决于对用户接下来的操作有没有影响。不过这样的效果实现起来有些复杂了，对于网页上的一个导航栏来说，需要不断监听鼠标的坐标，开发和和维护的成本有点高。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近看到几个管理系统的演示项目，结合开发过程中不顺手的地方，发现大多数网站的侧边导航栏都是点击展开，点击关闭。&lt;/p&gt;
&lt;img src=&quot;classical.gif&quot;</summary>
        
      
    
    
    
    
    <category term="设计" scheme="https://smallyu.net/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>新的征程</title>
    <link href="https://smallyu.net/2020/03/08/%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/"/>
    <id>https://smallyu.net/2020/03/08/%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/</id>
    <published>2020-03-07T17:00:29.000Z</published>
    <updated>2024-08-03T19:07:10.109Z</updated>
    
    <content type="html"><![CDATA[<p>我犹豫了很久，要不要把这些东西写下来，应该什么时候写，现在写合不合适……如果我无法在自己的独立博客上写自己想写的东西，我就被生活上的事情束缚了，博客也变的没有意义。我总是担心，如果我的同事、领导偶然看见我在博客上写想要离开公司，或者原来早就产生离开公司的想法，对公司有什么不满之类；或者担心招聘者会偶然看到我对公司的不忠诚，看到我说公司的坏话，会不会对新的公司也产生一大堆意见，毕竟我总是把网址写在简历中。</p><p>也可能世上本无事，我杞人忧天了。</p><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>我期望的工作，可能需要一点实力，也需要一点运气。当HR问我想要跳槽的原因，我一开始的说辞是想要寻找更好的机会，不是现在的公司不好，而是想要更好。具体说就是想要找更好的发展前景，技术上或者业务上能够有更多的成长……直到HR问我，你现在的平台机会不多，前景不好，工作不饱满吗？</p><p>我重新思考了这个问题，关于为什么想要跳槽。我没有撒谎，现在的公司确实还好，没什么能说得上不好的地方，当然也说不上多好。我想了想，真正的原因应该是我作为开发人员，作为技术支持这样的一个角色，对于目前公司的情况来说，难堪大用。公司更需要的是能拉客户的销售，能写专利的技术研究员（投标的时候要指标），而不是能把脏活干好的熟练的工人。</p><p>我有算不上丰富的开发经验，从还有静态网站和动态网站之分的那个年代，接触到互联网之后对广阔的网络世界充满兴趣。从三极管到模拟电路、数字电路、集成芯片、单片机、汇编语言、树莓派、C语言、Java、JavaScript、MVC、MVVM、FP……除了网站开发，稍微知道一点安卓的玩法、用H5开发原生应用的混合开发、基于Node.js的桌面应用开发……大学读电子类专业并没有阻碍我对计算机的了解，反而知道了一些可能计算机专业不会学的电子电路、通信编码之类。其实我真正懂得东西很少，只是稍微知道一点概念，但内心深处总是充满力量，有一种莫名的热情，让我感觉自以为能够解决更多问题，事实上我也确实希望能有更多机会解决更多的问题，希望在技术上有长足的发展。</p><p>有时候会感觉世界的不公，我无法想象不会处理SVN冲突、搞不清二维数组的前端，没用过Docker、不懂RBAC权限模型的后端，不知道<code>String.valueOf()</code>和<code>(String)</code>区别、可以直接往<code>JSONObject</code>里传<code>Map</code>的Java开发，是合格的程序员。我可以解决同事无法解决的技术问题，有超过同事的技术广度，甚至有更多努力工作的意愿，但仅仅因为我的工作年限较短，别人的工作时间较长，我只能拿与我工作经验相当的工资。实际上我接触Web开发的时间可能比某些小作坊的面试官还要长（真的遇到过）。也许我的同事都是幸运者，在互联网还未退潮的时候上了船。</p><p>我并不是想说我是自大狂，我很清楚自己没有足够的实力，不懂JVM调优、背不下设计模式、没看过Spring或Redis的源码、不懂操作系统原理（看过两本书，抄过一本，没记住），不懂算法（见medium死），没有好的学历（双非）。我也不知道我会点什么。但是当面试官问我ECharts的用法、“事务的隔离级别”、“死锁产生的条件”、“Map的原理”，虽然有点卡壳……我同样有些犹豫，在百度用中文搜的第一条就能找到答案的问题，需不需要记下来呢，世界上的问题那么多，知识那么多。</p><h3 id="面向面试学习"><a href="#面向面试学习" class="headerlink" title="面向面试学习"></a>面向面试学习</h3><p>对于需不需要记下来的问题，我希望自然而然的解决。就像做开发，踩的坑多了，就成了资深程序员，看的报错日志多了，就能瞬间明白异常原因。我可以多面几个试，在面试过程中了解公司会问哪些问题，期望怎么样的回答，不断积累经验，顺便锻炼一下语言表达能力，在面试结束后弥补不足，补充知识。正好最近的疫情提供了绝佳的机会，几乎所有公司都无法现场面试，可以通过电话、视频面试，我在公司连假都不用请，除了稍微在心态上有点影响工作外，但保证不会落下进度。</p><p>到这里我又担心如果新的公司看到这些话，会不会认为我面试是刷经验去了，毕竟我真的会在简历上写下网址，大多数情况不会有人看，但万一呢……</p><p>目前对我来说，发展前景比工资重要太多了。所以最最最理想的情况，是进一家能叫得上名字的公司。折中一点的情况，是公司招牌和目前的公司相当，但是工资比现在高一点，底线是两千，试用期加上跳槽离职入职工作交接之类的成本，两千应该不夸张。再差一点的情况，再差一点，就是我被公司裁了，不得不找其他工作，又没有合适的机会，随便找了一家保证生存。</p><h3 id="最后的稻草"><a href="#最后的稻草" class="headerlink" title="最后的稻草"></a>最后的稻草</h3><p>我想说说目前的公司。当时在学校还是秋招阶段的时候，HR就跟我说，应届生两年后考虑涨工资。其实我从一开始就明白，我不可能等两年。开始实习后，带我的导师告诉我，他们一年涨一次。</p><p>所以在我被迫换部门后（当时公司效益不好，裁了很多人，未入职的应届生走了一半），我想着一定要等过个年，心里还在期望和等待的有两件事，一个是年终奖，一个是涨工资（普调）。倒不是在意能拿到手多少钱，而是想要了解一下公司的运作方式，绩效怎么回事，年终奖怎么发，是否和绩效挂钩，涨工资是怎么谈或者怎么样，还幻想着领导会不会谈个话，聊聊工作情况，表现怎样，未来计划，然后我应该说些什么，怎么表现，让领导看到我的能力。没有经历过那些，就想经历一下。</p><p>事实当然是令人失望的。我了解到部门内有的人三四年都没有涨过工资，暂且接受，但是到过年放假前的最后一天，我感到异常生气，因为没有年终奖。往年都有，就今年没有，这一点也能理解，公司效益不好。问题是公司当天把本季度的绩效工资发了下来（我们下季度发本季度绩效），这不是公司良心发现要发当前季度绩效了，如果想发，就应该和当月工资一起发。我当时瞬间想到的是“朝三暮四”这个词，公司把我们当猴养，我们在人格和尊严上都应该感受到侮辱，我无法继续忍受这种任人宰割的状况，没有公告，没有制度，没有任何形式的通知，关于工资、普调、年终奖，我希望知道规则，我希望知道该如何努力，该如何表现，问题是没有，全部没有，全看领导心情。我无法凭自己的努力改善自己的收入，这就是我在目前公司看不到希望的地方。我甚至都不明白我的直属领导到底是谁，到现在HR系统里还指向一个已经离职的名字，他什么时候来和我谈一谈工资的事情呢？</p><h3 id="区块链不是风口"><a href="#区块链不是风口" class="headerlink" title="区块链不是风口"></a>区块链不是风口</h3><p>最近几天初次知道了“共有知识”和“公共知识”的区别，重新明白了一下《皇帝的新装》里面的道理。提区块链是因为我目前属于区块链团队，公司也把一部分资源押在了区块链上。</p><pre><code class="html">我知道区块链没什么用。你知道区块链没什么用。他知道区块链没什么用。</code></pre><p>这是共有知识。</p><pre><code class="html">我知道 你和他都知道 区块链没什么用。你知道 我和他都知道 区块链没什么用。他知道 我和你都知道 区块链没什么用。</code></pre><p>这是公共知识。</p><p>大家都知道，但不清楚别人知不知道的，叫共有知识。当有人跨越了中间的沟壑，告诉所有人他们的想法是一致的，然后大家都知道了大家的想法是一致的，共有知识就变成了公共知识。目前的区块链就处于共有知识的阶段，因为很多人都说区块链怎样怎样，你无法不认可它的价值，如果你说区块链没有价值，那就是你不懂，你没有智慧，你见识浅薄，你……连位置最高的管理者都发话了，你能说你看不到区块链的价值吗？</p><p>和《皇帝的新装》的故事对比一下，是不是有一些相似之处？</p><h3 id="新的征程"><a href="#新的征程" class="headerlink" title="新的征程"></a>新的征程</h3><p>所以我真的犹豫了很久，要不要写下这些东西，关于当前的公司，关于新的目标，从年前放假的最后一天，直到现在。</p><p>我需要新的机会。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;我犹豫了很久，要不要把这些东西写下来，应该什么时候写，现在写合不合适……如果我无法在自己的独立博客上写自己想写的东西，我就被生活上的事情束缚了，博客也变的没有意义。我总是担心，如果我的同事、领导偶然看见我在博客上写想要离开公司，或者原来早就产生离开公司的想法，对公司有什么不</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java项目开发中的3个小问题</title>
    <link href="https://smallyu.net/2020/02/26/Java%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%843%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://smallyu.net/2020/02/26/Java%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%843%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-26T09:37:42.000Z</published>
    <updated>2024-08-03T19:07:09.971Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. mysql需要id自增主键吗</strong></p><p>有些时候我们会使用具有具体含义的字段作为主键，比如用用户名username而不是无意义的自增id。这样做的好处之一是可以利用主键不可重复的特性，保证username的惟一。如果试图写入重复的数据，数据库会抛出”Duplicate entry * for key PRIMARY”的错误。</p><p>利用这个“好处”的问题是，我们能否依赖以及是否需要依赖主键的默认特性（字段不重复）来实现我们业务上的需求（字段不重复），而事实上“不重复”是惟一索引的特性，并不是主键的特性。主键字段会自动加上惟一索引。</p><p>同时，利用这个“好处”的不便之处之一是，数据表缺少一个表示“数据行序列”的字段。oracle还有rownum这样的东西，mysql则没有，得用脚本实现。如果需要分段遍历表的话，没有行的概念就很难操作。</p><p>《阿里巴巴Java开发手册》明确要求表必备id字段，他们不一定是对的，但我相信他们的理由一定足够充分。</p><img src="id.png" width="90%" height="50%" /><p><strong>2. Map还是Bean</strong></p><p>用mybatis查询数据时，返回值类型一种是List<Map>，一种是List<Bean>。这里的Bean指数据对象（DO）。</p><p>使用Bean的好处显而易见，输入对象名再按下一个点，idea会自动弹出bean的getter和setter，表包含的属性一目了然。无论取值还是赋值，都对使用者友好。</p><p>使用Bean有可能存在的问题之一是，如果表结构有改动，比如删除一个字段，Bean类中对应删除了一个属性，同时删除了相应的getter和setter，那么只要是程序中用到了这个bean这个字段的地方，都需要逐一修改，如果不改，程序将无法通过编译。</p><p>我们经常在开发过程中遇到这种情况，调试A类，改了某个公用的COM类，编译的时候BCDEF…都报错了，这很让人抓狂，我只想要也迫切的只需要确认A类的问题是不是由COM类引起，却由于这种依赖关系需要尝试其他方法。</p><p>如果面临系统改造、整合、重构之类的问题，Bean也会暴露出同样的问题。我在最近接触的项目中，为了尽可能多复用原系统，尽可能少做改动，只好用含义不太相同的Bean.username储存实际上内容为Bean.phoneNumber的值。原系统的各种工具类（加解密、本地缓存之类）全都依赖Bean，涉及到Bean的改动之后，要么大批量的全改，要么全不改。</p><p>如果使用的是Map，Bean带来的问题可能会得到稍微的缓解。尤其是在合理处理取值操作后，比如<code>String.valueOf(map.get(&quot;&quot;))</code>可以避免伟大的空指针异常，程序取值为空也可以正常启动，需要变动的地方随心所欲的get、set，不再受Bean类getter、setter方法的限制。</p><p>另外，其实Map和Bean都是对属性的一种封装。</p><p><strong>3. 注解还是xml</strong></p><p>Spring的IOC支持注解也支持xml，mybatis的sql同样支持注解也支持xml。</p><p>在以前的时代，Java项目往往会打包成war或者jar，放在容器tomcat或者resin中运行。容器在运行的时候会将包自动解压成class文件和资源文件，资源文件就包括xml。使用xml配置的好处之一是，线上环境可以直接修改xml重启项目就完成操作，不需要再把java文件编译成class文件，打包解压替换，走一遍项目上线的流程，拉分支、开发、测试、编译、部署、合并基线，一步步发邮件。</p><p>我想现在时代变了，有持续集成，有自动化运维，有properties，有yml，xml似乎显得不是那么重要。</p><p>对于mybatis的sql来说，内部有一个xml的解析器，xml相当于一种dsl，通过配置来实现动态sql语句之类的需求。如果使用注解的方式，把sql写在provider里，我们就失去了xml解析器的功能。不过失去能力的同时，我们也会获得自由。面对字符串形式的sql语句，我们完全可以自己封装一个parser。</p><p>一个有趣的现象是，国外的开发者似乎更喜欢注解的方式，国内的开发者倾向于使用xml，国外的书籍很多作者使用注解做案例，国内的博客文章则大多使用xml配置做教程。这一点有些类似于前端框架react和vue的状况，技术实力较强的企业、开发者更加青睐react，因为jsx更像是编程语言，有更多的发挥空间，vue则受到技术实力较弱的企业和开发者喜爱，因为上手简单，开发简单。如果你用过vue就应该有体会，用那玩意儿开发不叫编程，它只是软件工业化的产物。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>程序员的定位</title>
    <link href="https://smallyu.net/2020/01/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%AE%9A%E4%BD%8D/"/>
    <id>https://smallyu.net/2020/01/11/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%AE%9A%E4%BD%8D/</id>
    <published>2020-01-11T10:19:45.000Z</published>
    <updated>2024-09-12T07:28:46.933Z</updated>
    
    <content type="html"><![CDATA[<p>有一件可怕的事情是，程序员不再关注代码、软件、系统、架构，而是关注产品、运营、销售，展望内容不再是提高代码质量、迭代更好的软件、做更好的工程，而是提高文档输出能力、活跃团队气氛。</p><h3 id="startup与996"><a href="#startup与996" class="headerlink" title="startup与996"></a>startup与996</h3><p>公司开始倡导创业心态，创业嘛，大家就要一起努力，一起干大事。BOSS说，有天回公司晚了，看到某某和某某10点多还在……大家也要这样，我们也只能这样做，如果因为身体或者其他原因不能适合我们这种节奏了，可能就不太适合我们这个团队了。大家要一起努力，要10106，我们只能这样做，如果不这样做，如果不这样做……公司就会死。</p><p>当时听到这儿，哑然失笑。说句不太符合价值观的话，我明知道这样说不对，如果老板看到这样的想法，我明天就得和HR聊聊了，这是没有责任心的体现，这是没有职业道德的体现，这是……恕我直言，公司死掉，于我何干？</p><p>画饼啊，平时都听人吐槽，老板给画个大饼，入职后发现遥遥无期，然后上网发帖，不要相信老板的鬼话，不要相信什么福利奖金，拿到手的才是真的。我们这画风好像不太一样啊，如果不努力，公司会死掉？以前看到过一句话，所有人都告诉我们要努力，但是从来没有人告诉我们努力之后可以得到什么。公司死掉了，我们换家公司不也照样干活吗？</p><p>年会的问答环节上，大BOSS抓住了“享受红利”这个字眼，大意是红利不是公司给予的，要给公司带来相应的价值。猜想很多时候，公司的想法是，你要先给我干20分的活，我就分你10分的利。员工的想法是，你给我10分的钱，我就干好10分的活，你要再多给我5分，我就再多尽5分力。</p><p>996是类似的问题，我们为什么是10106？因为我们9点半上班，坐到工位上打开电脑、开个晨会大概就10点了，所以是1010，而不是99。关于996，一种说法是有些员工挣表现的心理，从小被奖励小红花的培育文化，造就了认为“只要努力就会有收获”的心态。不过很多老板也确实吃这一套。</p><p>昨天我听到了另一种说法。我们BOSS虽然说出了10106的话，但是并不会发正式的制度通知出来，因为这违反劳动法。我对此感到疑惑，这就不好办了呀，到底要不要10106？请教稍有经验的员工，得到的答案是，老板喜欢“聪明”的员工。也就是说，老板提到这个事了，具体怎么做得自己掂量。</p><h3 id="加班"><a href="#加班" class="headerlink" title="加班"></a>加班</h3><p>有时候项目紧、突发bug、上线、工作失误，偶尔加班很正常，有忙有闲。有的公司要求经常性加班，有干不完的活，也就是所谓996工作制。一般来说965是一个数，996是一个数，对应的薪资水平不同。产生矛盾的点在于，公司希望用965的薪资招996的人，员工希望领996的薪水干965的活。</p><p>存在一种情况是老板没有要求加班，但是有人加班。每个人分工不同，任务量不同，完成速度不同，要看具体情况。如果自己效率低于别人，加班无可厚非。比较坑的是别人因为效率不高整天加班，你完成任务没有加班，老板就在工作时间这件事上做文章。你如果和别人一样的工作时间，是不是就能产出更多了？别人没完成的也可以帮帮忙完成一下……相信明智的领导能够分辨出真正的工作能力，也能够按照工作量而不是工作时间判断产出。不过最可怕的是揣着明白装糊涂。</p><p>另一种情况是老板要求多呆一会儿。可能没有那么紧急的工作需要加班才能完成，但是别人加班了，为什么你到点就走？所有人都加班，就你特殊？……老板为什么会想要多呆一会儿呢，加班总归要多干点活吧，应该是植根于中国劳动人民群众心中占小便宜的心理。</p><p>其实996对工作产出的影响未必是正面的。如果到点大家都下班了，我是不好意思长留加班的（认真），别人都能完成工作，你需要加班完成，是不是你能力不行？所以工作内容会尽量在上班时间紧凑的完成。如果每天需要加班呢，反而会感觉上班稍微拖沓一点也没事，反正要加班，反正到点也走不了，上班时间摸摸鱼，没完成的好好加一把班，还能给老板留个好印象。</p><h3 id="技术人"><a href="#技术人" class="headerlink" title="技术人"></a>技术人</h3><p>公司开始倡导“销售导向”，因为销售是能够直接决定收益的一环，也是老板比较重视的部分。述职会上，我第一次从销售和运营的口中了解到公司的全貌，也是在述职会中，BOSS提到，“像了解机器学习常用的模型和算法是一些很具体的、很普通的事情，我们要……”，那正是我几天前的述职材料中提到的内容。</p><p>其实技术不重要，尤其是销售导向的公司，用到了什么技术真的不重要，重要的是把客户谈下来，把客户忽悠住，给公司挣钱。放在整个社会中，技术要足够领先、足够新，才能有立足的可能，像机器学习这样已经谈了十几年的技术，了解常见的用法确实很普通、很平庸。尤其是并不能带来什么收益。</p><p>从实行OKR开始，我们的绩效计划有两个特点，一是要有目标有结果，二是这个目标和结果不是工作内容方面的，而是自我提升方面的。自我提升主要指输出，就是写内刊、写专利、分享技术等，尤其是要能够给工作带来帮助的。讽刺的是，我们几乎没有技术氛围，真正写代码的只有几个骨干。从绩效管理能体现出的是，领导不太在意工作方面的内容，比如建立项目规范和开发规范，需求、开发、评审、测试之类的，领导更在意个人方面的东西。</p><p>可能很多时候的情况是，公司在意的是“你能给公司带来什么？”员工想的是“公司需要我做些什么？”</p><p>述职也是一样，不得不写一些工作之外，但又和工作相关的内容。深度学习本身是一个值得学习和研究的技术领域，即使是常见的模型和算法，从原理到工程至少也要1年的时间才能有一定了解。另外我目前的工作内容是应用层开发，也就是增删改查的业务之类，部门的技术主题是区块链，所以就把机器学习放在了展望一栏。</p><p>个人而言，机器学习是很大的一步。它本身有一定门槛，以前也多次尝试，看吴恩达的教程放弃了一次，看斯坦福的图像识别课放弃了一次，……有观点说机器学习是微积分在现代计算机技术背景下的发展，它的基础理论是数学，同时观点也提到，区块链是小骗，AI是大骗……不管骗不骗，总归还是要学的。</p><h3 id="程序员"><a href="#程序员" class="headerlink" title="程序员"></a>程序员</h3><p>和销售或者运营相比，程序员的特点之一可能是不那么依赖外部资源，人脉、市场、监管、业务，技术在形式上千变万化，本质上都是操作计算机进行计算。应用层开发的程序员，本职工作应该是按照进度要求完成开发任务，职业素养是保证代码质量，需要提升的是系统架构能力。熟练的Coder可以高效使用工具链，优秀的Coder可以优化算法、提高程序效率和系统性能。</p><p>对不起，I am a Coder，我认为不丢人。（@<a href="https://www.ruanyifeng.com/blog/2011/10/dont_call_yourself_a_programmer.html">不要自称为程序员</a>）</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;有一件可怕的事情是，程序员不再关注代码、软件、系统、架构，而是关注产品、运营、销售，展望内容不再是提高代码质量、迭代更好的软件、做更好的工程，而是提高文档输出能力、活跃团队气氛。&lt;/p&gt;
&lt;h3 id=&quot;startup与996&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="程序员" scheme="https://smallyu.net/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>Rust的ownership是什么？</title>
    <link href="https://smallyu.net/2019/12/21/Rust%E7%9A%84ownership%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://smallyu.net/2019/12/21/Rust%E7%9A%84ownership%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2019-12-21T15:06:28.000Z</published>
    <updated>2024-08-03T19:07:09.973Z</updated>
    
    <content type="html"><![CDATA[<p>Rust是内存安全的。Facobook的Libra使用Rust开发，并推出了新的编程语言Move。Move最大的特性是将数字资产作为资源（Resource）进行管理，资源的含义是只能够移动，无法复制，就像纸币一样，以此来保证数字资产的安全。其实Move的这种思想并不是独创的，Rust早已使用这样的方式来管理内存，因此Rust是内存安全的。Rust中的内存由ownership系统进行管理。</p><h3 id="Java的引用计数"><a href="#Java的引用计数" class="headerlink" title="Java的引用计数"></a>Java的引用计数</h3><p>垃圾回收有很多种方式，ownership是其中之一。Java使用的是引用计数，引用计数法有一个广为人知的缺陷，无法回收循环引用涉及到的内存空间。引用计数的基本规则是，每次对内存的引用都会触发计数加一，比如实例化对象，将对象赋值给另一个变量，等。当变量引用被取消，对应的计数就减一，直到引用计数为0，才释放空间。</p><pre><code class="Java">class Test &#123;    Test ref = null;&#125;Test a = new Test(); // a的计数加一Test b = new Test(); // b的计数加一// 此时a的计数是1，b的计数是1a.ref = b;           // a的计数加一，因为ref是a的类变量b.ref = a;           // b的计数加一，因为ref是b的类变量// 此时a的计数是2，b的计数是2a = null;            // a的计数减一，因为a的引用被释放b = null;            // b的计数减一，因为b的引用被释放// 此时a的计数是1，b的计数是1</code></pre><p>因此，在a和b的引用被释放时，它们的计数仍然为1。想要a.ref的计数减一，就要将a.ref指向nulll，需要手动操作指定为null吗？当然不需要，Java从来没有手动释放内存空间的说法。一般情况下，a.ref执行的对象也就是b的空间被释放（计数为0）时，a.ref的计数也会自动减一，变成0，但此时因为发生了循环引用，b需要a的计数变为0，b的计数才能变成0，可a要想变成0，需要b先变成0。相当于死锁。</p><p>这和Rust的ownership有关系吗？当然，没有关系……</p><h3 id="ownership"><a href="#ownership" class="headerlink" title="ownership"></a>ownership</h3><p>ownership有三条基本规则：</p><ul><li>每个值都拥有一个变量<code>owner</code></li><li>同一时间只能有一个<code>owner</code>存在</li><li>当<code>owner</code>离开作用域，值的内存空间会被释放</li></ul><p>作用域多数情况由<code>&#123;&#125;</code>界定，和常规的作用域是一样的概念。</p><pre><code class="Rust">&#123;                       // s还没有声明    let s = &quot;hello&quot;;    // s是可用的&#125;                       // s已经离开作用域</code></pre><p>Rust的变量类型分简单类型和复杂类型，相当于普通变量和引用变量，因为ownership的存在，简单类型发生赋值操作是，值是被复制了一份的，但复杂类型是将引用直接重置到新的引用变量上，原先的变量将不可用。</p><pre><code class="Rust">let x = 5;let y = x;                        // y是5，x还是5let s1 = String::from(&quot;smallyu&quot;);let s2 = s1;                      // s2是&quot;smallyu&quot;，s1已经不可用</code></pre><p>赋值过程中，s2的指针先指向string，然后s1的指针被置空，这也就是移动（Move）的理念。如果想要s1仍然可用，需要使用<code>clone</code>复制一份数据到s2，而不是改变指针的指向。</p><pre><code class="Rust">let s1 = String::from(&quot;smallyu&quot;);let s2 = s1.clone();              // s1仍然可用</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>目前提到的有两个概念，一是ownership在离开作用域后会释放内存空间，二是复杂类型的变量以移动的方式在程序中传递。结合这两个特点，会发生这样的情况：</p><pre><code class="Rust">fn main() &#123;    let s = String::from(&quot;smallyu&quot;);    takes(s);             // s被传递到takes函数                          // takes执行结束后，s已经被释放    println!(&quot;&#123;&#125;&quot;, s);    // s不可用，程序报错&#125;fn takes(s: String) &#123;     // s进入作用域    println!(&quot;&#123;&#125;&quot;, s);    // s正常输出&#125;                         // s离开作用域，内存空间被释放</code></pre><p>如果把s赋值为简单类型，比如5，就不会发生这种情况。对于复杂类型的变量，一旦离开作用域空间就会释放，这一点是强制的，因此目前可以使用函数的返回值来处理这种情况：</p><pre><code class="Rust">fn main() &#123;    let s = String::from(&quot;smallyu&quot;);    let s2 = takes(s);     println!(&quot;&#123;&#125;&quot;, s2);&#125;fn takes(s: String) -&gt; String &#123;     println!(&quot;&#123;&#125;&quot;, s);     s&#125; </code></pre><p>takes把变量原封不动的返回了，但是需要一个变量接住takes返回的值，这里重新声明一个变量s2的原因是，s是不可变变量。</p><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>引用变量不会触发ownership的drop方法，也就是引用变量在离开作用域后，内存空间不会被回收：</p><pre><code class="Rust">fn main() &#123;    let s = String::from(&quot;smallyu&quot;);    takes(&amp;s);    println!(&quot;&#123;&#125;&quot;, s);&#125;fn takes(s: &amp;String) &#123;    println!(&quot;&#123;&#125;&quot;, s);&#125;</code></pre><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>引用变量仅属于可读的状态，在takes中，s可以被访问，但无法修改，比如重新赋值。可变变量可以解决这样的问题：</p><pre><code class="Rust">fn main() &#123;    let mut s = String::from(&quot;smallyu&quot;);    takes(&amp;mut s);    println!(&quot;&#123;&#125;&quot;, s);&#125;fn takes(s: &amp;mut String) &#123;    s.push_str(&quot;, aha!&quot;);&#125;</code></pre><p>可变变量也存在限制，同一个可变变量同一时间只能被一个其他变量引用：</p><pre><code class="Rust">let mut s = String::from(&quot;smallyu&quot;);let r1 = &amp;mut s;let r2 = &amp;mut s;println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</code></pre><p>程序会报错，这是容易理解的，为了保证内存安全，一个变量只能存在一个可变的入口。如果r1和r2同时有权力更改s的值，将引起混乱。也因此，如果是<code>r1 = &amp;s</code>而不是<code>r1 = &amp;mut s</code>，程序会没有问题，只能存在一个引用针对的是可变变量的引用变量。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>函数的返回值类型不可以是引用类型，这同样和ownership的规则有关，返回普通变量相当于把函数里面的东西扔了出来，如果返回引用变量，引用变量指向的是函数里面的东西，但函数一旦执行结束就会销毁内部的一切，所以引用变量已经无法引用到函数。</p><pre><code class="Rust">fn dangle() -&gt; &amp;String &#123;    let s = String::from(&quot;smallyu&quot;);    &amp;s;&#125; // 到这里s的内容空间已经释放，返回值无法引用到这里</code></pre><h3 id="？"><a href="#？" class="headerlink" title="？"></a>？</h3><p>没有更多内容了。</p><p>最近看了一部能够让人振奋的美剧《硅谷》，编剧给主角挖了很多坑，感觉他们倒霉都是自己作的，编剧也给观众留了很多坑，剧情跌宕起伏到想给编剧寄刀片。抛开那些情节，剧中渲染的geek真的很帅，很帅！当然，神仙打架，凡人也参与不了。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Rust是内存安全的。Facobook的Libra使用Rust开发，并推出了新的编程语言Move。Move最大的特性是将数字资产作为资源（Resource）进行管理，资源的含义是只能够移动，无法复制，就像纸币一样，以此来保证数字资产的安全。其实Move的这种思想并不是独创的</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>我亲手写出了难以维护的代码</title>
    <link href="https://smallyu.net/2019/12/15/%E6%88%91%E4%BA%B2%E6%89%8B%E5%86%99%E5%87%BA%E4%BA%86%E9%9A%BE%E4%BB%A5%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>https://smallyu.net/2019/12/15/%E6%88%91%E4%BA%B2%E6%89%8B%E5%86%99%E5%87%BA%E4%BA%86%E9%9A%BE%E4%BB%A5%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81/</id>
    <published>2019-12-15T12:03:32.000Z</published>
    <updated>2024-08-03T19:07:10.107Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间尝试了一些线下活动，加上有几天身体异常痛苦，现在稍微静下来感觉恍如隔世。最近有个项目在做最后的验收，于是搬出了一两个月前的代码，需要手动操作更新一些数据。看到这些不久之前写的代码，同样恍如隔世的感觉，如果这是别人写的，我一定会第一时间认为很垃圾，既然是我亲手写的，客观的说，它确实很垃圾。</p><p>那是一个很好记的日子，从那天开始，2019年才真正开始。我曾经接触的是老系统的代码，不得不在resin里启动项目，编译一次至少要两分钟，难以调试，曾经在测试服务器上开发和调试程序，而不是发布代码，曾经写过一些小任务，比如批量执行sql还踩了坑。我曾经看不起垃圾代码，看不起9102年还在用eclipse的程序员。</p><p>时至今日，我也变成了写出垃圾代码的程序员。</p><h3 id="小需求"><a href="#小需求" class="headerlink" title="小需求"></a>小需求</h3><p>第一次写出垃圾代码，印象比较深的是打印两次日志：</p><pre><code class="java">catch (e) &#123;    System.out.println(&quot;捕获到异常&quot;);    logger.error(&quot;捕获到异常&quot;);&#125;</code></pre><p>logger出现了多少次，println就出现了多少次，这显然是丑陋的做法。因为当时的nohup.out和log文件夹不在同一目录，log文件夹专门配置过放在统一的目录，然后希望nohup.out也有日志输出……具体原因有点模糊了，这应该是第一次恶心到我自己的代码。后来好像再版的时候去掉了，恍恍惚惚。</p><p>同样是这个需求中，当时的老大的代码里，有一处值得借鉴和赞赏的写法，我当时怀着慷慨激昂的心情认为这是冗余的做法，有点想要挑战权威的意味，事情证明还是年轻了。</p><pre><code class="java">代码想不起来了 T_T</code></pre><p>同样还是这个需求，需要实现可以自定义配置sql语句，类似jdbcTemplate中的<code>?</code>，或者mybatis的<code>#&#123;&#125;</code>，我当时用了非常生硬的做法：</p><pre><code class="java">// 需求sql = update set a=&#123;a&#125;, b=&#123;b&#125;, ...// 解决for (i = 0; i &lt; param.num; i++) &#123;    switch(match.group()) &#123;        case &#123;a&#125;: break;        case &#123;b&#125;: break;        ...    &#125;&#125;</code></pre><p>当被问到参数位置是否可以调换，还是放心的，那参数能多能少吗？……</p><h3 id="改需求"><a href="#改需求" class="headerlink" title="改需求"></a>改需求</h3><p>曾经见过一个程序，一个文件里面有一个类，这是理所当然的，这个类里面只有一个方法，方法有一千多行，是个女程序员写的。</p><p>我的任务是原先输出的报表上加几个字段，原先输出了<code>a,b</code>，现在需要<code>a,b,c,d</code>。<code>c,d</code>是我需要实现的部分，大致的程序逻辑和<code>a,b</code>一样，但是来源不同，执行不同的sql查出来的。按理说改个sql不就完了吗，问题是一千多行的方法里面嵌套了三四层循环，包含了从不同银行查数据的业务操作，循环内外的变量名就是<code>list1、list2</code>，最终的结果还会涉及到对<code>a,b</code>的累加操作。</p><p>当时选择的做法是不动原来的程序，复制一份出来，分别执行完后整合一下数据。心高气傲啊，不愿意读垃圾代码。所以后来一个类里面有两个一千行代码的方法了。要命的是bug不断，复制出来的代码仍然需要从头到尾看明白，而且对两部分数据的整合也带来了不少麻烦和意想不到的漏洞……</p><h3 id="完善需求"><a href="#完善需求" class="headerlink" title="完善需求"></a>完善需求</h3><p>另一个需求是接手别人做到一半的项目。9102年了在spring boot里面用模板引擎写页面，我不得不用jquery和基于jquery的移动端样式库完成开发，界面丑先不说了，文档！文档前后对不上！也怪我，小看了需求，应该不明白就问，问清楚了各个环节再动手操作。结果自然好不了，也是反反复复的改……可能不会有人愿意再维护那份代码。</p><h3 id="不断变更的需求"><a href="#不断变更的需求" class="headerlink" title="不断变更的需求"></a>不断变更的需求</h3><p>无法在一开始敲定需求，一定会产生烂代码。在理想情况下做好规划、有充裕的时间和高素质的开发人员完成工作，各种设计、模式自然是好的。现实一定不是那样。</p><p>vue的前端项目里有一种惯用的写法，是对axios的封装，在一个单独的api.js里写各种export，然后在模块中import。据说是为了统一管理api的url还是什么，总之在实际的开发过程中，发现这实在是繁琐的写法，带来了很多开发上的不便。维护更容易了吗？并没有。原因之一就是需求在不断变化，如果api里的注释不够清晰也不够准确，那单独抽出来毫无意义。</p><pre><code>// api.jsexport a = () =&gt; &#123; get(&#39;a&#39;) &#125;// model.jsimport &#123;a&#125; from api.jsa().then(res =&gt; &#123;&#125;)</code></pre><p>如果api中的a函数和路由a不完全对应，需要修改api.js时就不得不到对应的页面中去找是哪个函数，这和直接把路由写在页面中没有区别。或许可以试着把路由访问的函数在每个模块或者每个页面顶部封装一下，让模块或者页面里的api是自治的。</p><p>前端项目里比起api，更让人难过的是随处可见的css！更更让人难过的是项目已经成型了！同样是背景色的配置，index里写一遍，common里写一遍，model里写一遍，甚至内联的写法再来一遍……问题是各个地方的配置内容还不一样。背景色这种样式还好，可怕的是文档流，定位，浮动，边距……css真正的内功是文档流吧，假如完全不懂还撑起了整个项目，这样的代码谁敢动？</p><h3 id="懒得重写的需求"><a href="#懒得重写的需求" class="headerlink" title="懒得重写的需求"></a>懒得重写的需求</h3><p>随着需求的不断变更，会出现的另一个现象是以前的代码能复用就复用，以最快的速度完成现在的需求，反正不知道以后需求会不会变，要是每次都重构出整洁的代码，工作量和工作效率……这绝对是产生烂代码的途径之一。</p><p>后端开发中有个我不太喜欢的东西，bean，也叫entity，不知道是从哪个年代流传下来的做法，包括模板化的dao和service，写个IClass再写个ClassImpl有多大意思呢。bean不利于需求变更，有时候用map反而好一点。回到一开始提到要验收的项目，我写出的烂代码和bean不无关系，大概就是bean的设计包含有很多个字段，后来需求变了，字段也变了，如果要改就要改很多地方，天知道以后需求还会不会变，就强行复用了，导致有些字段含义不明，有些字段完全对不上，仅仅是占用了位置来储存数据。</p><p>当然，框架的选择失误也是产生垃圾代码的原因，这要归因于我经验不足，不得不承认架构师在项目管理中起到的核心作用。</p><h3 id="开发中的困境"><a href="#开发中的困境" class="headerlink" title="开发中的困境"></a>开发中的困境</h3><p>一个是起名字的难题，偶尔写错了接口名称，或者复制粘贴相似的逻辑，懒得改变量名，产出的代码一定难以维护，这就可见code review真是企业开发中不可缺少的一步，不过中小公司可能对代码质量的要求也没那么高，除非是要上线的、会涉及到线上业务的代码，review是必须的，搞不好会出人命的，普通的开发可能就没那么严格。</p><p>另一个是模块划分的问题，比如a页面有文件上传，b页面有文件下载，那么文件上传下载是不是应该放在同一api路径？都是文件操作，好像挺对的。可如果其他api都是按照页面划分，同一个页面的所有接口都在同一路径下，那单独把文件操作拎出来是不是有点突兀？有时也会按照数据表划分模块，一遇到联表的操作就不好约定了。各种规则混着用多半会引起混乱，让代码难堪。</p><h3 id="？"><a href="#？" class="headerlink" title="？"></a>？</h3><p>年终之际，还是要给我的2019画上一个圆满的问号。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;前段时间尝试了一些线下活动，加上有几天身体异常痛苦，现在稍微静下来感觉恍如隔世。最近有个项目在做最后的验收，于是搬出了一两个月前的代码，需要手动操作更新一些数据。看到这些不久之前写的代码，同样恍如隔世的感觉，如果这是别人写的，我一定会第一时间认为很垃圾，既然是我亲手写的，客</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Haskell中的Monad是什么？</title>
    <link href="https://smallyu.net/2019/11/26/Haskell%E4%B8%AD%E7%9A%84Monad%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://smallyu.net/2019/11/26/Haskell%E4%B8%AD%E7%9A%84Monad%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2019-11-26T05:34:02.000Z</published>
    <updated>2024-08-03T19:07:09.967Z</updated>
    
    <content type="html"><![CDATA[<p>第一次听说Monad是在一个Scala Meetup上，后来试着了解Monad的概念，却头疼于Haskell的各种大部头的书和教程。再后来看到阮一峰在2015年发表的《<a href="http://www.ruanyifeng.com/blog/2015/07/monad.html">图解 Monad</a>》，虽然清晰易懂，但是脱离了Haskell，图片的表意和语言中的概念对不上。阮一峰的文章译自《<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a>》，我阅读了原文。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>计算机程序用于控制计算机进行运算，程序操作的对象是各种不同类型的值，比如数值。这是一个简单的值<code>2</code>：</p><img src="1.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>用函数对值进行一些处理，可以返回函数执行的结果，比如：</p><img src="2.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>除了简单的数值类型，值也有可能被包含在一些上下文环境中，组成更复杂的值类型。可以把上下文环境想象成盒子，数值放在盒子里面，这个盒子整体作为一个值，描述为<code>Just 2</code>，也就是带盒子的<code>2</code>：</p><img src="3.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>如果对Java有过了解，可以将这个盒子理解为包装类，比如Integer和int，对应带盒子的2和不带盒子的2。</p><h3 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h3><p>面对带盒子的<code>2</code>，我们无法直接把<code>+3</code>的函数作用在它上面：</p><img src="4.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>这时需要一个函数<code>fmap</code>来操作。fmap会先从<code>Just 2</code>中取出数值2，然后和3相加，再把结果5放回盒子里，返回<code>Just 5</code>：</p><img src="5.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>fmap怎么知道该如何解析<code>Just</code>？换一个其他像<code>Only</code>之类的类型，还能解析吗？所以就需要Functor（函子）来完成<code>定义</code>的的操作。</p><p>Functor是一种数据类型：</p><img src="6.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>Functor定义了fmap的行为：</p><img src="7.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>fmap有两个入参和一个出参，入参分别是一个函数和一个带盒子的值，出参是一个带盒子的值，可以这样使用：</p><pre><code class="Haskell">fmap (+3) (Just 2)-- Just 5</code></pre><p>回到Haskell，在Haskell的“系统类库”中有一个<code>Functor</code>的实例<code>Maybe</code>，<code>Maybe</code>中定义了<code>fmap</code>的行为，指定了面对<code>Just</code>类型的入参时对值进行操作：</p><pre><code class="Haskell">instance Functor Maybe where  fmap func (Just val) = Just (func val)  fmap func Nothing = Nothing</code></pre><p>表达式<code>fmap (+3) (Just 2)</code>的整个过程类似这样：</p><img src="8.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>同理，从<code>Maybe</code>的定义中能看出，如果传入fmap的第二个参数是<code>Nothing</code>，函数将返回<code>Nothing</code>，事实确实如此：</p><img src="9.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><pre><code class="Haskell">fmap (+3) Nothing-- Nothing</code></pre><p>现在假设一个Java的场景，用户使用工具类Request发起一个向服务器的请求，请求返回的类型是Response，Response是一个实体类，可能包含所需数据data也可能不包含：</p><pre><code class="Java">Response res = Request.get(url);if (res.get(&quot;data&quot;) != null) &#123;  return res.data;&#125; else &#123;  return null;&#125;</code></pre><p>使用Haskell中fmap的写法就变成了：</p><pre><code class="Haskell">fmap (get(&quot;data&quot;)) (Response res)</code></pre><p>当然Haskell不存在<code>get(&quot;data&quot;)</code>这样的写法，可以将由Response获取Response.data的操作封装为函数getData，然后传入fmap作为第一个参数。</p><p>Haskell提供了fmap函数的语法糖<code>&lt;$&gt;</code>简化fmap的写法：</p><pre><code class="Haskell">getData &lt;$&gt; (Response res)</code></pre><p>再来想一个问题，Haskell的函数是如何对列表进行操作的？函数会对列表的每一个元素都进行计算，然后返回列表：</p><img src="10.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>其实列表也是Functions，这是列表的定义：</p><pre><code class="Haskell">instance Functor [] where  fmap = map</code></pre><h3 id="Applicatives"><a href="#Applicatives" class="headerlink" title="Applicatives"></a>Applicatives</h3><p><code>Applicatives</code>是另一个概念，我们之前说数据被放在盒子里，如果函数也被放在盒子里呢？</p><img src="11.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>Haskell的系统提供了操作符<code>&lt;*&gt;</code>用于处理盒子里的函数：</p><img src="12.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>例如：</p><pre><code class="Haskell">Just (+3) &lt;*&gt; Just 2 == Just 5</code></pre><p>使用<code>&lt;*&gt;</code>还可以完成一些有趣的操作，比如分别让列表中的元素*2和+3：</p><pre><code class="Haskell">[(*2), (+3)] &lt;*&gt; [1, 2, 3]-- [2, 4, 6, 4, 5, 6]</code></pre><img src="13.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><h3 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h3><p>函数的执行是使用<code>带入参</code>的<code>函数</code>处理<code>值</code>，涉及到三个角色。<code>Functors</code>是被处理的<code>值</code>放在盒子里，<code>Applicatives</code>是<code>函数</code>放在盒子里，<code>Monads</code>则是将函数的<code>入参</code>放在盒子里。Monads有一个操作符<code>&gt;&gt;=</code>来实现Monads的功能。假设现在有一个函数<code>half</code>的入参是数值，如果是偶数就除以2，否则返回Nothing:</p><pre><code class="Haskell">half x = if even x  then Just (x `div` 2)  else Nothing</code></pre><img src="14.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>想要给<code>half</code>传一个<code>Just</code>类型的值怎么办？</p><img src="15.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p><code>&gt;&gt;=</code>可以解决这个问题：</p><pre><code class="Haskell">Just 3 &gt;&gt;= half-- Nothing</code></pre><p><code>&gt;&gt;=</code>操作符把<code>Just 3</code>变成了<code>3</code>放在<code>half</code>中进行计算。<code>Monad</code>是一个数据类型，定义了<code>&gt;&gt;=</code>的行为：</p><pre><code class="Haskell">class Monad m where  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code></pre><img src="16.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><p>这里的<code>Maybe</code>是一个<code>Monad</code>（和上文的Maybe同时存在）:</p><pre><code class="Haskell">instance Monad Maybe where  Nothing &gt;&gt;= func = Nothing  Just val &gt;&gt;= func = func val</code></pre><p><code>&gt;&gt;=</code>还支持链式的操作：</p><pre><code class="Haskell">Just 20 &gt;&gt;= half &gt;&gt;= half &gt;&gt;= half-- Nothing</code></pre><img src="17.png" style="box-shadow: 0 0 0 #fff; margin-left: 0;" /><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然Haskell的Monad比较有名，但实际上涉及到三个概念<code>Functors</code>、<code>Applicatives</code>和<code>Monads</code>，可能Monad的应用比较广泛一点。在数据处理上，FP并不比OOP高级，逻辑是相似的，只是写法不同。面对同样的问题使用不同的思维方式和表达方式去解决，对应了不同的编程思想和编程范式。世界上有很多精妙的理论等待我们探索。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;第一次听说Monad是在一个Scala Meetup上，后来试着了解Monad的概念，却头疼于Haskell的各种大部头的书和教程。再后来看到阮一峰在2015年发表的《&lt;a</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>浅析Libra背后的区块链技术</title>
    <link href="https://smallyu.net/2019/11/20/%E6%B5%85%E6%9E%90Libra%E8%83%8C%E5%90%8E%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    <id>https://smallyu.net/2019/11/20/%E6%B5%85%E6%9E%90Libra%E8%83%8C%E5%90%8E%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/</id>
    <published>2019-11-20T09:21:18.000Z</published>
    <updated>2024-08-03T19:07:10.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间国家领导人曾公开表示鼓励区块链技术的研究，称要把区块链作为核心技术自主创新的突破口。Libra的发行计划是区块链发展史上一座重要的里程碑，本文从合约语言、数据库协议、逻辑数据模型、数据结构、共识协议等方面简要介绍Libra区块链的技术方案。</p></blockquote><p>2019年5月，Facebook首次确认推出加密货币的意向，“全球币”、“脸书币”的消息不胫而走。6月18日，Facebook正式宣布将推出名为Libra的加密货币，预计2020年上半年针对性发布。Facebook宣称，Libra建立在安全、可靠、可扩展的区块链上，采用链外资产抵押的模式，锚定一篮子法定货币作为资产担保，由独立的Libra协会治理。Facebook在全球拥有27亿用户，Libra的愿景是建立一套简单、无国界的货币，为数十亿人提供金融服务。</p><p>Facebook正式宣布Libra后，同步上线了Libra的官网、白皮书和测试网络等内容。白皮书中提到，Libra网络希望未来以公有链的形式运作，但由于目前没有成熟的技术能在公有链上支撑大规模的交易，Libra将以联盟链的形式起步，计划三到五年内展开由联盟链过渡为公有链的研究。</p><p>Libra官网公布了三篇论文详细说明Libra使用的技术方案，这三篇论文分别是《Libra区块链》、《Move：一种具有可编程资源的语言》和《Libra区块链中的状态机复制》。Libra为满足高度安全、足够灵活、吞吐量极高等要求，设计了新的编程语言Move，选择BTF共识机制，采用广泛使用的Merkle Tree作为数据结构。本文简要介绍Libra区块链的相关技术。</p><h3 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h3><p>当现实世界的资产进入Libra储备，系统会创建相应的数字资产Libra货币，这些数字资产在不同账户之间流通，当现实中的资产离开Libra储备，对应的数字资产也随之销毁。Fackbook设计了新的编程语言Move用于对Libra中的数字资产进行管理，Libra在Move中将数字资产表示为资源（resource）。</p><p>Move是带有类型的字节码语言，资源是Move的类型之一，程序在执行前会先经过字节码验证器检验，然后由解释器执行。Move中的资源仅支持copy和move两种操作，可以理解为copy移出资源，move移入资源，也就是说资源和普通的变量类型不同，资源的值可以赋给普通变量，但资源本身只能在地址间移动，不能复制或丢弃。如果在程序中使用了违反规则的copy和move操作，比如copy一次move两次，程序将无法通过字节码验证器，因为在第一次move后原先的资源就已经不可访问了。</p><p>使用Move可以编写自定义的交易逻辑和智能合约，相比现有的合约语言要更加强大。比特币脚本提供了简洁优雅的设计用于表达花费比特币的策略，但是比特币脚本不支持自定义数据类型和程序，不是图灵完备的。以太坊虚拟机倒是支持流程控制、自定义数据结构等特性，但太过自由的合约让程序的漏洞随之增多，发生过多起安全事件。Move的静态类型系统为数字资产的安全性提供了保障。</p><p>为了配合静态验证工具的验证，Move在设计上采取了一些措施：没有动态调度，让验证工具更容易分析程序；限制可变性，每一次值的变化都要通过引用传递，临时变量必须在单个脚本中创建和销毁，字节码验证器使用类似Rust的”borrow checking”机制保证同一时间变量只有一个可变引用；模块化，验证工具可以从模块层面对程序进行验证而不需要关心具体实现细节，等等。Move的这些特性都使得静态验证工具更加高效可靠。</p><pre><code>public main(payee: address, amount: u64) &#123;  let coin: 0x0.Currency.Coin = 0x0.Currency.withdraw_from_sender(copy(amount));  0x0.Currency.deposit(copy(payee), move(coin));&#125;</code></pre><p>这是一段交易脚本的示例程序，是Move语言的中间表示（IR），IR更适合程序员阅读和编写。程序实现了一个转移资源的函数，main方法是脚本的入口，包含两个入参：目标地址和金额。程序先从0x0地址Currency模块中移出amount个资源暂存到coin变量，然后将coin的资源移动到payee的地址上。</p><p>交易脚本是为Move提供灵活性的一个方面，另一方面来自安全的模块化设计。交易脚本让交易逻辑更加自由，模块化设计则让保证了脚本程序的多样化。模块的类型是<code>module</code>，主要包含Move程序，一个模块可以包含任意个资源，也就是声明另个或多个资源类型的变量，modules&#x2F;resources&#x2F;procedures相当于面向对象语言中的classes&#x2F;object&#x2F;methods，不同的是Move中并没有self、this之类的概念。</p><h3 id="Libra协议"><a href="#Libra协议" class="headerlink" title="Libra协议"></a>Libra协议</h3><p>Libra区块链是一个需要经过密码学认证的分布式数据库，用于储存可编程资源，比如Libra货币就是可编程资源，在Move中表现为资源。Libra协议中有两种实体类型，验证节点（validators）共同参与维护数据库，客户端（client）通常发起向数据库的请求。Libra协议会在执行过程中选举出leader接收客户端的请求，然后leader将请求同步到其他验证节点执行，其他验证节点执行结束后把结果返回给leader，leader再把请求的最终结果返回客户端。</p><p>Libra的交易会经过很多步骤，包括验签、运行先导程序、验证交易脚本和模块程序的正确性、发布模块、执行交易脚本、运行结尾程序等。为了使合约交易的计算能力可计量，Libra吸收了以太坊中Gas的概念，消耗Gas作为交易的费用。</p><img src="a.png" width="100%" style="box-shadow: 0 0 0px #fff;"><p>这张图详细展示了交易请求在Libra的网络组件中流转的过程，客户端发起请求到权限控制层，权限验证后将请求数据转给虚拟机进行预处理，同时数据也会进入内存池中，内存池负责将请求同步到其他节点，共识协议在请求同步的过程中发挥作用，节点同步结束后虚拟机执行真正的交易程序，程序执行完毕对结果持久化，基本流程结束。</p><h3 id="逻辑数据模型"><a href="#逻辑数据模型" class="headerlink" title="逻辑数据模型"></a>逻辑数据模型</h3><p>Libra区块链上所有的数据都保存在有版本号标识的数据库中，版本号是64位无符号整数。每个版本的数据库都包含一个元组 (T, O, S)，T代表交易，O代表交易的输出，S代表账本的状态。当我们说执行了一个Apply操作，表示为Apply(S, T) -&gt; (O, S)，意思是在S状态下执行了T交易，产生了O输出并且账本的状态变为S。</p><p>账户是资源的拥有者，可以使用账户内的资源进行交易。账户地址是一个256位的值，创建新账户需要一个验证&#x2F;签名的键值对（vk, sk），新的账户地址a由vk经过公钥加密计算得到，a &#x3D; H(vk)。具体来说Libra使用SHA3-256实例化哈希函数，使用wards25519椭圆曲线做变量的EdDSA公钥进行数字签名。交易过程中由已经存在的账户调用create_account(a) 指令即可生成新账户。</p><img src="b.png" width="80%" style="box-shadow: 0 0 0px #fff;"><p>上图所示有四个以0x为前缀的账户地址，矩形框表示模块，椭圆形表示资源，箭头表示依赖关系。图中0x12账户中的Currency.T在Currency模块中声明，Currency模块的代码储存在0x56地址上。同理，0x34的StatChannel.T声明自0x78的StateChannel模块。当客户端想要访问0x12下的Currency.T，请求资源的路径应写作0x12&#x2F;resources&#x2F;0x56.Currency.T。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Libra交易区块中包含各节点签名的数据，交易前会对签名数据进行校验，根据这一集体签名客户端可以相信请求的数据库版本是完整有效的，也因此客户端可以请求任意节点甚至是第三方数据库副本进行查询。Libra协议中的数据结构主要基于默克尔树。</p><img src="c.png" width="100%" style="box-shadow: 0 0 0px #fff;"><p>如图所示，账本历史数据的根哈希用来验证系统的完整状态，账本数据由默克尔树累加形成，虚线表示数据累积的过程。账本历史数据的每一个节点都包含交易签名、事件树和账本状态，事件树也是基于默克尔树，账本状态则是基于稀疏默克尔树，账本状态的每个叶子节点都包含有账户数据。</p><p>Libra协议中验证节点V会对数据D的根哈希a进行校验。例如不受信任的节点在获取到数据D后使用函数f对数据进行运算，希望得到结果r，同时还需要一个用于验证函数结果正确性的数据π，协议会要求节点把(a, f, r, π)都传到验证节点V处进行验证，如果f(D) &#x3D; r则通过验证。</p><img src="d.png" width="70%" style="box-shadow: 0 0 0px #fff;"><p>在上图中，数据D &#x3D; {0:s0, 1:s1, 2:s2, 3:s3}。假设f是获取第三项数据的函数，也就是要获取h2的数据，期望结果f(D) &#x3D; h2，此时h2就是r，r &#x3D; h2，用于验证计算结果正确性的数据π &#x3D; [h3, h4]，根哈希a &#x3D; H(h4||h5) &#x3D; H(h4 || H(H(2 || r) || h3))，验证节点将执行Verify(a, f, r, π)对计算结果进行验证。</p><h3 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h3><p>Libra选择使用的是拜占庭容错共识，实现了一种HotStuff共识的变体LibraBFT，简称LBFT。LBFT协议的主要作用是让提交的块在同一个序列上，或者说避免分叉。每三次提交为一轮操作，每一次提交验证节点都会投票选举出下一轮的leader，同时这些投票的集合形成一个法定证书（QC），每一轮的第一个块记为preferred_round，下一个块写入时对preferred_round的QC进行验证，也就是preferred_round后的第一、二、三个块都与preferred_round校验，第四个块将是第二轮的preferred_round，依次更迭。</p><img src="e.png" width="50%" style="box-shadow: 0 0 0px #fff;"><p>如图所示，k是preferred_round，如果在k处出现了分叉，并且有2f + 1个验证节点投票给了k，k+1将接在k的后面，k+2依次写入，k左侧的分叉失效。这时假如k+3的leader超时了，k+4成为新的leader并写入在preferred_round（k）的后面，会引起新的分叉。如果k+4获得2f+1个投票，k+5会按照规则写入在k+4后面。</p><p>在k+4分叉后，当超时的k+3再次被选为leader并重新提交，验证节点会对k+3的preferred_round（k）的QC进行校验，校验通过，k+3写入在了k+2的后面，这符合规则。再然后，下一个leader（k+6）的preferred_round实际上是k+4，准备提交块到k+3后面时发现QC对不上，k及其后的k+1、k+2、k+3都会被删除，k+4后的链成为主链。</p><p>LBFT基本上是对链式HotStuff的实现，并没有太多创新，Libra团队更多的是在共识协议中做出一种选择，对BFT的选择是好是坏还存在争议，需要时间来验证，LBFT算是Libra从联盟链到公有链过渡前的方案，预计至少支持100个节点，上限大概是1000个左右。和HotStuff一样，LBFT最多容忍三分之一的不诚实节点。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Libra协议目前还处于比较早期的阶段，性能上并不算惊艳，支持每秒1000笔交易，每次提交的交易确认时间大概是10秒钟。Libra协议在设计上很多也是兼顾了性能，比如每三次提交进行一次共识，每一轮操作内不需要等待就可以进行投票，这减少了客户端和验证节点之间的网络延时；考虑到并行和分片的思想，稀疏默克尔树的使用使得账户的身份数据可以跨数据库进行验证，也支持并行更新等等。</p><p>Libra选择了众多成熟的技术构建Libra系统，使用内存安全的Rust编写核心程序、使用容易验证的Merkle Tree作数据结构、基于Chained HotStuff实现共识协议等等。Move是Libra在技术上最大的亮点之一，在语言层面保证了数字资产的安全性，Move本身是一种字节码语言，难以阅读，所以提供了Move的中间表示IR，用于编写交易脚本和智能合约。Libra作为一种在金融领域的创新实验，基于区块链提出了世界货币的愿景，其社会意义可能要远大于在技术创新上所带来的意义。Libra协会目前拥有16个成员组织，涵盖支付业、电信业、区块链业、风险投资业等领域，已经在世界范围引起广泛关注。</p><p>Libra预计2020年上半年针对性发布，让我们拭目以待！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前段时间国家领导人曾公开表示鼓励区块链技术的研究，称要把区块链作为核心技术自主创新的突破口。Libra的发行计划是区块链发展史上一座重要的里程碑，本文从合约语言、数据库协议、逻辑数据模型、数据结构、共识协议等方面简要介绍Libra区块链的技术方案。</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>对区块链的理性认识</title>
    <link href="https://smallyu.net/2019/11/05/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A4%E8%AF%86/"/>
    <id>https://smallyu.net/2019/11/05/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E7%90%86%E6%80%A7%E8%AE%A4%E8%AF%86/</id>
    <published>2019-11-05T05:53:58.000Z</published>
    <updated>2024-08-03T19:07:10.104Z</updated>
    
    <content type="html"><![CDATA[<p>曾以为区块链是革命性的、颠覆性的技术，毕竟区块链和人工智能、大数据并列互联网前沿技术。但是，人工智能达到真正的智能暂时还是梦，大数据也实现不了像《复联》里一样的精准分析。前几天国家领导人对区块链的讲话振奋人心，可过去几年的物联网、互联网+，不也都无疾而终了吗。</p><h3 id="公有链无法脱离货币"><a href="#公有链无法脱离货币" class="headerlink" title="公有链无法脱离货币"></a>公有链无法脱离货币</h3><p>有的观点认为，核反应最初的目的是建造核弹，而核反应现在也作为电能的来源服务于人民，区块链最初的目的是支持比特币的运作，现在我们想要区块链应用于其他方向。也就是说，观点认为核反应的位置和区块链是对等的。</p><pre><code>核反应 -&gt; 核弹区块链 -&gt; 比特币</code></pre><p>可是仔细想想，到底该如何对比这几乎完全不一样的两种事物。如果你看过几本区块链相关的书，会发现讲的东西并不会特别新鲜，观点也完全够不上所谓革命、创新。比特币诞生至今不过10年左右，并没有克服技术上的难题，只是不同机制的组合，它应该和P2P或者某种电子游戏处在同一地位。比特币的价值在于进行电子交易，而不是货币本身。</p><pre><code>核反应 -&gt; 核能量 -&gt; 大爆炸区块链 -&gt; 比特币 -&gt; 电子交易</code></pre><p>因为核反应，才能产出核能量，有了核能量，才能够产生大爆炸。因为区块链，才有了比特币，有了比特币，才能够进行电子交易。所以这样来看，核能量是离不开核反应的，比特币是离不开区块链的。</p><p>那么，区块链能够离开比特币单独应用于场景吗？或者说，其实区块链和比特币是一体的，就像核反应产生出的核能量，有价值的是能量而不是反应，区块链产出比特币，运作于区块链上的比特币才有所谓匿名、不可篡改、可溯源等特性，有价值的是比特币而不是区块链。</p><p>几天前广州市政府发布补贴区块链企业的细则（<a href="http://www.gz.gov.cn/gzswjk/2.3.6.3/201910/7beb40281dde4fa2beee0da2b16aa6dc.shtml">实施细则</a>），明确要求“无币”公有链项目。这项政策，一方面是国家不允许发币，另一方面，公有链无币其实是区块链最理想的情况，一般来说，理想是难以实现的。</p><p>比特币解决的是交易中的信任问题，解决方式归根结底是数据存在哪儿。两个人进行交易，如果由交易发起方记账，或者交易接受方记账，或者两个人都记账，无论谁记，只要有一方说谎，甚至不说谎，他就是记错了，都会产生争执，不认账怎么办！这时就需要第三方机构介入，通过银行记账，通过律所解决纠纷。要是连银行、政府、法律都不相信，就不用活了。</p><p>如果真的不信任中心化的机构，比特币提出的办法是，让全世界的人都为你记账，全世界的人都会记住两个人的交易记录，谁给谁转账多少，这样无论如何都不再会有差错，除非全世界一半以上的人都犯了同样的错误。所以问题在于，凭什么让全世界的人为两个人的个人交易记账？人家为什么要记？于是将比特币作为奖励，谁记账了，并且被系统认为记的账是有效的，谁就可以得到奖金。</p><p>没有奖励，世界上的人不会主动为你记账，分布式账本还怎么维持运行？</p><h3 id="比特币并非去中心化"><a href="#比特币并非去中心化" class="headerlink" title="比特币并非去中心化"></a>比特币并非去中心化</h3><p>有人认为分布式记账、分布式数据库就已经是去中心化了，但这一定不是去中心化的最终形态。比如，比特币程序的开发、维护和升级？数据确实天下共享，但程序还是要有人制定规则，有人开发，有人发布，出bug了要有人修复，有更好的点子了要迭代升级，分布式的数据全部经由中心化的程序发布中心发布的程序处理。目前解决程序上信任的方式是将程序开源……这一点暂且可行，但是程序升级带来的困难就要大多了，要么确保向下兼容，要么确保所有人更新程序。</p><p>另外，比特币的数据冗余是个极大的问题，每个节点都需要备份全量数据，而且大多数是不相关的历史数据。如果单个节点不保留全部数据，就无法保证分布式数据的可靠性，但如果保留全部数据，又是对资源很大的浪费。中心化系统一份数据就可以解决的问题，为了能够相互信任，就多出来几十亿份数据？就好比我不相信银行，就自己造一个银行，自己管自己？</p><p>可以畅想一下，在牺牲去中心化概念的情况下，能够有哪些可能。</p><p>一、全球共用一个数据库，数据库只承担储存数据的任务，分布式程序只解决共识问题。数据库非常安全，数据容量非常大，但是写入规则严格，需要全球一半以上的人认可，或者通过其他的共识机制准入。任何人可以随意查询，可溯源，历史数据不能修改。共识程序是必要的，决定了哪些数据可以写入，比如判断余额是否足够，而且是全世界的人一起判断，如果有坏人想要写入非法数据，需要买通全球一半以上的人……这样数据冗余最少。</p><p>二、每个节点只保留一半数据，数据拆分为历史的一半和当前的一半。一个人储存最新的一半数据，另一个人储存旧的一半数据，旧数据只需要负责储存，当新数据过多时同步到旧数据这里。新数据负责接收广播、写入数据，功能等同于现在的节点，如果遇到需要查询历史数据的情况，就从旧数据的一半查。相当于两人合作完成一个节点，新旧节点随时随机搭配，节点的新旧由系统平均分配。至于安全性，因为全网的节点随机配对，应该不会低于比特币，最坏的情况是一半的节点全部挂掉。同理，可将两份数据扩展到多份数据的情况。</p><p>三、每个节点只保留一半数据或者更多份，数据对半拆分。就是同一条数据，按照一定规则拆分为多个数据包，分别储存在不同的节点，参考HDFS的储存方式，存在一定冗余，但又节省了不少空间。再激进一点，数据可以实现自验证，网络中的每个节点储存的数据大小是随机的，当用户查询某一条数据时，从全网的节点中搜寻可以组成所需数据的节点，然后从中取出数据。也就是说整个节点网络的数据都混杂在一起，难点变成了如何给数据包设计自验证机制。</p><h3 id="数字货币和区块链没有关系"><a href="#数字货币和区块链没有关系" class="headerlink" title="数字货币和区块链没有关系"></a>数字货币和区块链没有关系</h3><p>有的人谈到区块链的应用，会把央行关于数字货币的研究给扯上，甚至某交易所知名总监，以区块链为主题的演讲，却把比特币和Libra的趣闻轶事说了一遍。很多人都在忽略概念上的区别，这无关紧要，也至关重要。央行说有发行数字货币的计划，也说过区块链可以作为技术选择之一，但区块链从不是必须的技术。区块链对于国家的意义，是“以去中心化之名，行中心化之实”，意在一统国内互联网，方便监管。即使没有区块链，国家也有能力实现各种应用，只是借势上了区块链的船而已。</p><p>过去的区块链指支撑比特币运行的技术体系，未来的区块链将几乎约等于联盟链。</p><p>华为区块链白皮书中的观点很客观，区块链是互联网的补充，它不会脱离传统数据库，离不开TCP，只是在特定场合下发挥独特的作用。对于国家来说，链上的数据清晰可见，没有人能暗箱操作；对于企业来说，可以方便的实现制衡，几家企业合作共享一组数据，区块链则是打开大门的钥匙。如果没有区块链，可能说不上来数据共享是个什么样子，区块链诞生了，并且比特币在世界范围稳定运行了十多年，所以这是可信的、有前途的技术方向，大家都争先恐后创新、落地。</p><p>可以预见，未来区块链的开发会分为两类，一类底层开发，一类应用层开发。底层开发的技术要求更高，开发者素质更高，应用层开发则类似于现在的Web开发。会先后出现一些区块链应用提供商，也会相应的出现一些SDK，开发者调用区块链储存数据、进行交易，类似于现在调用数据库提供的API、请求支付机构的接口。</p><h3 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h3><p>区块链会被广泛应用到我们的网络中，但不足以改变世界。（不要笑）</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>无意间发现了分布式网络 <a href="https://github.com/HelloZeroNet/ZeroNet">ZeroNet</a> ，是一个早在2015年就发布的项目，它几乎满足了所有我对区块链储存系统的想象，而且功能完备，可以基于这个网络搭建博客、论坛、邮箱、共享文件等。当然，我曾想到的、应该存在的问题，ZeroNet也一个都没有解决，算是对我的一些想法的验证，惟一不同的是我希望将分布式网络对接到公网，但ZeroNet的做法是建立了一套自治的网络系统，包括.bit域名也只能作为URI的后缀，这无疑限制了该网络无法被更加广泛传播使用。另外，由于点对点文件系统难以监管，GWF将ZeroNet列入名单，这虽然是特殊现象，但ZeroNet和IPFS等网络似乎可以说明，区块链最适合也只能应用于金融领域或者受限制的互联网中。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;曾以为区块链是革命性的、颠覆性的技术，毕竟区块链和人工智能、大数据并列互联网前沿技术。但是，人工智能达到真正的智能暂时还是梦，大数据也实现不了像《复联》里一样的精准分析。前几天国家领导人对区块链的讲话振奋人心，可过去几年的物联网、互联网+，不也都无疾而终了吗。&lt;/p&gt;
&lt;h</summary>
        
      
    
    
    
    
    <category term="区块链" scheme="https://smallyu.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础语法概述</title>
    <link href="https://smallyu.net/2019/08/19/Rust%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>https://smallyu.net/2019/08/19/Rust%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/</id>
    <published>2019-08-19T14:12:25.000Z</published>
    <updated>2024-08-03T19:07:09.973Z</updated>
    
    <content type="html"><![CDATA[<p>Rust是复杂度和应用场景都对标C++的语言，一起学习吧！</p><p>最近，我开始思考像本文这样类型的内容算什么，编程语言的教程？内容不全面；对语言的评价？够不着；学习笔记？如果是，那绝非我本意。我倾向于认为这是一个探索的过程，无论对于我自己还是对于别人，我希望可以表现出来的是，你看，新的编程语言没什么神秘的，它如此简单！有的程序员终其一生，都将某种语言作为自己职业头衔的前缀，“Java程序员”或是“后端开发”，我们该跳出这种怪圈。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>Rust必须以<code>;</code>结尾。</p><h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><p>Rust使用<code>let</code>定义常量，使用<code>let mut</code>定义变量。这样的写法可能稍微有点奇怪：</p><pre><code class="Rust">fn main() &#123;  let x = 1;  println!(&quot;&#123;&#125;&quot;, x);  let mut y = 2;  println!(&quot;&#123;&#125;&quot;, y);  y = 3;  println!(&quot;&#123;&#125;&quot;, y);&#125;</code></pre><p>不同于其他语言的是，Rust允许在同一作用域中多次声明同一常量。也就是说，Rust里的常量虽然不可以被第二次赋值，但是同一常量名可以被多次定义。我们虽然能在系统层面明白常量和变量的区别，但是写法上稍微有点容易引起混淆。我多次给同一组符号赋值，这个符号不就是变量吗？</p><pre><code class="Rust">fn main() &#123;  let x = 1;  println!(&quot;&#123;&#125;&quot;, x);  let x = 2;  println!(&quot;&#123;&#125;&quot;, x);&#125;</code></pre><p>另一个有点奇怪的地方是，Rust的变量不允许重复定义。我们无法推测语言设计者的初衷，这明显不是为了允许重复定义而允许。也许，Rust中只存在常量，<code>mut</code>关键字的作用就是给常量一个可以被多次赋值的接口。没有mut，常量就是个常量，有了mut，常量就有了获得新值的“入口”。至于变量重复定义的问题，要啥自行车？</p><pre><code class="Rust">fn main() &#123;  let mut x = 1;  let mut x = 2;&#125;// warning: variable does not need to be mutable</code></pre><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>Rust的条件部分不需要写小括号，和Go语言一样。谁先谁后呢？</p><pre><code class="Rust">fn main() &#123;  let number = 2;  if number == 1 &#123;    println!(&quot;1&quot;)  &#125; else if number == 2 &#123;    println!(&quot;2&quot;)  &#125; else &#123;    println!(&quot;3&quot;)  &#125;&#125;</code></pre><p>由于if语句本身是一个表达式，所以也可以嵌套进赋值语句中，实现类似其他语言三目运算符的功能。（Rust是强类型的语言，所以赋值类型必须一致。）</p><pre><code class="Rust">fn main() &#123;  let number = if true &#123;    3  &#125; else &#123;    4  &#125;;  println!(&quot;&#123;&#125;&quot;, number);&#125;</code></pre><p>与Go语言简洁的多功能for循环相比，Rust支持多种类型的循环：</p><pre><code class="Rust">fn main() &#123;  loop &#123;    // ...  &#125;  while true &#123;    // ...  &#125;  let a = [1, 2, 3];  for item in a.iter() &#123;    println!(&quot;&#123;&#125;&quot;, item);  &#125;&#125;</code></pre><h3 id="函数与值的传递"><a href="#函数与值的传递" class="headerlink" title="函数与值的传递"></a>函数与值的传递</h3><p>Rust似乎不存在值传递与引用传递的区别，因为Rust中全都是引用传递，或者分类为常量的传递与变量的传递。对比Java中字符串的创建，Rust中创建字符串也可以使用“声明对象”的方式：</p><pre><code class="Rust">fn main() &#123;  // 常量传递  let a = String::from(&quot;a&quot;);  testa(&amp;a);  // 变量传递  let mut b = String::from(&quot;b&quot;);  testb(&amp;mut b);  println!(&quot;&#123;&#125;&quot;, b);&#125;fn testa(a: &amp;String) &#123;  println!(&quot;&#123;&#125;&quot;, a);&#125;fn testb(b: &amp;mut String) &#123;  b.push_str(&quot; b&quot;);&#125;</code></pre><p>函数当然也是可以有返回值的，Rust中函数的返回值用<code>-&gt;</code>定义类型，默认将函数最后一行的值作为返回值，也可以手动return提前结束函数流程。需要注意的是，在最后一行用来作为返回值的表达式，记得不要加封号……</p><pre><code class="Rust">fn main() &#123;  let mut a = test();  println!(&quot;&#123;&#125;&quot;, a);  a = test2();  println!(&quot;&#123;&#125;&quot;, a);&#125;fn test() -&gt; u32 &#123;  1&#125;fn test2() -&gt; u32 &#123;  return 2;&#125;</code></pre><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体的基本用法比较常规，没有<code>new</code>关键字，直接“实例化”就可以使用：</p><pre><code class="Rust">struct Foo &#123;  a: String,  b: i32&#125;fn main() &#123;  let t = Foo &#123;    a: String::from(&quot;a&quot;),    b: 1,  &#125;;  println!(&quot;&#123;&#125;, &#123;&#125;&quot;, t.a, t.b);&#125;</code></pre><p>同样可以给结构体添加方法：</p><pre><code class="Rust">struct Foo &#123;  a: String,  b: i32&#125;impl Foo &#123;  fn test(&amp;self) -&gt; i32 &#123;    self.b + 1  &#125;&#125;fn main() &#123;  let t = Foo &#123;    a: String::from(&quot;a&quot;),    b: 1,  &#125;;  println!(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, t.a, t.b, t.test());&#125;// a, 1, 2</code></pre><h3 id="列表与模式匹配"><a href="#列表与模式匹配" class="headerlink" title="列表与模式匹配"></a>列表与模式匹配</h3><p>下面的例子创建了包含3个元素的向量，然后将第0个元素赋值给常量one。之后使用模式匹配判断列表的第0个元素是否等于one的值，如果相等则输出字符串”one”，否则为”none”。Rust的模式匹配中，Some()和None都是内置的关键字：</p><pre><code class="Rust">fn main() &#123;  let v = vec![1, 2, 3];  let one = &amp;v[0];  println!(&quot;&#123;&#125;&quot;, one);  match v.get(0) &#123;    Some(one) =&gt; println!(&quot;one&quot;),    Some(2) =&gt; println!(&quot;two&quot;),    None =&gt; println!(&quot;none&quot;),  &#125;&#125;</code></pre><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>panic函数用于抛出异常：</p><pre><code class="Rust">fn main() &#123;  panic!(&quot;new Exception&quot;);&#125;// thread &#39;main&#39; panicked at &#39;new Exception&#39;, test.rs:4:3// note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.</code></pre><p>针对错误处理，Rust提供了两个简写的方法，用于便捷的处理错误信息。unwrap()函数会自动抛出panic，如果不使用unwrap()，程序则会跳过发生panic的代码。这在某种程度上与Java的异常处理逻辑相反，因为Java如果不对异常进行处理，程序就无法继续运行。而Rust如果使用unwrap()对panic进行处理，程序将不再继续执行，同时打印出错误信息。</p><pre><code class="Rust">use std::fs::File;fn main() &#123;  let f = File::open(&quot;hello.txt&quot;);  println!(&quot;a&quot;);  let f2 = File::open(&quot;hello.txt&quot;).unwrap();  println!(&quot;b&quot;);&#125;// a// thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Os &#123; code: 2, kind: NotFound, message: &quot;系统找不到指定的文件。&quot; &#125;&#39;, src\libcore\result.rs:999:5// ...</code></pre><p>另一个简写的方法是expect()，可用于替代unwrap()。它与unwrap()的区别在于，unwrap()使用系统内置的panic信息，而expect()可以传入参数作为panic的错误信息。仅此而已。</p><pre><code class="Rust">use std::fs::File;fn main() &#123;    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);&#125;// thread &#39;main&#39; panicked at &#39;Failed to open hello.txt: ...// ...</code></pre><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Rust中的Lambda表达式使用<code>|</code>作为入参的界定符，即使用<code>||</code>来代替<code>()</code>。此外Lambda的公用和其它语言是相同的：</p><pre><code class="Rust">fn main() &#123;  let test = |num| &#123;    num == 1  &#125;;  println!(&quot;&#123;&#125;, &#123;&#125;&quot;, test(1), test(2));&#125;// true, false</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Rust的语言特性远不止此，尤其是Rust与众不同的内存管理机制，以及让Rust新手得其门不得其道的概念”ownership”，都需要我们不断前行。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Rust是复杂度和应用场景都对标C++的语言，一起学习吧！&lt;/p&gt;
&lt;p&gt;最近，我开始思考像本文这样类型的内容算什么，编程语言的教程？内容不全面；对语言的评价？够不着；学习笔记？如果是，那绝非我本意。我倾向于认为这是一个探索的过程，无论对于我自己还是对于别人，我希望可以表现</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>基于Java的爬虫框架WebCollector</title>
    <link href="https://smallyu.net/2019/08/10/%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6WebCollector/"/>
    <id>https://smallyu.net/2019/08/10/%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6WebCollector/</id>
    <published>2019-08-10T13:03:41.000Z</published>
    <updated>2024-08-03T19:07:10.089Z</updated>
    
    <content type="html"><![CDATA[<p>Long, Long Ago，网络上出现大量Python爬虫教程，各种培训班借势宣扬Python，近几年又将噱头转向人工智能。爬虫是一个可以简单也可以复杂的概念，就好比建造狗屋和建筑高楼大厦都是在搞工程。</p><p>由于工作的缘故，我需要使用WebCollector爬取一些网页上的数据。其实宏观上，爬虫无非就是访问页面文件，把需要的数据提取出来，然后把数据储存到数据库里。难点往往在于，一是目标网站的反爬策略，这是让人比较无奈的斗智斗勇的过程；二是目标网页数量大、类型多，如何制定有效的数据爬取和数据分析方案。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这是一张简略的概念图，受屏幕宽度限制，可能无法看清内容，请在新标签页打开图片，或者直接点击 <a href="/2019/08/10/%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6WebCollector/WebCollector.png">这里</a>。这张图片并不是完美的，甚至还包含不完全正确的实现方式，具体内容会在后面阐述。</p><img src="WebCollector.png" width="95%" height="100%"><p>我将目标网页分为4种类型：</p><ol><li>静态的网页文档，curl就可以加载到</li><li>需要自定义HTTP请求的页面，比如由POST请求得到的搜索结果页面，或者需要使用Cookie进行鉴权的页面</li><li>页面中包含由JavaScript生成的数据，而我们需要的正是这部分数据。由于js是加载后才执行的，就像CSS加载后由浏览器进行渲染一样，这样的数据无法直接得到</li><li>页面中包含由JavaScript生成的数据，且需要自定义HTTP请求的页面</li></ol><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>为了便于测试，在本地使用Node.js启动一个简单的服务器，用于接收请求，并返回一个页面作为响应。server.js的内容如下：</p><pre><code class="JavaScript">var http = require(&#39;http&#39;)var fs = require(&#39;fs&#39;)var server = http.createServer((req,res) =&gt; &#123;  // 返回页面内容  fs.readFile(&#39;./index.html&#39;, &#39;utf-8&#39;, (err,data) =&gt; &#123;    res.end(data);  &#125;);  // 打印请求中的Cookie信息  console.log(req.headers.cookie)&#125;)server.listen(9000) </code></pre><p>index.html的内容更加简单，只包含一个title和一个p标签：</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;This is a title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h3><p>这是一个最简版的爬虫程序，在构造方法中调用父类的有参构造方法，同时添加url到待爬取队列中。visit是消费者，每一个url请求都会进入这个方法被处理。</p><pre><code class="Java">public class StaticDocs extends BreadthCrawler &#123;    public StaticDocs(String crawlPath, boolean autoParse) &#123;        super(crawlPath, autoParse);        this.addSeed(&quot;http://127.0.0.1:9000/&quot;);    &#125;    @Override    public void visit(Page page, CrawlDatums next) &#123;        System.out.println(page.doc().title();        // This is a title    &#125;    public static void main(String[] args) throws Exception &#123;        StaticDocs crawler = new StaticDocs(&quot;crawl&quot;, true);        crawler.start(1);    &#125;&#125;</code></pre><h3 id="Cookie鉴权"><a href="#Cookie鉴权" class="headerlink" title="Cookie鉴权"></a>Cookie鉴权</h3><p>需要在header中带cookie请求同样简单，在构造方法中添加相应配置就可以，node.js的命令行会打印出cookie的内容：</p><pre><code class="Java">public CookieDocs(String crawlPath) &#123;    super(crawlPath, true);    // 设置请求插件    setRequester(new OkHttpRequester() &#123;        @Override        public Request.Builder createRequestBuilder(CrawlDatum crawlDatum) &#123;            return super.createRequestBuilder(crawlDatum)                    .header(&quot;Cookie&quot;, &quot;name=smallyu&quot;);        &#125;    &#125;);    this.addSeed(&quot;http://127.0.0.1:9000/&quot;);&#125;// name=smallyu</code></pre><h3 id="JavaScript生成的数据"><a href="#JavaScript生成的数据" class="headerlink" title="JavaScript生成的数据"></a>JavaScript生成的数据</h3><p>测试js生成数据的情况需要做一点准备，修改index.html，在body标签中加入这样几行代码：</p><pre><code class="JavaScript">&lt;div id=&quot;content&quot;&gt;1&lt;/div&gt;&lt;script&gt;  document.getElementById(&#39;content&#39;).innerHTML = &#39;2&#39;&lt;/script&gt;</code></pre><p>可以预见，请求中直接返回的div内容是1，然后js经由浏览器执行，改变div的内容为2。访问静态页面的爬虫程序只能进行到第1步，也就是直接获取请求返回的内容。修改StaticDocs.java的visit方法，打印出div的内容看一下，可以确信是1：</p><pre><code class="Java">System.out.println(page.select(&quot;div&quot;).text());// 1</code></pre><p>这是一个官方提供的Demo，用于获取js生成的数据。WebCollector依赖于Selenium，使用HtmlUnitDriver运行js：</p><pre><code class="Java">public class JsDocs &#123;    public static void main(String[] args) throws Exception &#123;        Executor executor = (CrawlDatum datum, CrawlDatums next) -&gt; &#123;            HtmlUnitDriver driver = new HtmlUnitDriver();            driver.setJavascriptEnabled(true);            driver.get(datum.url());            WebElement divEle = driver.findElement(By.id(&quot;content&quot;));            System.out.println(divEle.getText());            // 2        &#125;;        //创建一个基于伯克利DB的DBManager        DBManager manager = new RocksDBManager(&quot;crawl&quot;);        //创建一个Crawler需要有DBManager和Executor        Crawler crawler = new Crawler(manager, executor);        crawler.addSeed(&quot;http://127.0.0.1:9000/&quot;);        crawler.start(1);    &#125;&#125;</code></pre><p>如果你看过WebCollector的主页，一定可以注意到这个Demo和其他Demo的明显不同。在不需要js生成的数据时，新建的类继承自BreadthCrawler，而BreadthCrawler继承自AutoParseCrawler，AutoParseCrawler又继承自Crawler。现在获取js数据的Demo，直接跳过BreadthCrawler和AutoParseCrawler，实例化了Crawler。</p><img src="uml.png" width="50%" height="100%"><p>为什么要这样做呢？再次强调，这是官方提供的Demo。</p><h3 id="Cookie鉴权后JavaScript生成的数据"><a href="#Cookie鉴权后JavaScript生成的数据" class="headerlink" title="Cookie鉴权后JavaScript生成的数据"></a>Cookie鉴权后JavaScript生成的数据</h3><p>根据官方提供的用例，显然是无法设置cookie的，因为Crawler类并没有提供自定义Header的方法。这个自定义Header的方法继承自AutoParseCrawler类。那么如何做到既可以添加Cookie又可以使用HtmlUnitDriver？</p><p>其实结果很简单，我在看过WebCollector的代码后发现AutoParseCrawler实现了Executor接口，并且在构造方法中将this赋值给了父类的executor。也就是说，AutoParseCrawler本身就是一个Executor。下面的代码用以表示它们的关系：</p><pre><code class="Java">public class Crawler &#123;    protected Executor executor;    public Crawler(DBManager dbManager, Executor executor) &#123;        // ...    &#125;&#125;public class AutoParseCrawler extends Crawler implements Executor &#123;    public AutoParseCrawler(boolean autoParse) &#123;        // 这里的executor指向父类        this.executor = this;    &#125;&#125;</code></pre><p>new Crawler时传入一个executor，相当于直接new一个AutoParseCrawler。BreadthCrawler继承自AutoParseCrawler，所以BreadthCrawler本身也是个Executor。再看官方关于自定义Cookie的Demo，如何在其中使用HtmlUnitDriver呢？重写Executor的execute方法。</p><p>所以，在定义cookie后获取js生成的数据，使用继承BreadthCrawler的类，然后重写execute就可以。这是一个完整的Demo：</p><pre><code class="Java">/** * @author smallyu * @date 2019.08.11 12:18 */public class JsWithCookieDocs extends BreadthCrawler &#123;    public JsWithCookieDocs(String crawlPath) &#123;        super(crawlPath, true);        // 设置请求插件        setRequester(new OkHttpRequester() &#123;            @Override            public Request.Builder createRequestBuilder(CrawlDatum crawlDatum) &#123;                return super.createRequestBuilder(crawlDatum)                        .header(&quot;Cookie&quot;, &quot;name=smallyu&quot;);            &#125;        &#125;);        this.addSeed(&quot;http://127.0.0.1:9000/&quot;);    &#125;    // 直接重写execute即可    @Override    public void execute(CrawlDatum datum, CrawlDatums next) throws Exception &#123;        super.execute(datum, next);        HtmlUnitDriver driver = new HtmlUnitDriver();        driver.setJavascriptEnabled(true);        driver.get(datum.url());        WebElement divEle = driver.findElement(By.id(&quot;content&quot;));        System.out.println(divEle.getText());        // 2        // 同时，node.js的命令行中打印出cookie内容    &#125;    // 重写execute就不需要visit了    public void visit(Page page, CrawlDatums crawlDatums) &#123;&#125;    public static void main(String[] args) throws Exception &#123;        JsWithCookieDocs crawler = new JsWithCookieDocs(&quot;crawl&quot;);        crawler.start(1);    &#125;&#125;</code></pre><h3 id="外部代理"><a href="#外部代理" class="headerlink" title="外部代理"></a>外部代理</h3><p>也许还没有结束。在一开始概述的图片上，同时定义cookie以及获取js生成的数据，实现方式是内部Selenium + 外部browsermob-proxy。假设没有上述重写execute的方法（官方也确实没有提供类似的Demo），该如何实现想要的效果？一种实践是本地启动一个代理，给代理设置好cookie，然后让Selenium的WebDriver通过代理访问目标页面，就可以在带header的情况下拿到js生成的数据。这是在JsDocs.java的基础上，使用代理的完整实现：</p><pre><code class="Java">public class JsWithProxyDocs &#123;    public static void main(String[] args) throws Exception &#123;        Executor executor = (CrawlDatum datum, CrawlDatums next) -&gt; &#123;            // 启动一个代理            BrowserMobProxy proxy = new BrowserMobProxyServer();            proxy.start(0);            // 添加header            proxy.addHeader(&quot;Cookie&quot; , &quot;name=smallyu&quot;);            // 实例化代理对象            Proxy seleniumProxy = ClientUtil.createSeleniumProxy(proxy);            // 由代理对象生成capabilities            DesiredCapabilities capabilities = new DesiredCapabilities();            capabilities.setCapability(CapabilityType.PROXY, seleniumProxy);            // 内置，必须设置            capabilities.setBrowserName(&quot;htmlunit&quot;);            // 使用capabilities实例化HtmlUnitDriver            HtmlUnitDriver driver = new HtmlUnitDriver(capabilities);            driver.setJavascriptEnabled(true);            driver.get(datum.url());            WebElement divEle = driver.findElement(By.id(&quot;content&quot;));            System.out.println(divEle.getText());   // 2        &#125;;        //创建一个Crawler需要有DBManager和Executor        Crawler crawler = new Crawler(new RocksDBManager(&quot;crawl&quot;), executor);        crawler.addSeed(&quot;http://127.0.0.1:9000/&quot;);        crawler.start(1);    &#125;&#125;</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对于WebCollector我已经没有兴趣了解更多，倒是在注意到框架的包名<code>cn.edu.hfut</code>后有种豁然开朗的感觉。凌乱的代码风格，随处可见不知所以的注释，毫无设计美感的代码架构，倒也符合国内不知名大学的开源软件水平，距离工业级的框架，可能还需要N个指数倍东的时间。至于使用过程中遇到depth含义不明、线程非法结束、next.add失效等问题，就这样吧，也在情理之中，整个框架都像是赶工的结果，或者说是学生们拿来练手的项目。我在WebCollector的Github上RP了关于重写execute的问题，从开发者回复的只言片语中，我怀疑开源者自己都没有把里面的东西搞清楚 :P</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Long, Long</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>工作能力低下的表现</title>
    <link href="https://smallyu.net/2019/07/25/%E5%B7%A5%E4%BD%9C%E8%83%BD%E5%8A%9B%E4%BD%8E%E4%B8%8B%E7%9A%84%E8%A1%A8%E7%8E%B0/"/>
    <id>https://smallyu.net/2019/07/25/%E5%B7%A5%E4%BD%9C%E8%83%BD%E5%8A%9B%E4%BD%8E%E4%B8%8B%E7%9A%84%E8%A1%A8%E7%8E%B0/</id>
    <published>2019-07-24T16:05:30.000Z</published>
    <updated>2024-08-03T19:07:10.105Z</updated>
    
    <content type="html"><![CDATA[<p>现在是零点零五分左右，本来是应该睡觉的时间，却突然想写点东西。</p><ul><li><p><strong>抱怨</strong> </p><p>时时刻刻在抱怨，这个不对，那个不好，并且将不满实实在在的挂在脸上，从嘴里说出来，生怕别人不知道有意见 :)</p></li><li><p><strong>无法承受工作压力</strong></p><p>抱怨的根源是工作内容，工作量稍微多一些就会开始抱怨，活好多，我好烦，我做不完，我做不过来，我没有时间。其实只不过是正常的工作量而已，其实不用加班，其实摸鱼晒网谁都喜欢 :)</p></li><li><p><strong>情绪化</strong></p><p>面对同事提出的问题，常见做法是不予理睬，稍加严重的做法是争锋相对。最让人诧异的是，生气的原因竟然可以是“他不尊重我的劳动成果”。打工而已，劳动哪有成果 :)</p></li><li><p><strong>自我为中心</strong></p><p>正常工作中的分工合作感觉像是去政府求人办事，要在适当的时候，方便的时候，有时间的时候，心情好的时候，不然可能会看到不太好的脸色。我曾以为众生平等 :)</p></li><li><p><strong>你的错，我的错</strong></p><p>盼天盼地盼月亮盼星星，是你的错，不是我的错，这个问题需要你改，而不是需要我改，有事找你别找我，你能解决的就尽量不要让我动手 :)</p></li><li><p><strong>专业能力不足</strong></p><ul><li><p><strong>模块化能力欠缺</strong></p><p>功能组件化，模块抽象化。不懂后端架构的前端工程师不是好码农，由于缺乏对整个项目结构的思考，复用能力太差，导致需求变更带来大的工作量，大的工作量会引起第一点 :)</p></li><li><p><strong>编程能力欠缺</strong></p><p>会写代码，但不会编程。缺乏基本的计算机常识，遇到功能点显得盲目、无力，由于自身能力的限制导致工作难度增大，工作时间加长，也就是工作量增大，大的工作量会引起第一点 :)</p></li><li><p><strong>对自己认知不足</strong></p><p>会做什么，不会做什么？ :)</p></li><li><p><strong>思想上的巨人</strong></p><p>思想上的巨人，行动上的矮子。即使知道自己有欠缺，口口声声说甚至有行动作出改变，但是收效甚微。一般来说，造成这种现象的原因是，没动脑子 :)</p></li></ul></li><li><p><strong>盲目要强</strong></p><p>拒绝别人的帮助，希望别人以更加友善、符合自己能力的方式迁就合作。在意“自己”完成任务，而不是自己“完成”任务。</p></li><li><p><strong>目的不明确</strong></p><p>工作是为了什么？既然如此痛苦，为什么不换个行业？ :)</p></li><li><p><strong>……</strong></p></li></ul><p>我没有任何恶意，只是描述一些客观现象。我可怜能力不足的人，面对超出自己能力范畴的工作时会感到无助，但我也难受，和这样的人合作也许是噩梦。我会尽量避开那些我不太喜欢的点，告诫自己不要也变成那样。让自己变好，然后拥有讨厌别人的资格。现在一点零五分左右，我要睡觉了。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>时间过去了将近一个月，我似乎开始理解某些行为和现象。</p><p>事情是这样，最近，我试着使用C#开发一个简单的桌面应用程序，我的想法很简单，自定义几个快捷键，然后让快捷键代替重复多次的退格键。比如，全局热键<code>Ctrl-5</code>相当于按下退格键<code>Backspace</code>5次，<code>Ctrl-6</code>则相当于按6次。</p><p>这个想法产生于我日常敲键盘的过程，由于双手打字速度较快，类似于多线程的无序执行，经常出现拼音中字母错位的现象，然后手快又按下了空格键，就会有一长串错误的词组上屏。每次都按N次退格键是一件比较让人不爽的事情，尤其是流畅的思路被打断，感觉啪啪啪的退格键既影响了正常打字的顺畅，又有一种不得不为自己之前犯下的小错误负责任的愤恨。</p><p>原先以为只要向系统注册一组全局按键，然后模拟键盘的输入，整个过程就这么简单。然而，在实际的开发过程中，我遇到了很多困难，一开始连WPF中的Window和Form都没有区分清楚，Google到的教程提到了多种注册快捷键的方法，但是真正可用的少之又少，对于按键的模拟也只能依靠搜索引擎，因为官方文档中提到的Keys.send()之类的方法并不起作用（也许是事件等级太低）。</p><p>在能够实现基本的注册快捷键和模拟按键功能后，我遇到了新的问题。快捷键是基于<code>Ctrl</code>，在按下快捷键的同时，程序就会执行，也就是模拟<code>Backspace</code>，这个时候Ctrl键还没有松开，系统会认为我按下了<code>Ctrl-Backspace</code>，这显然不是预期的效果。然后我将Ctrl换为Alt，最终确定Shift键和Backspace组合没有冲突。但是新的问题又来了，程序模拟的按键最多触发两次，所以实际效果最多退两格，无论我循环多少次或者改变nInPints参数的值，都没有解决这个问题。</p><p>所以，我并没有在表达开发一个那样的东西很难，只是说遇到了一些我不太擅长解决的问题。也是在那个过程中，我体会到了“我好烦”、“这个好难”、“真闹心”、“没那么简单”之类的情绪。</p><p>也许，我们应该多一些理解。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;现在是零点零五分左右，本来是应该睡觉的时间，却突然想写点东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;抱怨&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;时时刻刻在抱怨，这个不对，那个不好，并且将不满实实在在的挂在脸上，从嘴里说出来，生怕别人不知道有意见</summary>
        
      
    
    
    
    
    <category term="工作" scheme="https://smallyu.net/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin：简化版的Scala</title>
    <link href="https://smallyu.net/2019/07/06/Kotlin%EF%BC%9A%E7%AE%80%E5%8C%96%E7%89%88%E7%9A%84Scala/"/>
    <id>https://smallyu.net/2019/07/06/Kotlin%EF%BC%9A%E7%AE%80%E5%8C%96%E7%89%88%E7%9A%84Scala/</id>
    <published>2019-07-06T02:18:22.000Z</published>
    <updated>2024-08-03T19:07:09.971Z</updated>
    
    <content type="html"><![CDATA[<p>行走江湖的剑客，必然要有一柄趁手的宝剑。好的程序语言就像一把好剑，重量合适，拿着舒服，挥舞起来优雅，杀伤力过关。Kotlin官方对待Kotlin和Scala的关系是，“如果你玩Scala很happy，那你就不需要Kotlin。”</p><h3 id="脚本化"><a href="#脚本化" class="headerlink" title="脚本化"></a>脚本化</h3><p>Scala执行的基本单位和Java一样是类，而Kotlin允许文件中的main方法直接运行，不需要类。Java的入口函数定义在类中：</p><pre><code class="Java">public class Java &#123;    public static void main(String[] args) &#123;&#125;&#125;</code></pre><p>Scala的入口函数定义在样本类而不是普通的类中：</p><pre><code class="Scala">object Scala &#123;  def main(args: Array[String]): Unit = &#123;&#125;&#125;</code></pre><p>Kotlin的入口函数则直接定义在.kt文件中，相应的，Kotlin的类仅相当于一种数据结构，类中无法定义入口函数：</p><pre><code class="Kotlin">fun main(args: Array&lt;String&gt;) &#123;&#125;</code></pre><h3 id="构造函数与单例模式"><a href="#构造函数与单例模式" class="headerlink" title="构造函数与单例模式"></a>构造函数与单例模式</h3><p>Kotlin的构造函数同Scala一样写在类定义处，因此也无法像Java的构造函数一样直接写入初始化代码。Kotlin中使用init代码块来执行初始化程序：</p><pre><code class="Kotlin">class Test(arg: String) &#123;    init &#123;        println(&quot;This string is $&#123;arg&#125;&quot;)    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val test = Test(&quot;smallyu&quot;)&#125;// This string is smallyu</code></pre><p>如果需要第二个构造函数，就要使用类似ES6的constructor函数，或者类似Scala的辅助构造器。这实在是丑陋的写法，相比之下Java真的友善多了。</p><pre><code class="Kotlin">class Test(arg1: String) &#123;    init &#123;        println(&quot;This string is $&#123;arg1&#125;&quot;)    &#125;    constructor(arg2: Int): this(&quot;smallyu2&quot;) &#123;        println(&quot;This int is $&#123;arg2&#125;&quot;)    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val test = Test(1)&#125;// This string is smallyu2// This int is 1</code></pre><p>Kotlin的构造函数是需要用constructor关键字定义的，默认可以省略，但如果要加权限修饰符自然就不能省了。在Kotlin中实现单例模式的思路与Java相同，让构造器私有，然后通过静态方法暴露实例：</p><pre><code class="Kotlin">class Test private constructor() &#123;    companion object Factory &#123;        fun create(): Test = Test()    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val test = Test.Factory.create()&#125;</code></pre><p>Kotlin中的object定义静态代码块，companion允许在类内部定义静态代码块，因此compaion object定义了类外部可以访问的方法create()。</p><h3 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h3><p>Kotlin另一个有趣的玩意儿是getter和setter。前端框架React或Vue实现数据双向绑定的原理即使用Object.defineProperty()定义对象的getter和setter，使得对象的变化可以实时同步到页面上。Kotlin提供了对属性getter和setter的支持：</p><pre><code class="Kotlin">var test: Int    get() &#123;        println(&quot;There is test getter&quot;)        return 2    &#125;    set(arg) &#123;        println(&quot;The setter arg is $&#123;arg&#125;&quot;)    &#125;fun main(args: Array&lt;String&gt;) &#123;    println(test)    test = 3&#125;// There is test getter// 2// The setter arg is 3</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>开始对Kotlin感兴趣是因为发现Kotlin竟然支持协程，如果Kotlin真的有语言级别的协程支持，加上运行在Jvm上的特点，以及能够开发多平台应用包括Server Side、Android、JavaScript、Native，那Kotlin无疑是异常强大的编程语言。然而事实上Kotlin的协程只是一个扩展包，甚至还需要使用编译工具来引入，对协程的支持还是Go语言独大。用于JavaScript平台也是个幌子，并没有比TypeScript好用，至于Android和Native本身也是Java的应用场景……</p><p>Kotlin提供了许多语法糖，看似可以简化程序员的代码量，但是为了熟练应用Kotlin的特性，使用者又不得不搞清楚类似data class的概念，就像Scala的case class一样。Kotlin的学术性弱于Scala，工程能力又不比Java有大的优势。Go语言虽然另辟蹊径，语言特性上有广为诟病的地方，但是看着爽，写着也爽。所以Kotlin和Scala一样，并不会有广泛的应用前景。也就是说，它并不会是下一个很流行的编程语言。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;行走江湖的剑客，必然要有一柄趁手的宝剑。好的程序语言就像一把好剑，重量合适，拿着舒服，挥舞起来优雅，杀伤力过关。Kotlin官方对待Kotlin和Scala的关系是，“如果你玩Scala很happy，那你就不需要Kotlin。”&lt;/p&gt;
&lt;h3 id=&quot;脚本化&quot;&gt;&lt;a</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript有关联数组吗？</title>
    <link href="https://smallyu.net/2019/05/18/JavaScript%E6%9C%89%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%E5%90%97%EF%BC%9F/"/>
    <id>https://smallyu.net/2019/05/18/JavaScript%E6%9C%89%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%E5%90%97%EF%BC%9F/</id>
    <published>2019-05-18T10:50:32.000Z</published>
    <updated>2024-08-03T19:07:09.971Z</updated>
    
    <content type="html"><![CDATA[<p>如果你接触过PHP，那你对关联数组一定不陌生。C或Java中数组下标都是从0开始的数值，而PHP除了数值，还可以用字符串作为数组的下标。用数值做下标的数组叫做索引数组，用字符串做下标的数组叫做关联数组，他们都是合法的数组。</p><pre><code class="PHP">&lt;?php$arr[0] = 1;        // 索引数组$arr[&quot;a&quot;] = &quot;b&quot;;    // 关联数组echo $arr[0];       // 1echo $arr[&quot;a&quot;];     // b</code></pre><p>在JavaScript中，同样可以使用字符串来作为数组的下标：</p><pre><code class="JavaScript">let arr = []arr[0] = 1arr[&#39;a&#39;] = &#39;b&#39;</code></pre><p>昨天，我和漂亮同事在使用JavaScript中用字符串做下标的数组时，遇到了令人困惑的问题。</p><h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>在Express.js框架的路由处理中，用res.json()返回数组，下标为数值的数组可以正常返回，下标使用字符串的数组却始终返回空。这是一段最简代码，可以用来描述该过程：</p><pre><code class="JavaScript">app.get(&#39;/&#39;, (req, res) =&gt; &#123;  let arr = []  arr[&#39;a&#39;] = &#39;b&#39;  console.log(arr)  // [a: &#39;b&#39;]  res.json(arr)     // []&#125;)</code></pre><p>预期返回的数组arr包含1个元素，console.log()直接在命令行打印的文本内容是<code>[a: &#39;b&#39;]</code>，和预期一致，然而如果通过页面请求路由，返回的内容是<code>[]</code>，这是匪夷所思的，也就是说res.json()把数组的内容吞掉了。</p><h3 id="探寻"><a href="#探寻" class="headerlink" title="探寻"></a>探寻</h3><p>为了寻找问题的真实原因，我在框架的中找到res.json()方法的定义：</p><pre><code class="JavaScript">res.json = function json(obj) &#123;  var val = obj;  // ...  var body = stringify(val, replacer, spaces, escape)  // ...  return this.send(body);&#125;;</code></pre><p>返回内容body经过了stringify()方法处理，stringify()方法调用的是JavaScript中JSON标准库的方法JSON.stringify()：</p><pre><code class="JavaScript">function stringify (value, replacer, spaces, escape) &#123;  var json = replacer || spaces    ? JSON.stringify(value, replacer, spaces)    : JSON.stringify(value);  // ...&#125;</code></pre><p>那么就说明，JSON.stringify()方法的返回值，会忽略用字符串做下标的数组。为了证实这一现象，用简单的Demo测试一下：</p><pre><code class="JavaScript">let arr1 = [], arr2 = []arr1[0] = 1arr2[&#39;a&#39;] = &#39;b&#39;JSON.stringify(arr1)    // &quot;[1]&quot;JSON.stringify(arr2)    // &quot;[]&quot;</code></pre><p>所以问题又来了，JavaScript标准库中的JSON.stringify()方法，为什么要忽略数组中下标为字符串的元素？是有意为之，官方不赞成使用字符串做下标，还是无奈之举，存在不可抗拒的原因无法实现？为了找到问题的根源，我试着从Chrome解析JavaScript的 <a href="https://github.com/v8/v8">V8引擎</a> 中寻找JSON.stringify()的定义。</p><p>V8引擎是用C++写的，关于JSON.stringify()的定义应该是这一段代码：</p><pre><code class="JavaScript">// ES6 section 24.3.2 JSON.stringify.BUILTIN(JsonStringify) &#123;  HandleScope scope(isolate);  JsonStringifier stringifier(isolate);  Handle&lt;Object&gt; object = args.atOrUndefined(isolate, 1);  Handle&lt;Object&gt; replacer = args.atOrUndefined(isolate, 2);  Handle&lt;Object&gt; indent = args.atOrUndefined(isolate, 3);  RETURN_RESULT_OR_FAILURE(isolate,                           stringifier.Stringify(object, replacer, indent));&#125;</code></pre><p>可以推测出，object即JSON.stringify()处理并返回的内容，返回之前使用args.atOrUndefined()方法进行包装。这里atOrUndefined()被反复调用，传入两个参数，可以理解为，第一个参数isolate保存有完整的参数信息，第二个参数是数据的索引，结合起来便是atOrUndefined()方法要处理的完整数据。</p><p>然后看atOrUndefined()的定义，在下面的代码中，tOrUndefined()调用了at()方法，at()方法又调用了Arguments的at方法：</p><pre><code class="C++">Handle&lt;Object&gt; atOrUndefined(Isolate* isolate, int index) &#123;  if (index &gt;= length()) &#123;    return isolate-&gt;factory()-&gt;undefined_value();  &#125;  return at&lt;Object&gt;(index);&#125;Handle&lt;S&gt; at(int index) &#123;  DCHECK_LT(index, length());  return Arguments::at&lt;S&gt;(index);&#125;</code></pre><p>Arguments::at()方法中，指针value获取了待处理参数的内存地址，然后使用reinterpret_cast对value的值进行类型强转。</p><pre><code class="C++">Handle&lt;S&gt; at(int index) &#123;  Object** value = &amp;((*this)[index]);  // This cast checks that the object we&#39;re accessing does indeed have the  // expected type.  S::cast(*value);  return Handle&lt;S&gt;(reinterpret_cast&lt;S**&gt;(value));&#125;</code></pre><p>到这里值就返回了，但是并没能解释为什么使用字符串做下标的数组内容会被忽略。只要是同一个数组，它的值就会保存在一段连续的地址空间中，即使reinterpret_cast处理的是指针变量，也应该无论多少都照常输出才是。</p><h3 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h3><p>最后，通过Google找到了一个关于数组使用字符串做下标的问题和答案（<a href="https://stackoverflow.com/questions/10326635/string-index-in-js-array">String index in js array</a>），我才明白为什么字符串做下标的数组如此特殊，因为JavaScript里压根就没有关联数组！</p><pre><code class="JavaScript">let arr1 = [], arr2 = []arr1[0] = 1arr2[&#39;a&#39;] = &#39;b&#39;arr1.length     // 1arr2.length     // 0</code></pre><p>给一个数组使用字符串作为下标赋值后，数组的长度不会改变，赋的值并没有作为数组元素储存到数组里。使用字符串作为下标能够正常对数组取值赋值的原因是，JavaScript将字符串作为数组的属性进行了储存。</p><pre><code class="JavaScript">let arr = []arr[&#39;a&#39;] = &#39;b&#39;arr.hasOwnProperty(&#39;a&#39;)   // true</code></pre><p>因此，JSON.stringify()处理的是数组的内容，reinterpret_cast也只是基于指针对数组内容进行类型转换，属性什么的，当然不会有输出！</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><ol><li><p>为什么console.log()可以将数组的属性也输出？对于要输出的内容，它是怎么定义的？</p></li><li><p>为什么JavaScript中<code>typeof []</code>的值是<code>&quot;object&quot;</code>，也就是数组的类型是对象，但对象的属性会被处理，而数组不会？</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;如果你接触过PHP，那你对关联数组一定不陌生。C或Java中数组下标都是从0开始的数值，而PHP除了数值，还可以用字符串作为数组的下标。用数值做下标的数组叫做索引数组，用字符串做下标的数组叫做关联数组，他们都是合法的数组。&lt;/p&gt;
&lt;pre&gt;&lt;code</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>主流编程语言的异常处理机制</title>
    <link href="https://smallyu.net/2019/04/24/%E4%B8%BB%E6%B5%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>https://smallyu.net/2019/04/24/%E4%B8%BB%E6%B5%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2019-04-24T02:19:04.000Z</published>
    <updated>2024-08-03T19:07:10.027Z</updated>
    
    <content type="html"><![CDATA[<p>学习编程语言应该从语言特性入手，而不是编程语言本身。这里尝试对各种编程语言的异常和错误处理机制做一个横向的、简单的了解。涉及到的编程语言包括C、C++、Go、Java、Scala、Kotlin、Ruby、Rust、JavaScript、PHP、Python、Lisp。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>C语言没有异常捕获机制。程序在发生错误时会设置一个错误代码errno，该变量是全局变量。C语言提供了perror()和strerror()函数来显示与errno相关的描述信息。perror()函数可以直接调用，入参是一个字符串，输出<code>入参: 错误文本</code>。strerror()函数入参是一个数字（错误码），返回一个指针，指针指向错误码对应的文本。</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;void main ()&#123;  // 打开一个不存在的文件，会发生错误  fopen (&quot;unexist.txt&quot;, &quot;rb&quot;);  // 2  printf(&quot;%d\n&quot;, errno);  // No such file or directory  perror(&quot;&quot;);  // No such file or directory  printf(&quot;%s\n&quot;, strerror(errno));&#125;</code></pre><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>C++支持异常捕获机制。C++可以抛出或捕获两种内容，一种是int或char*之类的内容，程序可以捕获并抛出，这一点和Java相比有差异，因为Java并不支持直接抛出基本类型的异常：</p><pre><code class="C">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;int main () &#123;    try    &#123;        throw &quot;error&quot;;    &#125;    catch(const char* msg)    &#123;        cout &lt;&lt; msg &lt;&lt; endl;    &#125;&#125; // error</code></pre><p>另一种内容就是类，可以是内置的标准异常类，或是自定义的异常类：</p><pre><code class="C">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;int main () &#123;    try    &#123;        throw exception();    &#125;    catch(std::exception&amp; e)    &#123;        cout &lt;&lt; e.what() &lt;&lt; endl;    &#125;&#125; // std::exception</code></pre><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go语言作为非OOP派系的编程语言，并不支持try-catch的语法，但仍然具有类似抛出和捕获的特性。Go语言有3个错误相关的关键字，panic()、recover()和defer。可以理解为，panic()函数抛出异常，recover()函数捕获异常，defer关键字定义最后也就是finally执行的内容：</p><pre><code class="Go">package mainimport &quot;fmt&quot;func main() &#123;  defer func() &#123;    err := recover()    fmt.Println(err)  &#125;()  panic(&quot;error&quot;)&#125;// error</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java是纯粹的OOP语言，仅支持对象的抛出和捕获：</p><pre><code class="Java">public class ErrorTest &#123;    public static void main(String[] args) &#123;        try &#123;            throw new Exception();        &#125; catch (Exception e) &#123;            System.out.println(e);        &#125;    &#125;&#125;// java.lang.Exception</code></pre><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><p>Scala和Java是一个流派，同样仅支持对象的抛出和捕获，除了语法上和Java稍有差异，概念上基本是一jian样rong的：</p><pre><code class="Scala">object ErrorTest &#123;  def main(args: Array[String]): Unit = &#123;    try &#123;      throw new Exception()    &#125; catch &#123;      case e: Exception =&gt; print(e)    &#125;  &#125;&#125;// java.lang.Exception</code></pre><p>另外，Scala抛出的是Java的异常，也许Scala不能算作是独立的编程语言，而是依附于Java、为Java提供语法糖的编程语言。这一点值得深入思考和探究。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Kotlin和Scala是一种性质的语言，默认抛出的同样是Java的异常：</p><pre><code class="Kotlin">fun main(args: Array&lt;String&gt;) &#123;  try &#123;    throw Exception()  &#125; catch (e: Exception) &#123;    print(e)  &#125;&#125;// java.lang.Exception</code></pre><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><p>Ruby使用关键字raise和rescue代替try和catch来实现异常的抛出和捕获。Ruby同样支持try-catch关键字，这里暂不讨论，因为我没搞清楚它的用法。</p><pre><code class="Rbuy">begin  raise &quot;error&quot;   rescue Exception =&gt; e    puts eend// error</code></pre><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>Rust没有try-catch的语法，也没有类似Go的错误处理函数，而是用对错误处理进行过包装的<code>Option&lt;T&gt;</code>或Option的加强版<code>Result&lt;T, E&gt;</code>进行错误处理。Rust的模式匹配和Scala类似：</p><pre><code class="Rust">fn main() &#123;  match find() &#123;    None =&gt; println!(&quot;none&quot;),    Some(i) =&gt; println!(&quot;&#123;&#125;&quot;, i),  &#125;&#125;fn find() -&gt; Option&lt;usize&gt; &#123;  if 1 == 1 &#123;    return Some(1);  &#125;  None&#125;// 1</code></pre><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>脚本语言在变量类型上不做强制约束，捕获时也就不能按照异常类型来做区分。抛出错误的内容还是相对自由的：</p><pre><code class="JavaScript">try &#123;  throw 1&#125; catch (e) &#123;  console.log(e)&#125;// 1try &#123;  throw new Error(&#39;&#39;)&#125; catch (e) &#123;  console.log(e)&#125;// Error</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>PHP的try-catch和Java类似，并没有特殊之处：</p><pre><code class="PHP">&lt;?php  try &#123;      throw new Exception(&quot;error&quot;);  &#125; catch (Exception $e) &#123;      echo $e-&gt;getMessage();  &#125;</code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python在语法上能找到Ruby的影子，raise触发异常，execpt捕获异常：</p><pre><code class="Python">try:  raiseexcept:  print(&quot;error&quot;)</code></pre><h3 id="Lisp"><a href="#Lisp" class="headerlink" title="Lisp"></a>Lisp</h3><p>Lisp整体较复杂，Lisp捕获处理异常的内容暂时留坑。以下是Common Lisp触发错误的情形之一，declare会声明函数入参类型，传入错误参数将引发错误：</p><pre><code class="Lisp">(defun df (a b)  (declare (double-float a b))  (* a b))  (df &quot;1&quot; 3)// *** - *: &quot;1&quot; is not a number</code></pre><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>原先想梳理这些语言的大部分异常和错误处理相关概念，然而真正开始后发现比较困难，并且之前我没能区分”exception”和”checked exception”，以致从立意到标题到内容可能都有偏差。这次就先提及”exception”，之后讨论关于”checked exception”的内容。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;学习编程语言应该从语言特性入手，而不是编程语言本身。这里尝试对各种编程语言的异常和错误处理机制做一个横向的、简单的了解。涉及到的编程语言包括C、C++、Go、Java、Scala、Kotlin、Ruby、Rust、JavaScript、PHP、Python、Lisp。&lt;/p</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>实习3.5个月之际</title>
    <link href="https://smallyu.net/2019/04/21/%E5%AE%9E%E4%B9%A03.5%E4%B8%AA%E6%9C%88%E4%B9%8B%E9%99%85/"/>
    <id>https://smallyu.net/2019/04/21/%E5%AE%9E%E4%B9%A03.5%E4%B8%AA%E6%9C%88%E4%B9%8B%E9%99%85/</id>
    <published>2019-04-21T09:47:49.000Z</published>
    <updated>2024-08-03T19:07:10.098Z</updated>
    
    <content type="html"><![CDATA[<p>想用《卧虎藏龙》里的台词来描述心情：“被一种寂灭的悲哀环绕”。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>最近实际的工作产出很少，大多时间用在了熟悉业务上。不出所料，工作中用到的技术并不会超出想象，因此可以安心地认为目前还在及格线上。倒是业务比较复杂，对没有经验的人显得不太友好。线上的交易系统，生产上的数据库字段，真真切切对应具体的业务流程和操作。毫不知情地开发一时爽，等到上线就火葬场。</p><p>有经验的程序员做事细致谨慎，也确实是给我上了一课。在学校曾有人问我一些问题，我觉得很简单，然后直截了当的解决问题。现在到工作岗位上，我就是被解决问题的那个人。我之前思考过，我的同学技术水平如何？我的技术能力是否真的高过他们？如果有好过他们的地方，是什么？有核心竞争力吗？这些问题的答案，基本上都聚焦在“经验”上。经验是无法快速获得的，我的同学不行，我也不行。</p><p>我的经验来自爱好和习惯，也许是碰巧接触互联网较早，仅此而已。王垠提到过 <a href="http://www.yinwang.org/blog-cn/2017/04/14/experience-and-insight">经验和洞察力</a> 的问题，观点精辟，值得深思。我没有所谓的洞察力，并且洞察力类似于学习能力、理解能力，是一个人综合素养的体现，无法轻易获得。没有足够的阅历，怎么能透过现象看到本质？郭德纲说的很好，让人成长的不是时间，是经历。可以理解为，时间助长经验，经历助长洞察力。</p><h3 id="人际"><a href="#人际" class="headerlink" title="人际"></a>人际</h3><p>有件事情带给我一些思考。我请假几天，但有工单提测了没有测完。我说要离开几天时，测试同事问怎么要走云云，我说过几天就回来了，他说，“我不关心这个，我关心的是我工单怎么测……”倒不是他说这句话会让人伤心，我们本就毫无交集，认识没几天，同事之间往往只有工作关系，我也是清楚的。我在意的是，他竟然可以直截了当直击要害地说出自己的需求，这是一种需要能力也需要胆量的做法。</p><p>对话发生在几秒钟的时间里，能够快速组织语言描述清楚自己的想法，是我现在不具备的能力。需要胆量的说法是指，这样的做法稍微有点不符合国人的行事风格，客套话、顾面子、话里有话、笑里藏刀，都是中华民族的传统品德。</p><h3 id="比金钱更重要的东西"><a href="#比金钱更重要的东西" class="headerlink" title="比金钱更重要的东西"></a>比金钱更重要的东西</h3><p>看到朋友圈晒工作晒起薪，各种酸。但是就目前而言，我没有丝毫寻找新机会的冲动。融洽的工作氛围，压力并不大的工作内容，能让人有成长的业务需求，现在的工作足够让我满意，除了工资。我曾经的老师个性签名是，成长比成就重要。这句话并不绝对，但有道理。对于刚参加工作的情况来说，有多少挣钱的能力比能挣到多少钱重要，能力可以持续转化为金钱，一时的金钱却无法保正能力的持续增长。</p><p>996是一种选择。罗辑思维有过一种观点，就是大脑处于空闲状态的时候，会不自觉的考虑各种人际关系，因此一些现象可以这样解释：聪明人往往易怒、情商低，是因为他们把大量时间用在了目的性较强的问题，留给大脑的空闲时间少了，也就没有太多关于人际关系的思考；某个一线互联网公司内流行冥想活动，就是坐那儿什么也不干，此时虽然没有明确的想法，但大脑会不自主的东想西想，谁对我怎么样，我对谁怎么样，等等。这也正好是修福报之余衍生出来的、可能人类本身就需要的活动。</p><p>我开玩笑的和同学说，我的公司是996，同学反问，真的？你们公司是996？我能在言语之前感受到他开心的情绪。因为他在某N线城市找了一份工作，工资不高，但除去开销，能剩下的和我差不多。抛开五险一金的额度不谈，生活质量、圈子、眼界，以及上面提到的成长空间，都是我所在乎的。我突然对单纯的薪资比较感到厌恶，不要再用某种“小气”的思维方式推测我的处境了，我们需求不同，理想不同。我对某个世界充满兴趣，会亲身去探索，麻雀怎么会知道凤凰的志向呢？</p><h3 id="获取有效信息的途径"><a href="#获取有效信息的途径" class="headerlink" title="获取有效信息的途径"></a>获取有效信息的途径</h3><p>N年前，很多人努力读书上更好的学校，为的是更好的教育资源，甚至是结识更多“高端人才”。如今，因为互联网的存在，某些各种维度的距离已经不再遥远。你想要获取的很多信息，都可以通过网络得到，而且不只是书本书面知识，还包括在某些领域长期的经验和对一些问题独特的见解。</p><p>所以我能更加信任自己的决策而不是父母或者其他长辈，因为我和他们相比，虽然有年龄和人生经历上的不足，但由于我可以利用互联网来不断获取各种信息，我对某些事情的决策可能比他们更加正确。</p><p>当然，也并非所有会上网的人，都可以有效利用互联网来获取信息。从广泛的信息网络中搜查、筛选、分析、推断出自己想要的东西，很重要。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;想用《卧虎藏龙》里的台词来描述心情：“被一种寂灭的悲哀环绕”。&lt;/p&gt;
&lt;h3 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="实习" scheme="https://smallyu.net/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>电梯楼层显示屏的设计失误</title>
    <link href="https://smallyu.net/2019/03/27/%E7%94%B5%E6%A2%AF%E6%A5%BC%E5%B1%82%E6%98%BE%E7%A4%BA%E5%B1%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%A4%B1%E8%AF%AF/"/>
    <id>https://smallyu.net/2019/03/27/%E7%94%B5%E6%A2%AF%E6%A5%BC%E5%B1%82%E6%98%BE%E7%A4%BA%E5%B1%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%A4%B1%E8%AF%AF/</id>
    <published>2019-03-27T14:29:49.000Z</published>
    <updated>2024-08-03T19:07:10.114Z</updated>
    
    <content type="html"><![CDATA[<p>每次上楼的时候都感到困惑，有一个问题我注意很久了。</p><h3 id="电梯"><a href="#电梯" class="headerlink" title="电梯"></a>电梯</h3><p>其实没什么大不了的，目前某座楼里的电梯是这样的情况。电梯从楼上到1楼的过程中，楼层显示屏会显示向下的箭头<code>↓</code>，当电梯到达1楼，电梯门已经开了，箭头仍然向下。这时不少人会认为，电梯将要向下运行，到达地下室。</p><img src="f1.png" width="50%" height="50%"><p>这种想法很正常，因为电梯存在另一个设计失误。当有人等待电梯想要从10楼到达1楼，同时正好有人乘坐电梯从1楼到达20楼，电梯会在10楼停下并开门。此时无论想到1楼的人是否上电梯，电梯都会继续向20楼行驶。在10楼会开门单纯是因为，在10楼想要到达1楼的人按下了电梯的按钮。</p><img src="f10.png" width="50%" height="50%"><p>正因为电梯向上行驶的这种行为，很容易让人推测，电梯向下行驶也会存在这样的行为。在1楼看到箭头向下，以为电梯本是要到地下室，因为按了电梯的按钮，或正好有人在这一层出电梯，门就开了。然而事实是，箭头只是保留了之前电梯运行的状态（向下），至于接下来是向上还是向下，要看第一个进入电梯的人按了哪个楼层。</p><p>并非（绝不是）所有的电梯都这样。正确的做法应该是，当电梯没有运行任务时，显示屏不显示箭头，或者显示置空（–）之类的内容。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>当一个任务执行结束（电梯运行结束），应该把任务的标志位重置到初始状态（箭头置空）。这样的逻辑在程序里很常见，不管是UI还是内存，用户不可信，GC亦不可信，手动回收大法好。今天就踩了一个坑 :(</p><p>坑很简单，一句话就能表达：循环里执行SQL语句，Statement对象没关闭。</p><p>坑虽然简单，但在生产环境上影响了正常的业务操作。DB2的默认限制为1400-，之后就会报错。开发的时候要小心，自测的时候也应该注意大量数据的情况。此类错误，希望以后不要再犯！</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;每次上楼的时候都感到困惑，有一个问题我注意很久了。&lt;/p&gt;
&lt;h3 id=&quot;电梯&quot;&gt;&lt;a href=&quot;#电梯&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="设计" scheme="https://smallyu.net/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基本语法</title>
    <link href="https://smallyu.net/2019/03/15/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://smallyu.net/2019/03/15/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2019-03-15T13:18:11.000Z</published>
    <updated>2024-08-03T19:07:09.967Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言虽然在语言设计上不被王垠看好，但它如此简洁的代码结构确实让人着迷。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>Go语言语句结尾不需要<code>;</code>。</p><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><p>使用<code>var</code>声明变量。当变量需要初始化时，可以使用赋值符号<code>:=</code>代替<code>=</code>以省略var关键字。</p><pre><code class="go">var a intvar b stringvar c int = 10var d = &quot;golang&quot;  // 编译器自动推断类型d := 10</code></pre><p>与C语言或Java不同，Go语言的类型声明在变量右侧。需要注意的是，如果程序中声明的变量未经使用，程序将无法通过编译。Go语言是一种工程化的语言，因此它的一些特性让人感觉不可理喻，但又会在实际工程中提高效益。</p><p>Go语言的变量赋值支持一些炫酷的写法，比如要交换变量x和y的值，可以使用这种违反直觉的写法：</p><pre><code class="go">x, y = y, x</code></pre><p>Go语言中使用<code>const</code>定义常量，<code>true</code>、<code>false</code>和<code>iota</code>是预定义常量。其中iota稍显特殊，iota会在每一个const关键字出现时重置为0，然后在下一次const出现前，每出现一次iota，iota的值加1。</p><pre><code class="go">const a = iota   // 0const b = iota   // 0const (  c = iota       // 0  d = iota       // 1)</code></pre><h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>声明一个元素个数为3的数组，并初始化：</p><pre><code class="go">array := [3]int&#123;0, 1, 2&#125;array[0] = 3fmt.Println(array)</code></pre><p>和其他语言一样，Go语言在声明数组后并不能改变数组的大小。所以Go语言提供了像Python一样的切片。切片可以从数组中产生，也可以使用make()函数新建。</p><pre><code class="go">array := [3]int&#123;0, 1, 2&#125;slice1 := array[:2]       // 从数组中创建slice2 := make([]int, 3)  // 直接创建fmt.Println(slice1)       // [0 1]fmt.Println(slice2)       // [0 0 0]</code></pre><p>除切片外，映射也是使用make函数创建，映射的类型全称是<code>var myMap map[string] int</code>，意为声明变量myMap，key为string，value为int。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>Go语言允许if-else语句的条件表达式不加小括号，当然加上也无妨。</p><pre><code class="go">a := 1if a == 1 &#123;  print(1)&#125; else if (a == 2) &#123;  print(2)&#125; else &#123;  print(3)&#125;</code></pre><p>选择语句的条件表达式同样不需要小括号，另外也不需要break，其他匹配项并不会执行，这一点和Scala相同。对选择语句的优化貌似已经是不约而同的做法。</p><pre><code class="go">i := 0switch i &#123;case 0:  print(0)case 1:  print(1)&#125;</code></pre><p>循环结构的条件表达式依然不需要小括号。Go语言只支持for循环。同时对无限循环的场景也做了优化，不再需要for(;;)的写法。</p><pre><code class="go">for &#123;  print(1)&#125;</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Go语言诞生自C语言的派系，因此Go语言从一开始就不是OOP或FP的语言，没有类、对象等概念。函数是程序中的一等公民。和C语言相同，（main包下的）main函数是整个程序的入口。</p><pre><code class="go">func add(a int, b int) (int, int) &#123;  return a + b, a - b&#125;func main() &#123;  x, y := add(1, 2)  print(x, y)&#125;</code></pre><p>Go语言的语句简洁高效，函数名后的第一个括号为入参，第二个括号是出参。函数支持多返回值。如果参数类型相同，可以将类型声明合并到一起，如<code>(a, b int)</code>。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>刚才提到Go语言没有类、对象等概念，但是Go语言有类似C语言的结构体，并且能力强大。这里定义一个Person结构体，包含两个属性name和age，并为Person添加一个方法getInfo，用于输出Person对象的信息：</p><pre><code class="go">type Person struct &#123;  name string  age int&#125;func (p Person) getInfo() &#123;  print(p.name, p.age)&#125;func main() &#123;  smallyu := new(Person)  smallyu.name = &quot;smallyu&quot;  smallyu.age = 1  smallyu.getInfo()&#125;</code></pre><p>用OOP的思想理解这样的程序并不违和。除了结构体，Go语言还保留有指针的概念。Java程序员对指针可能稍感陌生，关于指针在结构体方法中的应用，可以通过一个简单的例子来了解：</p><pre><code class="go">type Person struct &#123;  name string&#125;func (p Person) setName() &#123;  p.name = &quot;set name&quot;&#125;func (p *Person) setName2() &#123;  p.name = &quot;set name&quot;&#125;func main() &#123;  smallyu := &amp;Person&#123;&quot;smallyu&quot;&#125;  smallyu.setName()  fmt.Println(smallyu)        // &amp;&#123;smallyu&#125;  bigyu := &amp;Person&#123;&quot;bigyu&quot;&#125;  bigyu.setName2()  fmt.Println(bigyu)          // &amp;&#123;set name&#125;&#125;</code></pre><p>使用值类型定义的结构体方法，入参为形参；使用引用类型定义的结构体方法，入参为实参。<code>&amp;&#123;&#125;</code>是初始化对象的方法之一，等同于<code>new()</code>。</p><h3 id="匿名结合"><a href="#匿名结合" class="headerlink" title="匿名结合"></a>匿名结合</h3><p>Go语言中匿名结合的概念，相当于OOP语言的继承。一个结构体可以继承另一个结构体的属性和方法，大致是这样。</p><pre><code class="go">type Father struct &#123;  name string&#125;func (f Father) getName() &#123;  print(f.name)&#125;type Son struct &#123;  Father&#125;func main() &#123;  smallyu := &amp;Son&#123;&#125;  smallyu.name = &quot;smallyu&quot;  smallyu.getName()       // smallyu&#125;</code></pre><p>Son并没有定义name属性，也没有定义getName()方法，它们均继承自Father。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>Go语言的接口是非侵入式的，结构体只要实现了接口中的所有方法，程序就会认为结构体实现了该接口。</p><pre><code class="go">type IPerson interface &#123;  getName()&#125;type Person struct &#123;  name string&#125;func (p Person) getName() &#123;  print(p.name)&#125;func main() &#123;  var smallyu IPerson = &amp;Person&#123;&quot;smallyu&quot;&#125;  smallyu.getName()&#125;</code></pre><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>使用协程的关键字是<code>go</code>，从命名就能看出协程对于Go语言的重要性、协程是轻量级的线程，启动一个协程非常简单：</p><pre><code class="go">func f(msg string) &#123;  println(msg)&#125;func main() &#123;  f(&quot;直接调用方法&quot;)  go f(&quot;协程调用方法&quot;)&#125;</code></pre><p>运行程序，你会发现程序只打印出”直接调用方法”几个字。这种情况是不是似曾相识？go启用了另一个”线程”来打印消息，而main线程早已结束。在程序末尾加上<code>fmt.Scanln()</code>阻止main线程的结束，就能看到全部的打印内容。</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>通道即协程之间相互通信的通道。</p><pre><code class="go">func main() &#123;  message := make(chan string)  go func() &#123;    message &lt;- &quot;ping&quot;  &#125;()  msg := &lt;-message  println(msg)&#125;</code></pre><p>make函数返回一个chan string类型的通道，在匿名函数中将字符串”ping”传入通道，之后将通道中的数据输出到变量msg，最后打印出msg的值为”ping”。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Go语言在错误处理部分有两个函数较为常用，panic函数和defer函数。panic函数会打印错误消息，并终止整个程序的执行，类似Java的Throw Exception；defer函数会在当前上下文环境执行结束前再执行，类似try catch后的finally；panic函数虽然会终止整个程序，但不会终止defer函数的执行，可以将defer函数用于打印日志。这是一个简单的例子：</p><pre><code class="go">func main() &#123;  println(&quot;beginning&quot;)  defer func() &#123;    println(&quot;defer&quot;)  &#125; ()  println(&quot;middle&quot;)  panic(&quot;panic&quot;)  println(&quot;ending&quot;)&#125;</code></pre><p>来分析一下程序的执行结果。首先beginning被打印；然后遇到defer，暂不打印；middle在defer之前被打印；遇到panic，程序将终止，打印defer和panic。</p><p>这里要注意，defer是在程序结束前执行，而不是在其他语句结束后执行，这是有区别的。就像这里，panic函数引起了当前程序的结束，所以defer会在panic函数前执行，而不是panic后。程序的执行结果如下：</p><pre><code class="Go">beginningmiddledeferpanic: panicgoroutine 1 [running]:main.main()    D:/go/src/awesomeProject/main.go:12 +0x7f</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除此之外Go语言还有很多语言特性，也提供了非常多实用的工具包。Go语言是一种值得我们尝试去使用的语言。关于协程和通道，后续会单独探讨这一重要特性。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p>《Go语言编程》</p></li><li><p><a href="https://gobyexample.com/">Go by Example</a></p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Go语言虽然在语言设计上不被王垠看好，但它如此简洁的代码结构确实让人着迷。&lt;/p&gt;
&lt;h3 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>实习0.5个月复盘</title>
    <link href="https://smallyu.net/2019/01/25/%E5%AE%9E%E4%B9%A00.5%E4%B8%AA%E6%9C%88%E5%A4%8D%E7%9B%98/"/>
    <id>https://smallyu.net/2019/01/25/%E5%AE%9E%E4%B9%A00.5%E4%B8%AA%E6%9C%88%E5%A4%8D%E7%9B%98/</id>
    <published>2019-01-25T13:28:28.000Z</published>
    <updated>2024-08-03T19:07:10.098Z</updated>
    
    <content type="html"><![CDATA[<p>0.5个月，2个星期，共经手2个工单。</p><h3 id="第1个工单"><a href="#第1个工单" class="headerlink" title="第1个工单"></a>第1个工单</h3><p>第1个工单内容较简单，需求为原先某字段为空时不允许记录重复写入，变更为允许。解决方式也简单，判断字段为空时不做重复校验，一律通过就行。刚开始主要还是熟悉开发流程。</p><ol><li>确认需求，OA出工单；</li><li>新建分支，进行开发；</li><li>自测；</li><li>代码评审；</li><li>提测；</li><li>收到测试报告，申请上线；</li><li>上线完成，代码合并基线。</li></ol><p>事实上沟通有一定成本，其他较复杂的需求可能沟通成本会更高。</p><h3 id="第2个工单"><a href="#第2个工单" class="headerlink" title="第2个工单"></a>第2个工单</h3><p>第2个工单需求为修复平台漏洞，1个SQL注入的漏洞，1个反射型XSS攻击的漏洞。解决思路也是常规。</p><p>代码评审后改正的第1个问题，也是带给我的第1个教训是，程序里if-else不可以嵌套过多。修复SQL注入漏洞需要对多个参数做校验，我一开始的做法是：</p><pre><code class="Java">if (param1) &#123;&#125; else if (param2) &#123;&#125; else &#123;&#125;</code></pre><p>这样的做法太糟糕了！而且明显是规范里不推荐的写法。经导师提醒，将代码改为扩展性更好的这种写法：</p><pre><code class="Java">Map&lt;String, String&gt; paramMap = new ConcurrentHashMap&lt;&gt;();map.put(param1);map.put(param2);if (map) &#123;&#125;</code></pre><p>乍一看没有问题，然而这段代码有bug潜伏，第2个给我带来教训的正是这里。ConcurrentHashMap不允许传入null！和HashMap相比，有非常大的NPE风险，因为这里传入的参数来自页面（或者参数传入时就应该做非空校验？）。生产环境的代码不允许差错。</p><p>第3个教训关于配置文件。程序的配置文件，应该达到的效果是，没有这几行配置，程序就像没上线的版本一样，所更改添加的功能都依赖这个配置文件。当然同时也就要求，程序在没有添加配置时做出相应的默认处理。我自然是没能提前考虑到，配置不存在，直接NPE。</p><p>第4个教训是，画蛇添足。程序前一天晚上上线，第二天早上8点接到异常报告，上班之后马上回滚。产生异常的原因是，我改了需求之外部分的代码。上下两个一模一样的方法，看到上面的方法加上参数校验了，虽然需求里面没写，也索性给下面那个方法加上参数校验吧。然后NPE。因为在需求之外，自测没测出来，代码评审没看出来，提测没测出来，上线就出来了。</p><p>程序回滚的损失大概就是，线上系统一晚上的异常，涉及到的各部分人员再走一次工单流程，去修复bug。就两行代码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>要对代码负责，从需求到上线。</li><li>积极处理其他事情，反应要快，沟通要顺畅，注意力要集中。</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;0.5个月，2个星期，共经手2个工单。&lt;/p&gt;
&lt;h3 id=&quot;第1个工单&quot;&gt;&lt;a href=&quot;#第1个工单&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="实习" scheme="https://smallyu.net/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>北京，北京</title>
    <link href="https://smallyu.net/2019/01/06/%E5%8C%97%E4%BA%AC%EF%BC%8C%E5%8C%97%E4%BA%AC/"/>
    <id>https://smallyu.net/2019/01/06/%E5%8C%97%E4%BA%AC%EF%BC%8C%E5%8C%97%E4%BA%AC/</id>
    <published>2019-01-06T12:06:19.000Z</published>
    <updated>2024-08-03T19:07:10.032Z</updated>
    
    <content type="html"><![CDATA[<p>初到北京，有很多新奇体验。这也意味着，真正的独立生活，开始了。</p><h3 id="租房"><a href="#租房" class="headerlink" title="租房"></a>租房</h3><p>半个多月前着手看房子，当时对这汪深水知之甚少。市面上的房子大概分三类：中介、公寓和房东直租。</p><p>多数人建议租房子不要找中介，并且各大网站如58同城大量充斥的信息源均来自中介。亲身确认像蘑菇租房、贝壳找房之类的APP确实中介居多。中介除了要一个或半个月房租的中介费外，在退房时也会有各种理由克扣押金。中介说了，不扣点押金回去是要挨骂的。中介在租房过程中扮演介绍人的角色，最后合同还是要和房东签。所以在签合同的环节也有机可趁，要注意房东是不是真房东，有可能是二房东或中介。</p><p>公寓和中介类似，不过算是“正规”中介，像8090公寓、自如、蛋壳，没有中介费，有年租8 ~ 10%的服务费（相当一个月房租），算下来也不比小中介花的少。不过品牌公寓的房子大多统一装修，不算好，但能保证在合格线上。就收费来说，中介多收一个月房租的中介费或服务费，加上押金也大概率是退不到手的，三个月就相当于交五个月房租，假设2000&#x2F;月，则实际是3333&#x2F;月，已经远超预期。</p><p>房东直租推荐<code>合租找室友</code>小程序，豆瓣小组也有，听说住多多APP也可以，房源不算多，但真实。</p><p>运气比较好，联系到一个很nice的央财研究生小姐姐，前两个月房子算是转租给我，没有押金，没有其他费用，房东是北师大的老师，可信度较高，不会乱收一些杂七杂八的费用，合租的其他人，有北师大的研究生，之前还有北大的……总之环境不错，性价比高（感激小姐姐</p><img src="huaban.jpg" width="50%" height="50%"><p>住进来后注意到缺一些生活必需品，才开始有独自一人生活的感觉，好在附近的超市非常方便，这是北京啊。</p><h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><p>北京的物价没有想象中可怕，楼下的小饭馆大概一顿饭￥15 ~ 20，已经不算贵，毕竟我们十八线小县城的盖饭还要￥10 ~ 12，在太原也要￥12 ~ 16。</p><img src="jituifan.jpg" width="50%" height="50%"><h3 id="出行"><a href="#出行" class="headerlink" title="出行"></a>出行</h3><p>任何地铁站都可以办理市政交通一卡通。太原的交通卡办理点，每天6点30准时下班，一分不多呆，办理交通卡需要身份证，只能用银行卡刷POS机，整个办理过程在10分钟以上；北京的一卡通就容易多了，7点30左右去的时候当然还是有人在的，小姐姐说话也客气，我没带太多现金，把一堆零钱递过去，不到1分钟就把卡拿出来了，没有各种繁琐的步骤。</p><p>刚拿到卡，好奇地铁是怎么坐的，该什么时候刷卡交钱，跟着别人从入口刷卡进去了。看了半天，乘坐地铁的人直接上车，也没有刷卡，下车的人也就下来了。怎么回事呢（哈）然后出站时刷卡发现少了3块钱。</p><img src="ditie.jpg" width="50%" height="50%"><p>每次出门都要提醒自己钥匙、眼镜、钱必带，也再次加深了独自生活的感觉。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>刚来的第一天住100&#x2F;天的宾馆，环境那个差。租房时也看过便宜一点的合住房，环境没比100块的宾馆好多少，而且合住的麻烦之处在于，如果其中一个人突然不住了，该怎么办呢。</p><p>正好有同学在帝都培训几天，通了电话，可能没有机会出去，不过也挺好的，不至于特别落寞。像我这样的人啊，一个人挺好的。</p><img src="jiejing.jpg" width="50%" height="50%"><h3 id="2019计划"><a href="#2019计划" class="headerlink" title="2019计划"></a>2019计划</h3><p>年初计划里把某件事情放到了重要位置。当时想到大概三个途径，显然其中一个几乎已经失败了，这就是现实。不过在变动中不断调整规划生活，不也正是生活的乐趣之一么。</p><h3 id="次日"><a href="#次日" class="headerlink" title="次日"></a>次日</h3><p>入职前一天还是出去了，先到王府井落脚看了看小吃街，然后在天安门附近逛逛，各个景点周一闭馆，无奈去中山公园转了一圈，3块钱的门票（笑哭</p><img src="zhongshangongyuan.jpg" width="50%" height="50%"><p>公园出来再次回到王府井，灯光下的小吃街算是很美。</p><img src="meishijie.jpg" width="50%" height="50%"><p>在北京这个陌生的环境，能机缘巧合下有这样的机会，让我有些特殊的心情，或许和人一起就开心，或许看到认识的人就不慌，恍惚间感觉自己不是孤身一人，生活还有很多希望，它给我的2019开了个好头。该感谢上天呢，还是该感谢……</p><img src="liangren.jpg" width="50%" height="50%">]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;初到北京，有很多新奇体验。这也意味着，真正的独立生活，开始了。&lt;/p&gt;
&lt;h3 id=&quot;租房&quot;&gt;&lt;a href=&quot;#租房&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="梦想" scheme="https://smallyu.net/tags/%E6%A2%A6%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Scala语法基础</title>
    <link href="https://smallyu.net/2018/12/17/Scala%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://smallyu.net/2018/12/17/Scala%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2018-12-17T03:06:03.000Z</published>
    <updated>2024-08-03T19:07:09.973Z</updated>
    
    <content type="html"><![CDATA[<p>Scala语法较复杂，参考软件的增量开发，学习一门编程语言也应先找到一种能够驾驭的表达方式，之后再逐步添枝加叶。Scala同时支持面向对象和函数式编程，是其语法复杂的原因之一。一些教程非常全面，但也因为全面，导致难以抽丝剥茧，抓住主干。</p><p>以下内容关注最简单的基础语法，希望根据这些内容，可以尝试编写面向对象风格的Scala代码。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>Scala允许语句结尾不加<code>;</code>，这一点类似JavaScript。</p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>val定义不可变变量（常量），var定义可变变量：</p><pre><code class="Scala">val msg1 = &quot;Hello World&quot;var msg2 = &quot;Hello Wrold&quot;val msg3: String = &quot;Hello World&quot;</code></pre><p>定义变量时，类型声明在变量右侧，而且是可选的，可以不声明，编译器会自动推断。Scala中的基本类型包括：</p><blockquote><p>Byte、Short、Int、Long、Char、String、Float、Double、Boolean</p></blockquote><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数即方法，下面是定义函数的例子：</p><pre><code class="Scala">def max(x: Int, y: Int): Int = &#123;  if (x &gt; y) &#123;    return x  &#125; else &#123;     return y  &#125;&#125;</code></pre><p>与Java中方法定义的显著区别有三处：一是使用def关键字定义函数；二是类型声明在变量右侧，上文已提及；三是函数声明和函数体中间使用<code>=</code>连接。</p><p>注意函数声明的参数必须明确定义类型，编译器无法自动推断入参类型。返回类型则是可选的，除非函数使用了递归。另外，return关键字也是可选的，如果没有显式的返回语句，程序会将最后一次运算结果作为返回。</p><p>当然if后是单个语句也可以不使用大括号，因此该函数还可以这样描述：</p><pre><code class="Scala">def max2(x: Int, y: Int) = if (x &gt; y) x else y</code></pre><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>上面的示例已经用到了if语句，Scala的if语句并无特殊之处，不过与其他语言相比，Scala用模式匹配的概念代替传统的switch结构：</p><pre><code class="Scala">val a = 1a match &#123;  case 1 =&gt; println(1)  case 2 =&gt; println(2)  case _ =&gt;&#125;</code></pre><p><code>_</code>通配符匹配所有值，用于捕获默认情况。匹配表达式中，备选项永远不会掉到下一个case，因此不需要break或return。（如果将_放到首句，程序不会继续向下执行）。但是要小心，如果程序没有匹配到选项，会抛出MatchError。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>while循环并不是Scala推荐的代码风格：</p><pre><code class="Scala">var i = 0while (i &lt; 5) &#123;  println(i)  i += 1&#125;</code></pre><p>似乎并没有难以理解的地方，这就是典型的while循环。与指令式语言相比，Scala没有<code>++</code>运算符，只能使用<code>i += 1</code>这样的语句。</p><p>提起while，就一定会想到for。Scala中的for循环与指令式语言有一些差异，简单的示例如下，程序会从0打印直到5（不包括5）。</p><pre><code class="Scala">for (i &lt;- 0 until 5) &#123;  println(i)&#125;</code></pre><p>Scala不推荐while循环，而更倾向于函数式的编程风格，用于遍历的foreach方法就是其一：</p><pre><code class="Scala">&quot;abc&quot;.foreach(c =&gt; println(c))</code></pre><p>程序会依次换行打印出a b c三个字符。如果函数体只有一行语句并只有一个参数，这行代码还可以更简洁：</p><pre><code class="Scala">&quot;abc&quot;.foreach(println)</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Scala的数组并不在语言层面实现，可以实例化Array类来使用。相应的，数组下标使用小括号（也就是方法参数）表示：</p><pre><code class="Scala">val greet  = new Array[String](3)greet(0) = &quot;a&quot;greet(1) = &quot;b&quot;greet(2) = &quot;c&quot;greet.foreach(println)</code></pre><p>实例化对象时，也可以直接传入默认参数。Array确实只是一个普通的类，下面的书写方式并没有黑魔法，只是用到了样本类。关于样本类，后文有提及。</p><pre><code class="Scala">val greet2 = Array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)greet2.foreach(println)</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类使用class关键字定义，类中也包含字段和方法，即典型的面向对象。与Python不同，Scala仍然支持权限控制：</p><pre><code class="Scala">class Accumulator &#123;  private var sum = 0  def add(b: Byte): Unit = &#123;    sum += b    println(sum)  &#125;&#125;</code></pre><h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>单例对象（Singleton对象）相当于Java中的静态类，使用object替代class关键字定义。单例对象由程序共享，可直接调用。单例对象可以作为程序入口，即将main方法定义在单例对象中。下面的程序从上面定义的Accumulator类中实例化出对象c，并调用其add方法，最终程序打印1：</p><pre><code class="Scala">object Run &#123;  def main(args: Array[String]): Unit = &#123;    val a = new Accumulator    a.add(1)  &#125;&#125;</code></pre><p>在同一源文件中，当单例对象和类同名时，称单例对象为类的伴生对象，类为单例对象的伴生类。类可以访问其伴生对象的私有属性和方法。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>Scala中构造方法的规则比Java要严格。Scala通过类参数的概念来实现构造方法：</p><pre><code class="Scala">class Accumulator(a: Int, b: Int)</code></pre><p>如果类没有主体，大括号是可以省略的。实例化这个类时，就需要传入参数。在Java中的构造方法重载，对应Scala中的辅助构造器，它看起来像这样：</p><pre><code class="Scala">class Accumulator(a: Int, b: Int) &#123;  def this(c: Int) = this(c, 1)&#125;</code></pre><p>这时类拥有两个构造方法：</p><pre><code class="Scala">val a1 = new Accumulator(1)val a2 = new Accumulator(1, 2)</code></pre><p>Scala构造器的严格之处就在于，第二个构造器只能借助第一个或超类的构造器。</p><h3 id="继承与重写"><a href="#继承与重写" class="headerlink" title="继承与重写"></a>继承与重写</h3><p>Scala的继承与Java没有明显差异，只是方法重写必须要使用override关键字：</p><pre><code class="Scala">class A(a: Int) &#123;  def test = println(&quot;a&quot;)&#125;class B(b: Int) extends A(b) &#123;  override def test = println(&quot;b&quot;)&#125;</code></pre><h3 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h3><p>特质（trait）和单例对象相像，除了定义时使用的关键字不同，其余和普通的类一样，可以包含字段和方法。特质的意义在于，支持混入（Mixins），并且允许混入多个特质。这一特性经常和多重继承进行对比。</p><pre><code class="Scala">trait A &#123;  def aMethod = println(&quot;A&quot;)&#125;trait B &#123;  def bMethod = println(&quot;B&quot;)&#125;class C extends A with B</code></pre><p>这样C的实例就可以调用aMethod和bMethod：</p><pre><code class="Scala">val c = new Cc.aMethodc.bMethod</code></pre><h3 id="样本类"><a href="#样本类" class="headerlink" title="样本类"></a>样本类</h3><p>样本类的定义要在class前加case关键字，即类在定义时用case修饰。这种修饰可以让Scala编译器自动为类添加一些便捷设定：1. 实例化可以省略new关键字；2. 自动将参数作为类字段；3. 自动为类添加toString、hashCode和equals：</p><pre><code class="Scala">case class A(a: Int) &#123;  def aMethod = println(a)&#125;object Run &#123;  def main(args: Array[String]): Unit = &#123;    val a = A(1)    a.aMethod     // 1    println(a)    // A(1)    println(a.a)  // 1  &#125;&#125;</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>与Java相比，Scala支持抽象类，但不支持接口，抽象类使用abstract定义，接口则由特质代替。Scala同样支持泛型、注解等语法。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>以上内容并不全面，也许并不够用。使用一种编程语言，除了掌握它的基本语法外，还要熟悉它的惯用写法，尤其像Scala这种多范式的编程语言。之后会持续修改完善此篇内容，也将继续讨论Scala的其他语言特性。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Scala语法较复杂，参考软件的增量开发，学习一门编程语言也应先找到一种能够驾驭的表达方式，之后再逐步添枝加叶。Scala同时支持面向对象和函数式编程，是其语法复杂的原因之一。一些教程非常全面，但也因为全面，导致难以抽丝剥茧，抓住主干。&lt;/p&gt;
&lt;p&gt;以下内容关注最简单的基</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>用Scala改写Java浅度实践</title>
    <link href="https://smallyu.net/2018/12/14/%E7%94%A8Scala%E6%94%B9%E5%86%99Java%E6%B5%85%E5%BA%A6%E5%AE%9E%E8%B7%B5/"/>
    <id>https://smallyu.net/2018/12/14/%E7%94%A8Scala%E6%94%B9%E5%86%99Java%E6%B5%85%E5%BA%A6%E5%AE%9E%E8%B7%B5/</id>
    <published>2018-12-14T04:36:36.000Z</published>
    <updated>2025-04-26T16:35:07.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>想要用Java实现Markdown解析器，目前只完成了多级标题的解析。其实也就是正则匹配之后替换掉相应内容，程序暂时比较简单，大致流程如下：</p><img src="mainProcess.png" width="80%"><h3 id="改写"><a href="#改写" class="headerlink" title="改写"></a>改写</h3><p>按照同样的流程，用Scala来实现该功能，之后也将使用Scala继续完成开发。首先读取文件内容，IO操作参考《Scala Cookbook》，只需一行代码即可：</p><pre><code class="scala">var srcLines = Source.fromFile(srcFile).getLines().toList</code></pre><p>与冗长的Java相比，Scala确实精简了不少。这是之前使用Java读取文件封装的方法：</p><pre><code class="java">/**  * 读取文件内容  *  * @param src 读取文件路径  * @return 读取文件内容  */private static String readFile(String src) throws IOException &#123;    StringBuffer content = new StringBuffer();    InputStream is = null;    BufferedReader reader = null;    is = new FileInputStream(src);    reader = new BufferedReader(new InputStreamReader(is));    String line = reader.readLine();    while (line != null) &#123;        content.append(line);        content.append(&quot;\n&quot;);        line = reader.readLine();    &#125;    if (reader != null) &#123;        reader.close();    &#125;    if (is != null) &#123;        is.close();    &#125;    return content.toString();&#125;</code></pre><p>至于Scala版本将字符串改为列表操作的原因在于，Scala和Java在使用正则匹配替换的API上有差异。Java使用Matcher对象进行迭代，Matcher对象拥有查找、替换等方法：</p><img src="replaceProcess.png" width="80%"><p>而Scala的Regex对象虽然拥有findAllMatchIn、replaceAllIn等方法，但在find中的对象仅用于查找，replace方法中又无法定位匹配项的内容。因此在Scala中，将文件读入列表，使用如下方式带索引遍历文本内容：</p><pre><code class="scala">List.range(0, srcLines.size).foreach(index =&gt; &#123;  srcLines = srcLines.updated(index, regexReplace)&#125;)</code></pre><p>无论是否含有匹配项，循环内都对列表执行一次updated，更新原内容为正则替换后的内容。这样做可能稍微欠妥，关于性能问题将持续关注并整改。可以看到的是，Scala的程序思想与Java典型的OOP确实存在些许差异。</p><p>最后关于文件写入，SDK中没有提供专门的操作对象，可使用JDK中的PrintWriter：</p><pre><code class="scala">val pw = new PrintWriter(new File(outFile))pw.write(outString)pw.close()</code></pre><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>“Scala是一门会伴随开发者成长的语言”，我将用它完成我的毕业设计。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Python获取海贼王更新信息</title>
    <link href="https://smallyu.net/2018/12/02/Python%E8%8E%B7%E5%8F%96%E6%B5%B7%E8%B4%BC%E7%8E%8B%E6%9B%B4%E6%96%B0%E4%BF%A1%E6%81%AF/"/>
    <id>https://smallyu.net/2018/12/02/Python%E8%8E%B7%E5%8F%96%E6%B5%B7%E8%B4%BC%E7%8E%8B%E6%9B%B4%E6%96%B0%E4%BF%A1%E6%81%AF/</id>
    <published>2018-12-02T10:08:00.000Z</published>
    <updated>2025-04-26T15:19:33.485Z</updated>
    
    <content type="html"><![CDATA[<p>12月2日，晴，海贼王停更。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>做为一个合格的肥宅，海贼王和妖精的尾巴每周必追。这两部动漫播放源都在爱奇艺，都是VIP内容。每周末看动漫，都要在YouTube或其它网站上找资源。问题是，资源网站的更新往往不及时，常常需要Google“动漫名称 + 最新集数”，比如“海贼王 864”。</p><p>每个星期都精确的记住一部动漫应该更新的最新一集集数是多少，恐怕不是正常肥宅会做的事情，况且两部。这样，每次搜索资源前，都需要进入爱奇艺，搜索海贼王，看到最新的一集集数，关闭页面，进入Google搜索。妖精的尾巴也要同样的操作来一次。</p><p>而且，在爱奇艺里看到最新一集集数的瞬间，无法判断它是否停更，还需要在复杂的PC页面中找到“更新时间”这一标签，看更新状态是否正常，才可以做出判断。至于手机页面或APP，更是没有途径可以查看动漫的更新状态。</p><p>另一个获取动漫最新集数的方式是，百度直接搜索动漫名称，首页就倒序显示最新几集的列表（这一点百度好于谷歌），但也无法判断更新是否正常。再者，浏览器默认为Google，百度搜索需要先输入baidu，按TAB切换至百度搜索引擎，再输入要搜索的内容敲回车，步骤同样繁琐。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>写一段简单的Python脚本，从爱奇艺页面上抓取信息，自己直接访问程序便能知晓动漫的更新情况。引入工具包：</p><pre><code class="python">import urllib.requestfrom bs4 import BeautifulSoupfrom wsgiref.simple_server import make_server# 海贼王页面链接url = &quot;http://www.iqiyi.com/a_19rrhb3xvl.html?vfm=2008_aldbd&quot;</code></pre><p>urllib用于发送http请求，并接收页面数据；bs4用于解析页面，更轻易获取内容；wsgiref用于建立http服务器，提供网络服务。url是全局变量，储存海贼王页面的链接地址。</p><pre><code class="python"># 从页面获取数据def reciveData(url):  # 获取页面内容  response = urllib.request.urlopen(url)  html = response.read()  # 解析器  soup = BeautifulSoup(html, &quot;html.parser&quot;, from_encoding=&quot;utf-8&quot;)  # 更新时间  p = soup.find(&#39;p&#39;, class_=&quot;episodeIntro-update&quot;)  # 最新集数  i = soup.find(&#39;i&#39;, class_=&quot;title-update-num&quot;)  return p, i</code></pre><p>这几行代码发送了请求，并从页面中获取信息。这里更新时间和最新一集集数的信息就已经拿到了。接着要创建一个http服务器，让程序输出内容到页面：</p><pre><code class="python"># 服务器环境的处理函数def application(environ, start_response):  # 获取数据  p, i = reciveData(url)  # 拼接出页面内容  start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])  content = (&#39;&lt;h3&gt;海贼王&lt;/h3&gt;&#39;            + &#39;msg: &#39; + p.contents[2].get_text().strip()             + &#39;&lt;br&gt;&#39;            + &#39;num: &#39; + i.get_text())  return [bytes(content, encoding = &quot;utf-8&quot;)]</code></pre><p>最后启动一个本地服务器，访问8010端口即可看到页面。可将程序部署到服务器，之后直接访问服务器：</p><pre><code class="python"># 启动服务器httpd = make_server(&#39;&#39;, 8010, application) httpd.serve_forever()</code></pre><p>运行结果如图：</p><img src="preview.png" width="30%"><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>从这一想法出发，可以扩展程序。一种是从各大网站获取全面的动漫更新信息，主动提供服务；再一种是根据用户的输入，提供自定义的动漫更新信息；或者将两者结合，提供一种大而全的、可收藏、可定制的服务。虽然这种想法毫无意义。</p><h3 id="更正"><a href="#更正" class="headerlink" title="更正"></a>更正</h3><p>之前的代码犯了一个低级错误，程序只会在首次运行时发起网络请求，之后由于网络服务一直处于启动状态，返回网页的内容始终都是初始数据。解决这个问题也很容易，将请求网络的操作封装到一个函数中，再到application函数中调用该函数即可。（代码已更正，为保证简洁，去掉了妖尾部分的代码和控制台的日志输出）</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;12月2日，晴，海贼王停更。&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>为什么习惯说“是”而不是“对”</title>
    <link href="https://smallyu.net/2018/11/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B9%A0%E6%83%AF%E8%AF%B4%E6%98%AF%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9/"/>
    <id>https://smallyu.net/2018/11/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B9%A0%E6%83%AF%E8%AF%B4%E6%98%AF%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9/</id>
    <published>2018-11-28T00:45:14.000Z</published>
    <updated>2024-08-03T19:07:10.026Z</updated>
    
    <content type="html"><![CDATA[<p>原因在于，“对”含有较多评判性的意味，“是”相对弱一些。我们从小接受的教育，对错太鲜明，对即1，错即0，全对即100，全错即0。当对话的两者没有明显的上下级关系、师从关系，可能将“对”用作口头禅会引起别人的小小不满，尽管这种不满不会表现出来，更不会说出口。“你为什么理所当然评判我的对错？”心里想想还是有的，虽然也许时间非常短暂，一瞬而过，之后便忘记了。</p><p>另一原因是，回答“对”往往发生在“是……吗？”的疑问句或“是……吧？”的反问句中。“Java中的int是基本类型吗？” “对” “Java中的int是基本类型吧？” “对” 好像是再正常不过的对话，但是不是的问句为什么要用“对”来回答？更可笑的是，如果答案是否定的，回答的内容往往就变成了“不是”，而不是“不对”。有的人说话，连自己都毫无逻辑。</p><p>或许支持说“对”的观点在于，“对”可以给人带来微小的认可感，听到“对”的回答，也能感觉自己被认可。事实上，优秀的人不需要这种认可。</p><p>同理，常见口语中还有“好”和“行”之间的微小差异，等等。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;原因在于，“对”含有较多评判性的意味，“是”相对弱一些。我们从小接受的教育，对错太鲜明，对即1，错即0，全对即100，全错即0。当对话的两者没有明显的上下级关系、师从关系，可能将“对”用作口头禅会引起别人的小小不满，尽管这种不满不会表现出来，更不会说出口。“你为什么理所当然</summary>
        
      
    
    
    
    
    <category term="观点" scheme="https://smallyu.net/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>PHP 7，让代码更优雅（译）</title>
    <link href="https://smallyu.net/2018/11/01/PHP7%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E4%BC%98%E9%9B%85/"/>
    <id>https://smallyu.net/2018/11/01/PHP7%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E4%BC%98%E9%9B%85/</id>
    <published>2018-11-01T14:19:31.000Z</published>
    <updated>2024-08-03T19:07:09.972Z</updated>
    
    <content type="html"><![CDATA[<p>PHP 7已发布很久，它可以让代码更加简洁，让我们一睹其风采。</p><h3 id="标量类型声明"><a href="#标量类型声明" class="headerlink" title="标量类型声明"></a>标量类型声明</h3><p>标量指string、int、float和bool。PHP 7之前，如果要验证一个函数的参数类型，需要手动检测并抛出异常：</p><pre><code class="php">&lt;?phpfunction add($num1, $num2) &#123;    if (!is_int($num1)) &#123;        throw new Exception(&quot;$num1 is not an integer&quot;);    &#125;    if (!is_int($num2)) &#123;        throw new Exception(&quot;$num2 is not an integer&quot;);    &#125;    return ($num1 + $num2);&#125;echo add(2, 4);     // 6echo add(1.5, 4);   // Fatal error: Uncaught Exception</code></pre><p>现在，可以直接声明参数类型：</p><pre><code class="php">&lt;?phpfunction add(int $num1, int $num2) &#123;    return ($num1 + $num2);&#125;echo add(2, 4);     // 6echo add(&quot;2&quot;, 4);   // 6echo add(&quot;sonething&quot;, 4);   // Fatal error: Uncaught TypeError</code></pre><p>由于PHP默认运行在coercive模式，所以”2”被成功解析为2。可以使用declare函数启用严格模式：</p><pre><code class="php">&lt;?phpdeclare(strict_types=1);function add(int $num1, int $num2) &#123;    return ($num1 + $num2);&#125;echo add(2, 4);     // 6echo add(&quot;2&quot;, 4);   // Fatal error: Uncaught TypeError</code></pre><h3 id="返回类型声明"><a href="#返回类型声明" class="headerlink" title="返回类型声明"></a>返回类型声明</h3><p>像参数一样，现在返回值也可以指定类型：</p><pre><code class="php">&lt;?phpfunction add($num1, $num2):int &#123;    return ($num1 + $num2);&#125;echo add(2, 4);     // 6echo add(2.5, 4);   // 6</code></pre><p>2.5 + 4返回了int类型的6，这是隐式类型转换。如果要避免隐式转换，可以使用严格模式来抛出异常：</p><pre><code class="php">&lt;?phpdeclare(strict_types=1);function add($num1, $num2):int&#123;    return ($num1 + $num2);&#125;echo add(2, 4); //6echo add(2.5, 4); //Fatal error: Uncaught TypeError</code></pre><h3 id="空合并运算符"><a href="#空合并运算符" class="headerlink" title="空合并运算符"></a>空合并运算符</h3><p>在PHP5中，检测一个变量，如果未定义则为其赋初值，实现起来需要冗长的代码：</p><pre><code class="php">$username = isset($_GET[&#39;username]&#39;) ? $_GET[&#39;username&#39;] : &#39;&#39;;</code></pre><p>在PHP 7中，可以使用新增的”??”运算符：</p><pre><code class="php">$username = $_GET[&#39;username&#39;] ?? &#39;&#39;;</code></pre><p>这虽然仅仅是一个语法糖，但能让我们的代码简洁不少。</p><h3 id="太空船运算符"><a href="#太空船运算符" class="headerlink" title="太空船运算符"></a>太空船运算符</h3><p>也叫组合运算符，用于比较两表达式的大小。当$a小于、等于、大于$b时，分别返回-1、0、1。</p><pre><code class="php">echo 1 &lt;=&gt; 1;   // 0echo 1 &lt;=&gt; 2;   // -1echo 2 &lt;=&gt; 1;   // 1</code></pre><h3 id="批量导入声明"><a href="#批量导入声明" class="headerlink" title="批量导入声明"></a>批量导入声明</h3><p>在相同命名空间下的类、函数、常量，现在可以使用一个use表达式一次导入：</p><pre><code class="php">&lt;?php// PHP 7之前use net\smallyu\ClassA;use net\smallyu\ClassB;use net\smallyu\ClassC as C;use function net\smallyu\funA;use function net\smallyu\funB;use function net\smallyu\funC;use const net\smallyu\ConstA;use const net\smallyu\ConstB;use const net\smallyu\ConstC;// PHP 7use net\smallyu\&#123;ClassA, ClassB, ClassC&#125;;use function net\smallyu\&#123;funA, funB, funC&#125;;use const net\smallyu\&#123;ConstA, ConstB, ConstC&#125;;</code></pre><h3 id="生成器相关特性"><a href="#生成器相关特性" class="headerlink" title="生成器相关特性"></a>生成器相关特性</h3><p>PHP中Generator函数和普通函数的形式相同。生成器使用在foreach的迭代中，比数组占用内存更少，效率更高。这是一个生成器的例子：</p><pre><code class="php">&lt;?php// 返回一个生成器function getValues($max) &#123;    for ($i = 0; $i &lt; $max; $i++) &#123;        yield $i * 2;    &#125;&#125;// 使用生成器foreach(getValues(99999) as $value) &#123;    echo &quot;Values: $value \n&quot;;&#125;</code></pre><p>代码中出现了yield表达式，它就像return一样，在函数中返回一个值，每次只执行一次，并且会从上一次停止的位置开始执行。</p><p>PHP 7之前不允许生成器函数使用return返回值，现在允许了，return不会影响yield的正常迭代，return的值也可以使用$gen-&gt;getReturn()来获取：</p><pre><code class="php">&lt;?php$gen = (function() &#123;    yield &quot;First Yield&quot;;    yield &quot;Second Yield&quot;;    return &quot;return Value&quot;;&#125;)();foreach ($gen as $val) &#123;    echo $val, PHP_EOL;&#125;echo $gen-&gt;getReturn();</code></pre><p>PHP 7还支持生成器委派，可以在一个生成器函数中调用另一个生成器：</p><pre><code class="php">&lt;?phpfunction gen() &#123;    yield &quot;yield 1 from gen1&quot;;    yield &quot;yield 2 from gen1&quot;;    yield from gen2();&#125;function gen2() &#123;    yield &quot;yield 3 from gen2&quot;;    yield &quot;yield 4 from gen2&quot;;&#125;foreach (gen() as $val) &#123;    echo $val, PHP_EOL;&#125;</code></pre><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>PHP 7也有匿名类啦。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>PHP 7对闭包的支持更加友好：</p><pre><code class="php">&lt;?phpclass A &#123; private $x = 1; &#125;// PHP 7之前$getAFun = function() &#123;return $this-&gt;x;&#125;;$getA = $getAFun-&gt;bindTo(new A, &#39;A&#39;); // 中间层闭包echo $getA();// PHP 7之后$getA = function() &#123; return $this-&gt;x; &#125;;echo $getA-&gt;call(new A);</code></pre><h3 id="可为空类型"><a href="#可为空类型" class="headerlink" title="可为空类型"></a>可为空类型</h3><p>Nullable types是PHP 7.1的新特性之一，在参数类型声明前加上一个问号，约定该参数只能是指定类型或者NULL。可以用在返回类型上：</p><pre><code class="php">&lt;?phpfunction testReturn(): ?string &#123;    return &#39;testing&#39;;&#125;var_dump(testReturn());     // string(7) &quot;testing&quot;function testReturn2(): ?string &#123;    return null;&#125;var_dump(testReturn2());    //NULL</code></pre><p>也可以用在参数类型上：</p><pre><code class="php">&lt;?phpfunction test(?string $name) &#123;    var_dump($name);&#125;test(&#39;testing&#39;);    // string(7) &quot;testing&quot;test(null);         // NULLtest();     // Fatal error: Uncaught ArgumentCountError</code></pre><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>list()函数的简化写法：</p><pre><code class="php">&lt;?php$records = [    [1, &#39;smallyu&#39;],    [2, &#39;bigyu&#39;],];// list() 风格list($firstId, $firstName) = $records[0];// [] 风格，PHP 7.1[$firstId, $firstName] = $records[0];var_dump($firstId);     // int(1)var_dump($firstName);   // string(7) &quot;smallyu&quot;</code></pre><p>另一个新特性是list()和[]都支持keys了：</p><pre><code class="php">&lt;?php$records = [    [&quot;id&quot; =&gt; 1, &quot;name&quot; =&gt; &#39;smallyu&#39;],    [&quot;id&quot; =&gt; 2, &quot;name&quot; =&gt; &#39;bigyu&#39;],];// list() 风格list(&quot;id&quot; =&gt; $firstId, &quot;name&quot; =&gt; $firstName) = $records[0];// [] 风格，PHP 7.1[&quot;id&quot; =&gt; $firstId, &quot;name&quot; =&gt; $firstName] = $records[0];var_dump($firstId);     // int(1)var_dump($firstName);   // string(7) &quot;smallyu&quot;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p>《Building REATful Web Services with PHP 7》 Chapter 2: PHP 7, To Code It Better</p></li><li><p><a href="http://php.net/manual/zh/migration70.new-features.php">PHP: 新特性 - Manual</a></p></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;PHP 7已发布很久，它可以让代码更加简洁，让我们一睹其风采。&lt;/p&gt;
&lt;h3 id=&quot;标量类型声明&quot;&gt;&lt;a href=&quot;#标量类型声明&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 11 教程（译）</title>
    <link href="https://smallyu.net/2018/10/31/Java11%E6%95%99%E7%A8%8B/"/>
    <id>https://smallyu.net/2018/10/31/Java11%E6%95%99%E7%A8%8B/</id>
    <published>2018-10-31T02:20:56.000Z</published>
    <updated>2024-08-03T19:07:09.971Z</updated>
    
    <content type="html"><![CDATA[<p>Java 11已经发布，很多人还在使用Java 8。这篇教程讲述一些重要的语言特性和API。</p><h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h3><p>局部变量指在方法体内声明的变量。Java10就已经引进一个新的关键字var，用于代替在声明局部变量时候的类型声明。</p><p>在Java 10之前，你必须这样声明一个变量：</p><pre><code class="java">String text = &quot;Hello Java 9&quot;;</code></pre><p>现在你可以使用var代替String。编译器会自动从变量的赋值推断出正确的类型。如文本的类型为String：</p><pre><code class="java">var text = &quot;Hello Java 10&quot;;</code></pre><p>使用var声明的变量仍然是静态变量，不可以在声明后赋值为其它类型：</p><pre><code class="java">var text = &quot;Hello Java11&quot;;text = 23;  // 编译错误，不兼容的类型</code></pre><p>同样可以使用final声明变量为常量：</p><pre><code class="java">final var text = &quot;Banana&quot;;text = &quot;Joe&quot;;   // 编译错误</code></pre><p>当然，在编译器无法推断出类型的场景下，不可以使用var，比如这些情况：</p><pre><code class="java">var a;var nothing = null;var lamdba = () -&gt; System.out.println(&quot;Pity!&quot;);var method = this::someMethod;</code></pre><p>当变量声明包含泛型时，var的优势尤为突出，下面的示例就用var来代替冗长的Map&lt;String, List<Integer>&gt;：</p><pre><code class="java">var myList = new ArrayList&lt;Map&lt;String, List&lt;Integer&gt;&gt;&gt;();for (var current : myList) &#123;    // current 的类型会被推断为 Map&lt;String, List&lt;Integer&gt;&gt;    System.out.println(current);&#125;</code></pre><p>Java 11的var关键字同样支持在lamdba表达式的参数中使用，并且支持为这些参数添加注解：</p><pre><code class="java">Predicate&lt;String&gt; predicate = (@Nullable var a) -&gt; true;</code></pre><blockquote><p>小技巧：在Intellij IDEA中按住CTRL键可以查看变量的推断类型。</p></blockquote><h2 id="HTTP-Client"><a href="#HTTP-Client" class="headerlink" title="HTTP Client"></a>HTTP Client</h2><p>从Java 9开始引进试用新的API HttpClient，用于处理HTTP请求。现在Java 11将其标准化，我们可以从模块java.net中获取使用。</p><p>新的HttpClient在同步和异步场景下都可以使用。同步请求会阻塞线程，直到获取到响应。BodyHandlers定义了响应数据的类型（如String、Byte[]、File）。</p><pre><code class="java">var request = HttpRequest.newBuilder()        .uri(URI.create(&quot;https://blog.smallyu.net&quot;))        .GET()        .build();var client = HttpClient.newHttpClient();var response = client.send(request, HttpResponse.BodyHandlers.ofString());System.out.println(response.body());// 记得在module-info.java中导入java.net.http模块</code></pre><p>同样可以使用异步的方式实现请求，调用sendAsync方法并不会阻塞当前线程，它会构建异步操作流，在接收到响应后执行相应操作：</p><pre><code class="java">var request = HttpRequest.newBuilder()        .uri(URI.create(&quot;https://blog.smallyu.net&quot;))        .build();var client = HttpClient.newHttpClient();client.sendAsync(request, HttpResponse.BodyHandlers.ofString())        .thenApply(HttpResponse::body)        .thenAccept(System.out::println);// 线程睡眠，防止在返回响应前当前线程就结束Thread.sleep(3000);</code></pre><blockquote><p>.GET()方法会作为默认的请求方式。</p></blockquote><p>下一个示例通过POST方式发送请求到指定URL。与BodyHandlers相似，使用BodyPublishers定义要发送的数据类型：</p><pre><code class="java">var request = HttpRequest.newBuilder()        .uri(URI.create(&quot;https://postman-echo.com/post&quot;))        .header(&quot;Content-Type&quot;, &quot;text/plain&quot;)        .POST(HttpRequest.BodyPublishers.ofString(&quot;Hi there!&quot;))        .build();var client = HttpClient.newHttpClient();var response = client.send(request, HttpResponse.BodyHandlers.ofString());System.out.println(response.statusCode());      // 200</code></pre><p>最后一个示例演示了如何使用BASIC-AUTH执行权限验证：</p><pre><code class="java">var request = HttpRequest.newBuilder()    .uri(URI.create(&quot;https://postman-echo.com/basic-auth&quot;))    .build();var client = HttpClient.newBuilder()    .authenticator(new Authenticator() &#123;        @Override        protected PasswordAuthentication getPasswordAuthentication() &#123;            return new PasswordAuthentication(&quot;postman&quot;, &quot;password&quot;.toCharArray());        &#125;    &#125;)    .build();var response = client.send(request, HttpResponse.BodyHandlers.ofString());System.out.println(response.statusCode());      // 200</code></pre><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>集合框架如List、Set和Map都增加了新的方法。List.of方法根据给定参数创建一个不可变列表，List.copyOf创建一个已存在列表的副本。</p><pre><code class="java">var list = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);var copy = List.copyOf(list);System.out.println(list == copy);   // true</code></pre><p>因为列表已经不可变，所以拷贝出的列表和原列表是同一实例。如果拷贝了一个可变列表，拷贝出的列表会是一个新的实例，不会对原列表产生副作用：</p><pre><code class="java">var list = new ArrayList&lt;String&gt;();var copy = List.copyOf(list);System.out.println(list == copy);   // false</code></pre><p>创建不可变映射不必自己创建映射实体，只需要将key和value交替传入作为参数：</p><pre><code class="java">var map = Map.of(&quot;A&quot;, 1, &quot;B&quot;, 2);System.out.println(map);    // &#123;B=2, A=1&#125;</code></pre><blockquote><p>Java 11中的不可变列表和旧版本的列表使用相同的接口，但是如果你对不可变列表进行修改，如添加或移除元素，程序会抛出java.lang.UnsupportedOperationException异常。幸运的是，当你试图修改不可变列表，Intellij IDEA会检查并给出警告。</p></blockquote><h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>Streams从Java 8开始引进，现在新增了三个方法。Stream.ofNullable从单个元素构建流：</p><pre><code class="java">Stream.ofNullable(null)    .count()   // 0</code></pre><p>dropWhile和takeWhile方法都是用于放弃流中的一些元素：</p><pre><code class="java">Stream.of(1, 2, 3, 2, 1)    .dropWhile(n -&gt; n &lt; 3)    .collect(Collectors.toList());  // [3, 2, 1]Stream.of(1, 2, 3, 2, 1)    .takeWhile(n -&gt; n &lt; 3)    .collect(Collectors.toList());  // [1, 2]</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>String类也新增了一些方法：</p><pre><code class="java">&quot; &quot;.isBlank();                // true&quot; Foo Bar &quot;.strip();          // &quot;Foo Bar&quot;&quot; Foo Bar &quot;.stripTrailing();  // &quot; Foo Bar&quot;&quot; Foo Bar &quot;.stripLeading();   // &quot;Foo Bar &quot;&quot;Java&quot;.repeat(3);             // &quot;JavaJavaJava&quot;&quot;A\nB\nC&quot;.lines().count();    // 3</code></pre><h3 id="其他JVM特性"><a href="#其他JVM特性" class="headerlink" title="其他JVM特性"></a>其他JVM特性</h3><p>Java 11包含许多新特性，以上只提及冰山一角，权作抛砖引玉，更多内容等待你探索……</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://winterbe.com/posts/2018/09/24/java-11-tutorial/">Java 11 Tutorial</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Java 11已经发布，很多人还在使用Java 8。这篇教程讲述一些重要的语言特性和API。&lt;/p&gt;
&lt;h3 id=&quot;局部变量类型推断&quot;&gt;&lt;a href=&quot;#局部变量类型推断&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="编程语言" scheme="https://smallyu.net/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
